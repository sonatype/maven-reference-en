<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.discursive.com/docbook/xml/4.5/docbookx.dtd">
<chapter id="pom-relationships">
  <title>The Project Object Model</title>

  <section id="pom-relationships-sect-intro">
    <title>Introduction</title>

    <para><indexterm>
        <primary>Project Object Model (POM)</primary>
      </indexterm><indexterm>
        <primary>pom.xml</primary>
      </indexterm>This chapter covers the central concept of Maven—the Project
    Object<indexterm class="startofrange" id="pom1">
        <primary>POM (Project Object Model)</primary>
      </indexterm> Model. The <acronym>POM</acronym> is where a project’s
    identity and structure are declared, builds are configured, and projects
    are related to one another. The presence of a <filename
    moreinfo="none">pom.xml</filename> file defines a Maven project.</para>
  </section>

  <section id="pom-relationships-sect-pom">
    <title>The POM</title>

    <para><indexterm>
        <primary>Project Object Model (POM)</primary>

        <secondary>definition of</secondary>
      </indexterm>Maven projects, dependencies, builds, artifacts: all of
    these are objects to be modeled and described. These objects are described
    by an <acronym>XML</acronym> file called a Project Object Model. The
    <acronym>POM</acronym> tells Maven what sort of project it is dealing with
    and how to modify default behavior to generate output from source. In the
    same way a Java web application has a <filename
    moreinfo="none">web.xml</filename> that describes, configures, and
    customizes the application, a Maven project is defined by the presence
    of<indexterm>
        <primary>pom.xml file</primary>
      </indexterm><indexterm>
        <primary>pom.xml file</primary>

        <seealso>POM</seealso>
      </indexterm> a <filename moreinfo="none">pom.xml</filename>. It is a
    descriptive declaration of a project for Maven; it is the figurative “map”
    that Maven needs to understand what it is looking at when it builds your
    project.</para>

    <para><indexterm>
        <primary>Project Object Model (POM)</primary>

        <secondary>comparison to build.xml</secondary>
      </indexterm><indexterm>
        <primary>Project Object Model (POM)</primary>

        <secondary>comparison to Makefile</secondary>
      </indexterm>You could also think of the <filename
    moreinfo="none">pom.xml</filename> as analogous to a <filename
    moreinfo="none">Makefile</filename> or an Ant <filename
    moreinfo="none">build.xml</filename>. When you are using
    <acronym>GNU</acronym> <emphasis>make</emphasis> to build something like
    MySQL, you’ll usually have a file named <filename
    moreinfo="none">Makefile</filename> that contains explicit instructions
    for building a binary from source. When you are using Apache Ant, you
    likely have a file named <filename moreinfo="none">build.xml</filename>
    that contains explicit instructions for cleaning, compiling, packaging,
    and deploying an application. <emphasis>make</emphasis>, Ant, and Maven
    are similar in that they rely on the presence of a commonly named file
    such as <filename moreinfo="none">Makefile</filename>, <filename
    moreinfo="none">build.xml</filename>, or <filename
    moreinfo="none">pom.xml</filename>, but that is where the similarities
    end. If you look at a Maven <filename moreinfo="none">pom.xml</filename>,
    the majority of the <acronym>POM</acronym> is going to deal with
    descriptions: Where is the source code? Where are the resources? What is
    the packaging? If you look at an Ant <filename
    moreinfo="none">build.xml</filename> file, you’ll see something entirely
    different. You’ll see explicit instructions for tasks such as compiling a
    set of Java classes. The Maven <acronym>POM</acronym> is declarative, and
    although you can certainly choose to include some procedural
    customizations via the Maven Ant plugin, for the most part you will not
    need to get into the gritty procedural details of your project’s
    build.</para>

    <para>The <acronym>POM</acronym> is also not specific to building Java
    projects. While most of the examples in this book are geared towards Java
    applications, there is nothing Java-specific in the definition of a Maven
    Project Object Model. While Maven's default plugins are targeted at
    building <acronym>JAR</acronym> artifacts from a set of source, tests, and
    resources, there is nothing preventing you from defining a
    <acronym>POM</acronym> for a project that contains C# sources and produces
    some proprietary Microsoft binary using Microsoft tools. Similarly, there
    is nothing stopping you from defining a <acronym>POM</acronym> for a
    technical book. In fact, the source for this book and this book's examples
    is captured in a multi-module Maven project which uses one of the many
    Maven Docbook plugins to apply the standard Docbook <acronym>XSL</acronym>
    to a series of chapter <acronym>XML</acronym> files. Others have created
    Maven plugins to build Adobe Flex code into <acronym>SWC</acronym>s and
    <acronym>SWF</acronym>s, and yet others have used Maven to build projects
    written in C.</para>

    <para>We've established that the <acronym>POM</acronym> describes and
    declares, it is unlike Ant or Make in that it doesn't provide explicit
    instructions, and we've noted that <acronym>POM</acronym> concepts are not
    specific to Java. Diving into more specifics, take a look at <xref
    linkend="fig-pom" /> for a survey of the contents of a
    <acronym>POM</acronym>.</para>

    <para><figure id="fig-pom">
        <title>The Project Object Model</title>

        <mediaobject>
          <imageobject role="web">
            <imagedata fileref="figs/web/pom-relationships_pom-small.png" />
          </imageobject>

          <imageobject role="print">
            <imagedata align="center"
                       fileref="figs/print/pom-relationships_pom-small.pdf"
                       format="PDF" scalefit="0" width="100%" />
          </imageobject>
        </mediaobject>
      </figure></para>

    <para><indexterm>
        <primary>Project Object Model (POM)</primary>

        <secondary>contents of</secondary>
      </indexterm>The <acronym>POM</acronym> contains four categories of
    description and configuration:</para>

    <variablelist>
      <varlistentry>
        <term>General project information</term>

        <listitem>
          <para>This includes a project’s name, the <acronym>URL</acronym>
          for<indexterm>
              <primary>project information (in pom.xml)</primary>
            </indexterm><indexterm>
              <primary>licensing information (project information)</primary>
            </indexterm><indexterm>
              <primary>organizational information (project
              information)</primary>
            </indexterm><indexterm>
              <primary>developer information (project information)</primary>
            </indexterm><indexterm>
              <primary>pom.xml file</primary>

              <secondary>project information in</secondary>
            </indexterm> a project, the sponsoring organization, and a list of
          developers and contributors along with the license for a
          project.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>Build settings</term>

        <listitem>
          <para>In this section, we customize the behavior of the
          default<indexterm>
              <primary>build information (in pom.xml)</primary>
            </indexterm><indexterm>
              <primary>pom.xml file</primary>

              <secondary>build information in</secondary>
            </indexterm> Maven build. We can change the location of source and
          tests, we can add new plugins, we can attach plugin goals to the
          lifecycle, and we can customize the site generation
          parameters.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>Build environment</term>

        <listitem>
          <para>The build environment consists of profiles that can
          be<indexterm>
              <primary>build environment</primary>
            </indexterm><indexterm>
              <primary>pom.xml file</primary>

              <secondary>build environment</secondary>
            </indexterm> activated for use in different environments. For
          example, during development you may want to deploy to a development
          server, whereas in production you want to deploy to a production
          server. The build environment customizes the build settings for
          specific environments and is often supplemented by a
          custom<indexterm>
              <primary>settings.xml file</primary>
            </indexterm> <filename moreinfo="none">settings.xml</filename> in
          <filename moreinfo="none">~/.m2</filename>. This settings file is
          discussed in <xref linkend="profiles" /> and in the section <xref
          linkend="appendix-settings-sect-details" />.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>POM relationships</term>

        <listitem>
          <para>A project rarely stands alone; it depends on other projects,
          inherits <acronym>POM</acronym> settings from parent projects,
          defines its own coordinates, and may include submodules.</para>
        </listitem>
      </varlistentry>
    </variablelist>

    <section id="pom-relationships-sect-super-pom" label="">
      <title>The Super POM</title>

      <para><indexterm>
          <primary>Super POM</primary>
        </indexterm><indexterm>
          <primary>Project Object Model (POM)</primary>

          <secondary>Super POM</secondary>
        </indexterm>Before we dive into some examples of
      <acronym>POM</acronym>s, let's take a quick look at the Super
      <acronym>POM</acronym>. All Maven project <acronym>POM</acronym>s extend
      the Super <acronym>POM</acronym>, which defines a set of defaults shared
      by all projects. This Super <acronym>POM</acronym> is a part of the
      Maven installation and can be found in the
      <filename>maven-${maven.version}-uber.jar</filename> file in
      <filename>\${M2_HOME}/lib</filename>. If you look in this
      <acronym>JAR</acronym> file, you will find a file named
      <filename>pom-4.0.0.xml</filename> under the
      <package>org.apache.maven.project</package> package. The Super
      <acronym>POM</acronym> for Maven is shown in <xref
      linkend="ex-super-pom" />.</para>

      <example id="ex-super-pom">
        <title>The Super POM</title>

        <programlisting>&lt;project&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;name&gt;Maven Default Project&lt;/name&gt;

  &lt;repositories&gt;
    &lt;repository&gt;
      &lt;id&gt;central&lt;/id&gt; <co id="coDef-super-1"
            linkends="coRef-super-1" />
      &lt;name&gt;Maven Repository Switchboard&lt;/name&gt;
      &lt;layout&gt;default&lt;/layout&gt;
      &lt;url&gt;http://repo1.maven.org/maven2&lt;/url&gt;
      &lt;snapshots&gt;
        &lt;enabled&gt;false&lt;/enabled&gt;
      &lt;/snapshots&gt;
    &lt;/repository&gt;
  &lt;/repositories&gt;

  &lt;pluginRepositories&gt;
    &lt;pluginRepository&gt;
      &lt;id&gt;central&lt;/id&gt; <co id="coDef-super-2"
            linkends="coRef-super-2" />
      &lt;name&gt;Maven Plugin Repository&lt;/name&gt;
      &lt;url&gt;http://repo1.maven.org/maven2&lt;/url&gt;
      &lt;layout&gt;default&lt;/layout&gt;
      &lt;snapshots&gt;
        &lt;enabled&gt;false&lt;/enabled&gt;
      &lt;/snapshots&gt;
      &lt;releases&gt;
        &lt;updatePolicy&gt;never&lt;/updatePolicy&gt;
      &lt;/releases&gt;
    &lt;/pluginRepository&gt;
  &lt;/pluginRepositories&gt;

  &lt;build&gt; <co id="coDef-super-3" linkends="coRef-super-3" />
    &lt;directory&gt;\${project.basedir}/target&lt;/directory&gt;
    &lt;outputDirectory&gt;
      \${project.build.directory}/classes
    &lt;/outputDirectory&gt;
    &lt;finalName&gt;\${project.artifactId}-\${project.version}&lt;/finalName&gt;
    &lt;testOutputDirectory&gt;
      \${project.build.directory}/test-classes
    &lt;/testOutputDirectory&gt;
    &lt;sourceDirectory&gt;
      \${project.basedir}/src/main/java
    &lt;/sourceDirectory&gt;
    &lt;scriptSourceDirectory&gt;src/main/scripts&lt;/scriptSourceDirectory&gt;
    &lt;testSourceDirectory&gt;
      \${project.basedir}/src/test/java
    &lt;/testSourceDirectory&gt;
    &lt;resources&gt;
      &lt;resource&gt;
        &lt;directory&gt;\${project.basedir}/src/main/resources&lt;/directory&gt;
      &lt;/resource&gt;
    &lt;/resources&gt;
    &lt;testResources&gt;
      &lt;testResource&gt;
        &lt;directory&gt;\${project.basedir}/src/test/resources&lt;/directory&gt;
      &lt;/testResource&gt;
    &lt;/testResources&gt;


      &lt;pluginManagement&gt;<co id="coDef-super-4" linkends="coRef-super-4" />
       &lt;plugins&gt;
                  &lt;plugin&gt;
           &lt;artifactId&gt;maven-antrun-plugin&lt;/artifactId&gt;
           &lt;version&gt;1.3&lt;/version&gt;
         &lt;/plugin&gt;
         &lt;plugin&gt;
           &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;
           &lt;version&gt;2.2-beta-2&lt;/version&gt;
         &lt;/plugin&gt;
         &lt;plugin&gt;
           &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt;
           &lt;version&gt;2.2&lt;/version&gt;
         &lt;/plugin&gt;
         &lt;plugin&gt;
           &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
           &lt;version&gt;2.0.2&lt;/version&gt;
         &lt;/plugin&gt;
         &lt;plugin&gt;
           &lt;artifactId&gt;maven-dependency-plugin&lt;/artifactId&gt;
           &lt;version&gt;2.0&lt;/version&gt;
         &lt;/plugin&gt;
         &lt;plugin&gt;
           &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt;
           &lt;version&gt;2.4&lt;/version&gt;
         &lt;/plugin&gt;
         &lt;plugin&gt;
           &lt;artifactId&gt;maven-ear-plugin&lt;/artifactId&gt;
           &lt;version&gt;2.3.1&lt;/version&gt;
         &lt;/plugin&gt;
         &lt;plugin&gt;
           &lt;artifactId&gt;maven-ejb-plugin&lt;/artifactId&gt;
           &lt;version&gt;2.1&lt;/version&gt;
         &lt;/plugin&gt;
         &lt;plugin&gt;
           &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt;
           &lt;version&gt;2.2&lt;/version&gt;
         &lt;/plugin&gt;
         &lt;plugin&gt;
           &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt;
           &lt;version&gt;2.2&lt;/version&gt;
         &lt;/plugin&gt;
         &lt;plugin&gt;
           &lt;artifactId&gt;maven-javadoc-plugin&lt;/artifactId&gt;
           &lt;version&gt;2.5&lt;/version&gt;
         &lt;/plugin&gt;
         &lt;plugin&gt;
           &lt;artifactId&gt;maven-plugin-plugin&lt;/artifactId&gt;
           &lt;version&gt;2.4.3&lt;/version&gt;
         &lt;/plugin&gt;
         &lt;plugin&gt;
           &lt;artifactId&gt;maven-rar-plugin&lt;/artifactId&gt;
           &lt;version&gt;2.2&lt;/version&gt;
         &lt;/plugin&gt;
         &lt;plugin&gt;
           &lt;artifactId&gt;maven-release-plugin&lt;/artifactId&gt;
           &lt;version&gt;2.0-beta-8&lt;/version&gt;
         &lt;/plugin&gt;
         &lt;plugin&gt;
           &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt;
           &lt;version&gt;2.3&lt;/version&gt;
         &lt;/plugin&gt;
         &lt;plugin&gt;
           &lt;artifactId&gt;maven-site-plugin&lt;/artifactId&gt;
           &lt;version&gt;2.0-beta-7&lt;/version&gt;
         &lt;/plugin&gt;
         &lt;plugin&gt;
           &lt;artifactId&gt;maven-source-plugin&lt;/artifactId&gt;
           &lt;version&gt;2.0.4&lt;/version&gt;
         &lt;/plugin&gt;
         &lt;plugin&gt;
            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;
            &lt;version&gt;2.4.3&lt;/version&gt;
         &lt;/plugin&gt;
         &lt;plugin&gt;
           &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt;
           &lt;version&gt;2.1-alpha-2&lt;/version&gt;
         &lt;/plugin&gt;
       &lt;/plugins&gt;
     &lt;/pluginManagement&gt;
  
  &lt;reporting&gt;
    &lt;outputDirectory&gt;target/site&lt;/outputDirectory&gt;
  &lt;/reporting&gt;
&lt;/project&gt;</programlisting>
      </example>

      <para>The Super <acronym>POM</acronym> defines some standard
      configuration variables that are inherited by all projects. Those values
      are captured in the annotated sections:</para>

      <calloutlist>
        <callout arearefs="coDef-super-1" id="coRef-super-1">
          <para>The default Super <acronym>POM</acronym> defines a single
          remote Maven repository with an ID of <literal>central</literal>.
          This is the central Maven repository that all Maven clients are
          configured to read from by default. This setting can be overridden
          by a custom <filename moreinfo="none">settings.xml</filename> file.
          Note that the default Super <acronym>POM</acronym> has disabled
          snapshot artifacts on the central Maven repository. If you need to
          use a snapshot repository, you will need to customize repository
          settings in your <filename moreinfo="none">pom.xml</filename> or in
          your <filename moreinfo="none">settings.xml</filename>. Settings and
          profiles are covered in <xref linkend="profiles" /> and in <xref
          linkend="appendix-settings-sect-details" />.</para>
        </callout>

        <callout arearefs="coDef-super-2" id="coRef-super-2">
          <para>The central Maven repository also contains Maven plugins. The
          default plugin repository is the central Maven repository. Snapshots
          are disabled, and the update policy is set to “never,” which means
          that Maven will never automatically update a plugin if a new version
          is released.</para>
        </callout>

        <callout arearefs="coDef-super-3" id="coRef-super-3">
          <para>The <sgmltag>build</sgmltag> element sets the default values
          for directories in the Maven Standard Directory layout.</para>
        </callout>

        <callout arearefs="coDef-super-4" id="coRef-super-4">
          <para>Starting in Maven 2.0.9, default versions of core plugins have
          been provided in the Super <acronym>POM</acronym>. This was done to
          provide some stability for users that are not specifying versions in
          their <acronym>POM</acronym>s.</para>
        </callout>
      </calloutlist>

      <figure id="fig-super-always-base">
        <title>The Super POM is always the base Parent</title>

        <mediaobject>
          <imageobject role="web">
            <imagedata fileref="figs/web/pom-relationships_pom-inherit-simple-super.png" />
          </imageobject>

          <imageobject role="print">
            <imagedata align="center"
                       fileref="figs/print/pom-relationships_pom-inherit-simple-super.pdf"
                       format="PDF" scalefit="0" width="100%" />
          </imageobject>
        </mediaobject>
      </figure>
    </section>

    <section id="pom-relationships-sect-simplest-pom">
      <title>The Simplest POM</title>

      <para>All Maven <acronym>POM</acronym>s inherit defaults from the Super
      <acronym>POM</acronym> (introduced earlier in the section <xref
      linkend="pom-relationships-sect-super-pom" />). If you are just writing
      a simple project that produces a <acronym>JAR</acronym> from some source
      in <filename moreinfo="none">src/main/java</filename>, want to run your
      JUnit tests in <filename moreinfo="none">src/test/java</filename>, and
      want to build a project site using <command moreinfo="none">mvn
      site</command>, you don’t have to customize anything. All you would
      need, in this case, is the simplest possible <acronym>POM</acronym>
      shown in <xref linkend="ex-simplest-pom" />. This <acronym>POM</acronym>
      defines a <varname>groupId</varname>, <varname>artifactId</varname>, and
      <varname>version</varname>: the three required coordinates for every
      project.</para>

      <example id="ex-simplest-pom">
        <title>The Simplest POM</title>

        <programlisting language="xml">&lt;project&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;groupId&gt;org.sonatype.mavenbook.ch08&lt;/groupId&gt;
  &lt;artifactId&gt;simplest-project&lt;/artifactId&gt;
  &lt;version&gt;1&lt;/version&gt;
&lt;/project&gt;</programlisting>
      </example>

      <para>Such a simple <acronym>POM</acronym> would be more than adequate
      for a simple project—e.g., a Java library that produces a
      <acronym>JAR</acronym> file. It isn’t related to any other projects, it
      has no dependencies, and it lacks basic information such as a name and a
      <acronym>URL</acronym>. If you were to create this file and then create
      the subdirectory <filename moreinfo="none">src/main/java</filename> with
      some source code, running <command moreinfo="none">mvn package</command>
      would produce a <acronym>JAR</acronym> in <filename
      moreinfo="none">target/simple-project-1.jar</filename>.</para>
    </section>

    <section id="pom-relationships-sect-effective-pom">
      <title>The Effective POM</title>

      <para><indexterm>
          <primary>effective POM</primary>
        </indexterm><indexterm>
          <primary>Project Object Model (POM)</primary>

          <secondary>effective POM</secondary>
        </indexterm>This simplest <acronym>POM</acronym> brings us to the
      concept of <indexterm>
          <primary>effective POMs</primary>
        </indexterm>the “effective <acronym>POM</acronym>.” Since
      <acronym>POM</acronym>s can inherit configuration from other
      <acronym>POM</acronym>s, you must always think of a Maven
      <acronym>POM</acronym> in terms of the combination of the Super
      <acronym>POM</acronym>, plus any parent <acronym>POM</acronym>s, and
      finally the current project’s <acronym>POM</acronym>. Maven starts with
      the Super <acronym>POM</acronym> and then overrides default
      configuration with one or more parent <acronym>POM</acronym>s. Then it
      overrides the resulting configuration with the current project’s
      <acronym>POM</acronym>. You end up with an effective
      <acronym>POM</acronym> that is a mixture of various
      <acronym>POM</acronym>s. If you want to see a project’s effective
      <acronym>POM</acronym>, you’ll need to run the
      <varname>effective-pom</varname> goal in the Maven Help plugin, which is
      introduced in <xref linkend="installation-sect-help-plugin-install" />.
      To run the <varname>effective-pom</varname> goal, execute the following
      in a directory with a <filename moreinfo="none">pom.xml</filename>
      file:<indexterm>
          <primary>Help plugin</primary>

          <secondary>effective-pom goal</secondary>
        </indexterm></para>

      <screen>$ <command>mvn help:effective-pom</command></screen>

      <para>Executing the <varname>effective-pom</varname> goal should print
      out an <acronym>XML</acronym> document capturing the merge between the
      Super <acronym>POM</acronym> and the <acronym>POM</acronym> from <xref
      linkend="ex-simplest-pom" />.</para>
    </section>

    <section id="pom-relationships-sect-real-poms">
      <title>Real POMs</title>

      <para>Maven is something of a chameleon; you can pick and choose the
      features you want to take advantage of. Some open source projects may
      value the ability to list developers and contributors, generate clean
      project documentation, and manage releases automatically using the Maven
      Release plugin. On the other hand, someone working in a corporate
      environment on a small team might not be interested in the distribution
      management capabilities of Maven nor the ability to list developers. The
      remainder of this chapter is going to discuss features of the
      <acronym>POM</acronym> in isolation. Instead of bombarding you with a
      10-page listing of a set of related <acronym>POM</acronym>s, we’re going
      to focus on creating a good reference for specific sections of the
      <acronym>POM</acronym>. In this chapter, we discuss relationships
      between <acronym>POM</acronym>s, but we don’t illustrate such a project
      here.</para>
    </section>
  </section>

  <section id="pom-relationships-sect-pom-syntax">
    <title>POM Syntax</title>

    <para>The <acronym>POM</acronym> is always <indexterm class="startofrange"
        id="pom2">
        <primary>POM (Project Object Model)</primary>

        <secondary>syntax</secondary>
      </indexterm>in a file named <filename moreinfo="none">pom.xml</filename>
    in the base directory of a Maven project. This <acronym>XML</acronym>
    document can start with the <acronym>XML</acronym> declaration, or you can
    choose to omit it. All values in a <acronym>POM</acronym> are captured as
    <acronym>XML</acronym> elements.</para>

    <section id="pom-reationships-sect-versions">
      <title>Project Versions</title>

      <para><indexterm>
          <primary>version identifier</primary>

          <secondary>format of</secondary>
        </indexterm>A Maven project’s <sgmltag>version</sgmltag> encodes a
      release<indexterm>
          <primary>major versions (projects)</primary>
        </indexterm><indexterm>
          <primary>minor versions (projects)</primary>
        </indexterm><indexterm>
          <primary>incremental versions (projects)</primary>
        </indexterm><indexterm>
          <primary>qualifiers for project versions</primary>
        </indexterm><indexterm>
          <primary>project versions, about</primary>

          <seealso>version attribute</seealso>
        </indexterm><indexterm>
          <primary>version attribute (pom.xml)</primary>
        </indexterm><indexterm>
          <primary>project versions, about</primary>
        </indexterm> version number that is used to group and order releases.
      Maven versions contain the following parts: major version, minor
      version, incremental version, and qualifier. In a version, these parts
      correspond to the following format:</para>

      <screen>&lt;major version&gt;.&lt;minor version&gt;.&lt;incremental version&gt;-&lt;qualifier&gt;
</screen>

      <para>For example, the version "1.3.5" has a major version of 1, a minor
      version of 3, and an incremental version of 5. The version "5" has a
      major version of 5 and no minor or incremental version. The qualifier
      exists to capture milestone builds: alpha and beta releases, and the
      qualifier is separated from the major, minor, and incremental versions
      by a hyphen. For example, the version "1.3-beta-01" has a major version
      of 1, a minor version of 3, and a qualifier of "beta-01".</para>

      <para>Keeping your version numbers aligned with this standard will
      become very important when you want to start using version ranges in
      your <acronym>POM</acronym>s. Version ranges, introduced in <xref
      linkend="pom-relationships-sect-version-ranges" />, allow you to specify
      a dependency on a range of versions, and they are only supported because
      Maven has the ability to sort versions based on the version release
      number format introduced in this section.</para>

      <para>If your version release number matches the format
      <varname>&lt;major&gt;.&lt;minor&gt;.&lt;incremental&gt;-&lt;qualifier&gt;</varname>
      then your versions will be compared properly; "1.2.3" will be evaluated
      as a more recent build than "1.0.2", and the comparison will be made
      using the numeric values of the major, minor, and incremental versions.
      If your version release number does not fit the standard introduced in
      this section, then your versions will be compared as strings; "1.0.1b"
      will be compared to "1.2.0b" using a String comparison.</para>

      <section id="pom-relationships-sect-version-build-numbers">
        <title>Version Build Numbers</title>

        <para><indexterm>
            <primary>version identifier</primary>

            <secondary>build numbers</secondary>
          </indexterm><indexterm>
            <primary>Project Object Model (POM)</primary>

            <secondary>version identifier</secondary>
          </indexterm>One gotcha for release version numbers is the ordering
        of the <indexterm>
            <primary>ordering of version qualifiers</primary>
          </indexterm><indexterm>
            <primary>qualifiers for project versions</primary>

            <secondary>ordering of</secondary>
          </indexterm>qualifiers. Take the version release numbers
        “1.2.3-alpha-2” and “1.2.3-alpha-10,” where the “<phrase
        role="keep-together">alpha-2</phrase>” build corresponds to the 2nd
        alpha build, and the “alpha-10” build corresponds to the 10th alpha
        build. Even though “alpha-10” should be considered more recent than
        “alpha-2,” Maven is going to sort “alpha-10” before “alpha-2” due to a
        known issue in the way Maven handles version numbers.</para>

        <para>Maven is supposed to treat the number after the qualifier as a
        build number. In other words, the qualifier should be "alpha", and the
        build number should be 2. Even though Maven has been designed to
        separate the build number from the qualifier, this parsing is
        currently broken. As a result, "alpha-2" and "alpha-10" are compared
        using a String comparison, and "alpha-10" comes before "alpha-2"
        alphabetically. To get around this limitation, you will need to
        left-pad your qualified build numbers. If you use "alpha-02" and
        "alpha-10" this problem will go away, and it will continue to work
        once Maven properly parses the version build number.</para>
      </section>

      <section id="pom-relationships-sect-snapshot-versions">
        <title>SNAPSHOT Versions</title>

        <para><indexterm>
            <primary>version identifier</primary>

            <secondary>SNAPSHOT versions</secondary>
          </indexterm><indexterm>
            <primary>SNAPSHOT versions</primary>
          </indexterm>Maven versions can contain a string literal to signify
        that a <indexterm>
            <primary>snapshot versions</primary>
          </indexterm>project is currently under active development. If a
        version contains the string “SNAPSHOT,” then Maven will expand this
        token to a date and time value converted to <acronym>UTC</acronym>
        (Coordinated Universal Time) when you install or release this
        component. For example, if your project has a version of
        “1.0-SNAPSHOT” and you deploy this project’s artifacts to a Maven
        repository, Maven would expand this version to “1.0-20080207-230803-1”
        if you were to deploy a release at 11:08 PM on February 7th, 2008
        <acronym>UTC</acronym>. In other words, when you deploy a snapshot,
        you are not making a release of a software component; you are
        releasing a snapshot of a component at a specific time.</para>

        <para>Why would you use this? SNAPSHOT versions are used for projects
        under active development. If your project depends on a software
        component that is under active development, you can depend on a
        SNAPSHOT release, and Maven will periodically attempt to download the
        latest snapshot from a repository when you run a build. Similarly, if
        the next release of your system is going to have a version "1.4", your
        project would have a version "1.4-SNAPSHOT" until it was formally
        released.</para>

        <para>As a default setting, Maven will not check for SNAPSHOT releases
        on remote repositories. To depend on SNAPSHOT releases, users must
        explicitly enable the ability to download snapshots using a
        <sgmltag>repository</sgmltag> or <sgmltag>pluginRepository</sgmltag>
        element in the <acronym>POM</acronym>.</para>

        <para>When releasing a project, you should resolve all dependencies on
        SNAPSHOT versions to dependencies on released versions. If a project
        depends on a SNAPSHOT, it is not stable as the dependencies may change
        over time. Artifacts published to non-snapshot Maven repositories such
        as <ulink
        url="http://repo1.maven.org/maven2">http://repo1.maven.org/maven2</ulink>
        cannot depend on SNAPSHOT versions, as Maven's Super
        <acronym>POM</acronym> has snapshot's disabled from the Central
        repository. SNAPSHOT versions are for development only.</para>
      </section>
    </section>

    <section id="pom-relationships-sect-property-refs">
      <title>Property References</title>

      <para><indexterm>
          <primary>Project Object Model (POM)</primary>

          <secondary>property references</secondary>
        </indexterm><indexterm>
          <primary>properties</primary>
        </indexterm>A <acronym>POM</acronym> can include references to
      properties <indexterm>
          <primary>properties</primary>

          <secondary>referencing in pom.xml</secondary>
        </indexterm><indexterm>
          <primary>references to properties, in pom.xml</primary>
        </indexterm>preceded by a dollar sign and surrounded by two curly
      braces. For example, consider the following
      <acronym>POM</acronym>:</para>

      <programlisting language="xml">&lt;project&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;groupId&gt;org.sonatype.mavenbook&lt;/groupId&gt;
  &lt;artifactId&gt;project-a&lt;/artifactId&gt;
  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
  &lt;packaging&gt;jar&lt;/packaging&gt;
  &lt;build&gt;
    &lt;finalName&gt;\${project.groupId}-\${project.artifactId}&lt;/finalName&gt;
  &lt;/build&gt;
&lt;/project&gt;</programlisting>

      <para>If you put this <acronym>XML</acronym> in a
      <filename>pom.xml</filename> and run <command>mvn
      help:effective-pom</command>, you will see that the output contains the
      line:</para>

      <programlisting language="xml">...
&lt;finalName&gt;org.sonatype.mavenbook-project-a&lt;/finalName&gt;
...</programlisting>

      <para>When Maven reads a <acronym>POM</acronym>, it replaces references
      to properties when it loads the <acronym>POM</acronym>
      <acronym>XML</acronym>. Maven properties occur frequently in advanced
      Maven usage, and are similar to properties in other systems such as Ant
      or Velocity. They are simply variables delimited by
      <varname>\${...}</varname>. Maven provides three implicit variables
      which can be used to access environment variables,
      <acronym>POM</acronym> information, and Maven Settings:</para>

      <variablelist>
        <varlistentry>
          <term>env</term>

          <listitem>
            <para><indexterm>
                <primary>properties</primary>

                <secondary>environment variables</secondary>
              </indexterm>The <varname>env</varname> variable exposes
            environment <indexterm>
                <primary>env variable</primary>
              </indexterm><indexterm>
                <primary>implicit variables, list of</primary>
              </indexterm>variables exposed by your operating system or shell.
            For example, a reference to <varname>\${env.PATH}</varname> in a
            Maven <acronym>POM</acronym> would be replaced by the
            <varname>\${PATH}</varname> environment variable (or
            <varname>%PATH%</varname> in Windows).</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>project</term>

          <listitem>
            <para><indexterm>
                <primary>properties</primary>

                <secondary>project variables</secondary>
              </indexterm>The <varname>project</varname> variable exposes
            the<indexterm>
                <primary>project variable</primary>
              </indexterm> <acronym>POM</acronym>. You can use a dot-notated
            (.) path to reference the value of a <acronym>POM</acronym>
            element. For example, in this section we used the
            <varname>groupId</varname> and <varname>artifactId</varname> to
            set the <sgmltag>finalName</sgmltag> element in the build
            configuration. The syntax for this property reference was:
            <code>\${project.groupId}-\${project.</code><code>artifactId}</code>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>settings</term>

          <listitem>
            <para><indexterm>
                <primary>properties</primary>

                <secondary>settings variables</secondary>
              </indexterm>The <varname>settings</varname> variable exposes
            Maven <indexterm>
                <primary>settings variable</primary>
              </indexterm>settings information. You can use a dot-notated (.)
            path to reference the value of an element in a <filename
            moreinfo="none">settings.xml</filename> file. For example,
            <varname>\${settings.offline}</varname> would reference the value
            of the <sgmltag>offline</sgmltag> element in <filename
            moreinfo="none">~/.m2/settings.xml</filename>.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <note>
        <para>You may see older builds that use <varname>\${pom.xxx}</varname>
        or just <varname>\${xxx}</varname> to reference <acronym>POM</acronym>
        properties. These methods have been deprecated and only
        <varname>\${project.xxx}</varname> should be used.</para>
      </note>

      <para>In addition to the three implicit variables, you can reference
      <indexterm>
          <primary>system properties, referencing</primary>
        </indexterm>system properties and any custom properties set in the
      Maven <acronym>POM</acronym> or in a build profile:</para>

      <variablelist>
        <varlistentry>
          <term>Java System Properties</term>

          <listitem>
            <para><indexterm>
                <primary>properties</primary>

                <secondary>Java system properties</secondary>
              </indexterm>All properties accessible via<indexterm>
                <primary>Java system properties, referencing</primary>
              </indexterm> <methodname>getProperties()</methodname> on
            <classname>java.lang.System</classname> are exposed as
            <acronym>POM</acronym> properties. Some examples of system
            properties are: <varname>\${user.name}</varname>, <varname
            role="keep-together">\${user.home}</varname>,
            <varname>\${java.home}</varname>, and
            <varname>\${os.name}</varname>. A full list of system properties
            can be found in the Javadoc for the
            <classname>java.lang.System</classname> class.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>x</term>

          <listitem>
            <para><indexterm>
                <primary>properties</primary>

                <secondary>arbitrary properties</secondary>
              </indexterm>Arbitrary properties can be set with a<indexterm>
                <primary>arbitrary properties, referencing</primary>
              </indexterm> <varname>properties</varname> element in a
            <filename moreinfo="none">pom.xml</filename> or <filename
            moreinfo="none" role="keep-together">settings.xml</filename>, or
            properties can be loaded from external files. If you set a
            property named <varname>fooBar</varname> in your <filename
            moreinfo="none">pom.xml</filename>, that same property is
            referenced with <varname>\${fooBar}</varname>. Custom properties
            come in handy when you are building a system that filters
            resources and targets different deployment platforms. Here is the
            syntax for setting <literal>\${foo}=bar</literal> in a
            <acronym>POM</acronym>:</para>

            <programlisting language="xml">&lt;properties&gt;
  &lt;foo&gt;bar&lt;/foo&gt;
&lt;/properties&gt;</programlisting>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>For a more comprehensive list of available properties, see <xref
      linkend="resource-filtering" />.</para>
    </section>
  </section>

  <section id="pom-relationships-sect-project-dependencies">
    <title>Project Dependencies</title>

    <para>Maven can manage both internal and external dependencies.
    An<indexterm class="startofrange" id="pom3a">
        <primary>dependencies</primary>
      </indexterm><indexterm>
        <primary>Project Object Model (POM)</primary>

        <secondary>project dependencies</secondary>

        <see>dependencies</see>
      </indexterm><indexterm>
        <primary>project dependencies</primary>

        <see>dependencies</see>
      </indexterm><indexterm>
        <primary>external dependencies</primary>
      </indexterm><indexterm>
        <primary>internal dependencies</primary>

        <seealso>dependencies</seealso>
      </indexterm><indexterm>
        <primary>internal dependencies</primary>

        <seealso>dependencies</seealso>
      </indexterm> external dependency for a Java project might be a library
    such as Plexus, the Spring Framework, or Log4J. An internal dependency is
    illustrated by a web application project depending on another project that
    contains service classes, model objects, or persistence logic. <xref
    linkend="ex-dependency" /> shows some examples of project
    dependencies.</para>

    <para><example id="ex-dependency">
        <title>Project Dependencies</title>

        <programlisting language="xml">&lt;project&gt;
  ...
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.codehaus.xfire&lt;/groupId&gt;
      &lt;artifactId&gt;xfire-java5&lt;/artifactId&gt;
      &lt;version&gt;1.2.5&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;junit&lt;/groupId&gt;
      &lt;artifactId&gt;junit&lt;/artifactId&gt;
      &lt;version&gt;3.8.1&lt;/version&gt;
      &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
      &lt;artifactId&gt;servlet-api&lt;/artifactId&gt;
      &lt;version&gt;2.4&lt;/version&gt;
      &lt;scope&gt;provided&lt;/scope&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
  ...
&lt;/project&gt;
</programlisting>
      </example></para>

    <para>The first dependency is a compile dependency on the XFire
    <acronym>SOAP</acronym> library from Codehaus. You would use this type of
    dependency if your project depended on this library for compilation,
    testing, and during execution. The second dependency is a
    <literal>test</literal>-scoped dependency on JUnit. You would use a
    <literal>test</literal>-scoped dependency when you need to reference this
    library only during testing. The last dependency in <xref
    linkend="ex-dependency" /> is a dependency on the Servlet 2.4
    <acronym>API</acronym>. The last dependency is scoped as a provided
    dependency. You would use a provided scope when the application you are
    developing needs a library for compilation and testing, but this library
    is supplied by a container at runtime.</para>

    <section id="pom-relationships-sect-dependency-scope">
      <title>Dependency Scope</title>

      <para><xref linkend="ex-dependency" /> briefly introduced three of the
      <indexterm>
          <primary>scope, dependency</primary>
        </indexterm><indexterm>
          <primary>dependencies</primary>

          <secondary>scope of</secondary>
        </indexterm>five dependency scopes: <literal>compile</literal>,
      <literal>test</literal>, and <literal>provided</literal>. Scope controls
      which dependencies are available in which classpath, and which
      dependencies are included with an application. Let’s explore each scope
      in detail:<indexterm>
          <primary>dependency management</primary>
        </indexterm></para>

      <variablelist>
        <varlistentry>
          <term>compile</term>

          <listitem>
            <para><literal><indexterm>
                <primary>dependency management</primary>

                <secondary>compile scope</secondary>
              </indexterm>compile</literal> is the default scope; all
            dependencies are <indexterm>
                <primary>compile dependencies</primary>
              </indexterm><literal>compile</literal>-scoped if a scope is not
            supplied. <literal>compile</literal> dependencies are available in
            all classpaths, and they are packaged.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>provided</term>

          <listitem>
            <para><literal><indexterm>
                <primary>dependency management</primary>

                <secondary>provided scope</secondary>
              </indexterm>provided</literal> dependencies are used when you
            expect the <acronym>JDK</acronym> or a container to provide them.
            For <indexterm>
                <primary>provided dependencies</primary>
              </indexterm>example, if you were developing a web application,
            you would need the Servlet <acronym>API</acronym> available on the
            compile classpath to compile a servlet, but you wouldn’t want to
            include the Servlet <acronym>API</acronym> in the packaged
            <acronym>WAR</acronym>; the Servlet <acronym>API</acronym>
            <acronym>JAR</acronym> is supplied by your application server or
            servlet container. <literal>provided</literal> dependencies are
            available on the compilation classpath (not runtime). They are not
            transitive, nor are they packaged.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>runtime</term>

          <listitem>
            <para><literal><indexterm>
                <primary>dependency management</primary>

                <secondary>runtime scope</secondary>
              </indexterm>runtime</literal> dependencies are required to
            execute and test the <indexterm>
                <primary>runtime dependencies</primary>
              </indexterm>system, but they are not required for compilation.
            For example, you may need a <acronym>JDBC</acronym>
            <acronym>API</acronym> <acronym>JAR</acronym> at compile time and
            the <acronym>JDBC</acronym> driver implementation only at
            runtime.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>test</term>

          <listitem>
            <para><literal><indexterm>
                <primary>dependency management</primary>

                <secondary>test scope</secondary>
              </indexterm>test</literal>-scoped dependencies are not required
            during the normal<indexterm>
                <primary>dependencies</primary>

                <secondary>test-scoped</secondary>
              </indexterm><indexterm>
                <primary>test-scoped dependencies</primary>
              </indexterm><indexterm>
                <primary>unit tests</primary>

                <secondary>test-scoped dependencies</secondary>
              </indexterm><indexterm>
                <primary>testing</primary>

                <secondary>using test-scoped dependencies</secondary>
              </indexterm> operation of an application, and they are available
            only during test compilation and execution phases.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>system</term>

          <listitem>
            <para><indexterm>
                <primary>dependency management</primary>

                <secondary>system scope</secondary>
              </indexterm>The <literal>system</literal> scope is similar to
            <literal>provided</literal> except that you have to <indexterm>
                <primary>system-scope dependencies</primary>
              </indexterm>provide an explicit path to the
            <acronym>JAR</acronym> on the local file system. This is intended
            to allow compilation against native objects that may be part of
            the system libraries. The artifact is assumed to always be
            available and is not looked up in a repository. If you declare the
            scope to be <literal>system</literal>, you must also provide the
            <sgmltag>systemPath</sgmltag> element. Note that this scope is not
            recommended (you should always try to reference dependencies in a
            public or custom Maven repository).</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section id="pom-relationships-sect-optional">
      <title>Optional Dependencies</title>

      <para><indexterm>
          <primary>dependency management</primary>

          <secondary>optional dependencies</secondary>
        </indexterm>Assume that you are working on a library that provides
      caching <indexterm>
          <primary>optional dependencies</primary>
        </indexterm><indexterm>
          <primary>dependencies</primary>

          <secondary>optional</secondary>
        </indexterm>behavior. Instead of writing a caching system from
      scratch, you want to use some of the existing libraries that provide
      caching on the file system and distributed caches. Also assume that you
      want to give the end user an option to cache on the file system or to
      use an in-memory distributed cache. To cache on the file system, you’ll
      want to use a freely available library called EHCache (<ulink
      url="http://ehcache.sourceforge.net/">http://ehcache.sourceforge.net/</ulink>),
      and to cache in a distributed <phrase
      role="keep-together">in-memory</phrase> cache, you want to use another
      freely available caching library named SwarmCache (<ulink
      url="http://swarmcache.sourceforge.net/">http://swarmcache.sourceforge.net/</ulink>).
      You’ll code an interface and create a library that can be configured to
      use either EHCache or SwarmCache, but you want to avoid adding a
      dependency on both caching libraries to any project that depends on your
      library.</para>

      <para>In other words, you need both libraries to compile this library
      project, but you don't want both libraries to show up as transitive
      runtime dependencies for the project that uses your library. You can
      accomplish this by using optional dependencies as shown in <xref
      linkend="ex-optional-depend" />.</para>

      <example id="ex-optional-depend">
        <title>Declaring Optional Dependencies</title>

        <programlisting language="xml">&lt;project&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;groupId&gt;org.sonatype.mavenbook&lt;/groupId&gt;
  &lt;artifactId&gt;my-project&lt;/artifactId&gt;
  &lt;version&gt;1.0.0&lt;/version&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;net.sf.ehcache&lt;/groupId&gt;
      &lt;artifactId&gt;ehcache&lt;/artifactId&gt;
      &lt;version&gt;1.4.1&lt;/version&gt;
      &lt;optional&gt;true&lt;/optional&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;swarmcache&lt;/groupId&gt;
      &lt;artifactId&gt;swarmcache&lt;/artifactId&gt;
      &lt;version&gt;1.0RC2&lt;/version&gt;
      &lt;optional&gt;true&lt;/optional&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;log4j&lt;/groupId&gt;
      &lt;artifactId&gt;log4j&lt;/artifactId&gt;
      &lt;version&gt;1.2.13&lt;/version&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
&lt;/project&gt;</programlisting>
      </example>

      <para>Since you've declared these dependencies as optional in
      <varname>my-project</varname>, if you've defined a project that depends
      on <varname>my-project</varname> which needs those dependencies, you'll
      have to include them explicitly in the project that depends on
      <varname>my-project</varname>. For example, if you were writing an
      application which depended on <varname>my-project</varname> and wanted
      to use the EHCache implementation, you would need to add the following
      <sgmltag>dependency</sgmltag> element to your project.</para>

      <programlisting language="xml">&lt;project&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;groupId&gt;org.sonatype.mavenbook&lt;/groupId&gt;
  &lt;artifactId&gt;my-application&lt;/artifactId&gt;
  &lt;version&gt;1.0.0&lt;/version&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.sonatype.mavenbook&lt;/groupId&gt;
      &lt;artifactId&gt;my-project&lt;/artifactId&gt;
      &lt;version&gt;1.0.0&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;net.sf.ehcache&lt;/groupId&gt;
      &lt;artifactId&gt;swarmcache&lt;/artifactId&gt;
      &lt;version&gt;1.4.1&lt;/version&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
&lt;/project&gt;</programlisting>

      <para>In an ideal world, you wouldn’t have to use optional dependencies.
      Instead of having one large project with a series of optional
      dependencies, you would separate the <phrase
      role="keep-together">EHCache-specific</phrase> code to a
      <varname>my-project-ehcache</varname> submodule and the
      SwarmCache-specific code to a <varname>my-project-swarmcache</varname>
      submodule. This way, instead of requiring projects that reference
      <varname>my-project</varname> to specifically add a dependency, projects
      can just reference a particular implementation project and benefit from
      the transitive dependency.</para>
    </section>

    <section id="pom-relationships-sect-version-ranges">
      <title>Dependency Version Ranges</title>

      <para><indexterm>
          <primary>version ranges</primary>
        </indexterm><indexterm>
          <primary>dependency management</primary>

          <secondary>version ranges</secondary>
        </indexterm>You don’t just have to depend on a specific version of
      a<indexterm>
          <primary>version attribute (pom.xml)</primary>

          <secondary>dependency version ranges</secondary>
        </indexterm><indexterm>
          <primary>project versions, about</primary>

          <secondary>dependency version ranges</secondary>
        </indexterm><indexterm>
          <primary>ranges for dependency versions</primary>
        </indexterm> dependency; you can specify a range of versions that
      would satisfy a given dependency. For example, you can specify that your
      project depends on version 3.8 or greater of JUnit, or anything between
      versions 1.2.10 and 1.2.14 of JUnit. You do this by surrounding one or
      more version numbers with the following characters:</para>

      <variablelist>
        <varlistentry>
          <term role="plain">(, )</term>

          <listitem>
            <para>Exclusive quantifiers</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term role="plain">[, ]</term>

          <listitem>
            <para>Inclusive quantifiers</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>For example, if you wished to access any <code>JUnit</code>
      version greater than or equal to 3.8 but less than 4.0, your dependency
      would be as shown in <xref linkend="ex-dep-range" />.</para>

      <para><example id="ex-dep-range">
          <title>Specifying a Dependency Range: JUnit 3.8 - JUnit 4.0</title>

          <programlisting language="xml">&lt;dependency&gt;
  &lt;groupId&gt;junit&lt;/groupId&gt;
  &lt;artifactId&gt;junit&lt;/artifactId&gt;
  &lt;version&gt;[3.8,4.0)&lt;/version&gt;
  &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
</programlisting>
        </example></para>

      <para>If you want to depend on any version of JUnit no higher
      than<indexterm>
          <primary>upper boundaries (version ranges)</primary>
        </indexterm><indexterm>
          <primary>inclusive boundaries (version ranges)</primary>
        </indexterm><indexterm>
          <primary>lower boundaries (version ranges)</primary>
        </indexterm><indexterm>
          <primary>exclusive boundaries (version ranges)</primary>
        </indexterm><indexterm>
          <primary>boundaries for version ranges, specifying</primary>
        </indexterm> 3.8.1, you would specify only an upper inclusive
      boundary, as shown in <xref linkend="ex-dep-range-2" />.</para>

      <example id="ex-dep-range-2">
        <title>Specifying a Dependency Range: JUnit &lt;= 3.8.1</title>

        <programlisting language="xml">&lt;dependency&gt;
  &lt;groupId&gt;junit&lt;/groupId&gt;
  &lt;artifactId&gt;junit&lt;/artifactId&gt;
  &lt;version&gt;[,3.8.1]&lt;/version&gt;
  &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
</programlisting>
      </example>

      <para>A version before or after the comma is not required, and means +/-
      infinity. For example, "[4.0,)" means any version greater than or equal
      to 4.0. "(,2.0)" is any version less than 2.0. "[1.2]" means only
      version 1.2, and nothing else.</para>

      <note>
        <para>When declaring a "normal" version such as 3.8.2 for Junit,
        internally this is represented as "allow anything, but prefer 3.8.2."
        This means that when a conflict is detected, Maven is allowed to use
        the conflict algorithms to choose the best version. If you specify
        [3.8.2], it means that only 3.8.2 will be used and nothing else. If
        somewhere else there is a dependency that specifies [3.8.1], you would
        get a build failure telling you of the conflict. We point this out to
        make you aware of the option, but use it sparingly and only when
        really needed. The preferred way to resolve this is via
        <sgmltag>dependencyManagement</sgmltag>.</para>
      </note>
    </section>

    <section id="pom-relationships-sect-transitive">
      <title>Transitive Dependencies</title>

      <para><indexterm>
          <primary>dependency management</primary>

          <secondary>transitive dependencies</secondary>
        </indexterm>A transitive dependency is a dependency of a dependency.
      If<indexterm>
          <primary>transitive dependencies</primary>
        </indexterm><indexterm>
          <primary>dependencies</primary>

          <secondary>transitive</secondary>

          <see>transitive dependencies</see>
        </indexterm> <varname>project-a</varname> depends on
      <varname>project-b</varname>, which in turn depends on
      <varname>project-c</varname>, then <varname>project-c</varname> is
      considered a transitive dependency of <varname>project-a</varname>. If
      <varname>project-c</varname> depended on <varname>project-d</varname>,
      then <varname>project-d</varname> would also be considered a transitive
      dependency of <varname>project-a</varname>. Part of Maven’s appeal is
      that it can manage transitive dependencies and shield the developer from
      having to keep track of all of the dependencies required to compile and
      run an application. You can just depend on something like the Spring
      Framework and not have to worry about tracking down every last
      dependency of the Spring Framework.</para>

      <para>Maven accomplishes this by building a graph of dependencies and
      dealing with any conflicts and overlaps that might occur. For example,
      if Maven sees that two projects depend on the same
      <varname>groupId</varname> and <varname>artifactId</varname>, it will
      sort out which dependency to use automatically, always favoring the more
      recent version of a dependency. Although this sounds convenient, there
      are some edge cases where transitive dependencies can cause some
      configuration issues. For these scenarios, you can use a dependency
      exclusion.</para>

      <section id="pom-relationships-sect-transitive-scope">
        <title>Transitive Dependencies and Scope</title>

        <para>Each of the scopes outlined earlier in the section <xref
        linkend="pom-relationships-sect-dependency-scope" /> affects not just
        the scope of <indexterm>
            <primary>scope, dependency</primary>

            <secondary>transitive dependencies and</secondary>
          </indexterm>the dependency in the declaring project, but also how it
        acts as a transitive dependency. The easiest way to convey this
        information is through a table, as in <xref
        linkend="table-transitive-dep-and-scope" />. Scopes in the top row
        represent the scope of a transitive dependency. Scopes in the leftmost
        column represent the scope of a direct dependency. The intersection of
        the row and column is the scope that is assigned to a transitive
        dependency. A blank cell in this table means that the transitive
        dependency will be omitted.</para>

        <para><table id="table-transitive-dep-and-scope">
            <title>How Scope Affects Transitive Dependencies</title>

            <tgroup cols="5">
              <thead>
                <row>
                  <entry>Direct Scope</entry>

                  <entry>Transitive Scope</entry>
                </row>
              </thead>

              <tbody>
                <row>
                  <entry></entry>

                  <entry><emphasis>compile</emphasis></entry>

                  <entry><emphasis>provided</emphasis></entry>

                  <entry><emphasis>runtime</emphasis></entry>

                  <entry><emphasis>test</emphasis></entry>
                </row>

                <row>
                  <entry><emphasis>compile</emphasis></entry>

                  <entry>compile</entry>

                  <entry>-</entry>

                  <entry>runtime</entry>

                  <entry>-</entry>
                </row>

                <row>
                  <entry><emphasis>provided</emphasis></entry>

                  <entry>provided</entry>

                  <entry>provided</entry>

                  <entry>provided</entry>

                  <entry>-</entry>
                </row>

                <row>
                  <entry><emphasis>runtime</emphasis></entry>

                  <entry>runtime</entry>

                  <entry>-</entry>

                  <entry>runtime</entry>

                  <entry>-</entry>
                </row>

                <row>
                  <entry><emphasis>test</emphasis></entry>

                  <entry>test</entry>

                  <entry>-</entry>

                  <entry>test</entry>

                  <entry>-</entry>
                </row>
              </tbody>
            </tgroup>
          </table></para>

        <para>To illustrate the relationship of transitive dependency scope to
        direct dependency scope, consider the following example. If
        <varname>project-a</varname> contains a test scoped dependency on
        <varname>project-b</varname> which contains a compile scoped
        dependency on <varname>project-c</varname>.
        <varname>project-c</varname> would be a test-scoped transitive
        dependency of <varname>project-a</varname>.</para>

        <para>You can think of this as a transitive boundary which acts as a
        filter on dependency scope. Transitive dependencies which are provided
        and test scope usually do not affect a project. The exception to this
        rule is that a provided scoped transitive dependency to a provided
        scope direct dependency is still a provided dependency of a project.
        Transitive dependencies which are compile and runtime scoped usually
        affect a project regardless of the scope of a direct dependency.
        Transitive dependencies which are compile scoped will have the same
        scope regardless of the scope of the direct dependency. Transitive
        dependencies which are runtime scoped will generally have the same
        scope of the direct dependency except when the direct dependency has a
        scope of compile. When a transitive dependency is runtime scoped and a
        direct is compile scoped the direct dependency the transitive
        dependency will have an effective scope of runtime.</para>
      </section>
    </section>

    <section id="pom-relationships-sect-conflict">
      <title>Conflict Resolution</title>

      <para>There will be times when you need to exclude a
      transitive<indexterm>
          <primary>conflict, dependency</primary>
        </indexterm><indexterm>
          <primary>resolving dependency conflicts</primary>
        </indexterm><indexterm>
          <primary>dependencies</primary>

          <secondary>conflicts with, resolving</secondary>
        </indexterm><indexterm>
          <primary>transitive dependencies</primary>

          <secondary>resolving conflicts with</secondary>
        </indexterm><indexterm>
          <primary>excluding transitive dependencies</primary>
        </indexterm><indexterm>
          <primary>replacing transitive dependencies</primary>
        </indexterm> dependency, such as when you are depending on a project
      that depends on another project, but you would like to either exclude
      the dependency altogether or replace the transitive dependency with
      another dependency that provides the same functionality. <xref
      linkend="ex-exclude" /> shows an example of a dependency element that
      adds a dependency on <varname>project-a</varname>, but excludes the
      transitive dependency <varname>project-b</varname>.<indexterm>
          <primary>excluding transitive dependencies</primary>
        </indexterm></para>

      <para><example id="ex-exclude">
          <title>Excluding a Transitive Dependency</title>

          <programlisting language="xml">&lt;dependency&gt;
  &lt;groupId&gt;org.sonatype.mavenbook&lt;/groupId&gt;
  &lt;artifactId&gt;project-a&lt;/artifactId&gt;
  &lt;version&gt;1.0&lt;/version&gt;
  &lt;exclusions&gt;
    &lt;exclusion&gt;
      &lt;groupId&gt;org.sonatype.mavenbook&lt;/groupId&gt;
      &lt;artifactId&gt;project-b&lt;/artifactId&gt;
    &lt;/exclusion&gt;
  &lt;/exclusions&gt;
&lt;/dependency&gt;</programlisting>
        </example></para>

      <para>Often, you will want to replace a transitive dependency with
      another implementation. For example, if you are depending on a library
      that depends on the Sun <acronym>JTA</acronym> <acronym>API</acronym>,
      you may want to replace the declared transitive dependency. Hibernate is
      one example. Hibernate depends on the Sun <acronym>JTA</acronym>
      <acronym>API</acronym> <acronym>JAR</acronym>, which is not available in
      the central Maven repository because it cannot be freely redistributed.
      Fortunately, the Apache Geronimo project has created an independent
      implementation of this library that can be freely redistributed. To
      replace a transitive dependency with another dependency, you would
      exclude the transitive dependency and declare a dependency on the
      project you wanted instead. <xref linkend="ex-exclude-replace" /> shows
      an example of a such replacement.</para>

      <example id="ex-exclude-replace">
        <title>Excluding and Replacing a Transitive Dependency</title>

        <programlisting language="xml">&lt;dependencies&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
    &lt;artifactId&gt;hibernate&lt;/artifactId&gt;
    &lt;version&gt;3.2.5.ga&lt;/version&gt;
    &lt;exclusions&gt;
      &lt;exclusion&gt;
        &lt;groupId&gt;javax.transaction&lt;/groupId&gt;
        &lt;artifactId&gt;jta&lt;/artifactId&gt;
      &lt;/exclusion&gt;
    &lt;/exclusions&gt;
  &lt;/dependency&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.apache.geronimo.specs&lt;/groupId&gt;
    &lt;artifactId&gt;geronimo-jta_1.1_spec&lt;/artifactId&gt;
    &lt;version&gt;1.1&lt;/version&gt;
  &lt;/dependency&gt;
&lt;/dependencies&gt;</programlisting>
      </example>

      <para>In <xref linkend="ex-exclude-replace" />, there is nothing marking
      the dependency on <varname>geronimo-jta_1.1_spec</varname> as a
      replacement, it just happens to be a library which provides the same
      <acronym>API</acronym> as the original <acronym>JTA</acronym>
      dependency. Here are some other reasons you might want to exclude or
      replace transitive dependencies:</para>

      <orderedlist>
        <listitem>
          <para>The <varname>groupId</varname> or
          <varname>artifactId</varname> of the artifact has changed, where the
          current project requires an alternately named version from a
          dependency's version - resulting in 2 copies of the same project in
          the classpath. Normally Maven would capture this conflict and use a
          single version of the project, but when <varname>groupId</varname>
          or <varname>artifactId</varname> are different, Maven will consider
          this to be two different libraries.</para>
        </listitem>

        <listitem>
          <para>An artifact is not used in your project and the transitive
          dependency has not been marked as an optional dependency. In this
          case, you might want to exclude a dependency because it isn't
          something your system needs and you are trying to cut down on the
          number of libraries distributed with an application.</para>
        </listitem>

        <listitem>
          <para>An artifact which is provided by your runtime container thus
          should not be included with your build. An example of this is if a
          dependency depends on something like the Servlet API and you want to
          make sure that the dependency is not included in a web application's
          <filename>WEB-INF/lib</filename> directory.</para>
        </listitem>

        <listitem>
          <para>To exclude a dependency which might be an
          <acronym>API</acronym> with multiple implementations. This is the
          situation illustrated by <xref linkend="ex-exclude-replace" />;
          there is a Sun <acronym>API</acronym> which requires click-wrap
          licensing and a time-consuming manual install into a custom
          repository (Sun's <acronym>JTA</acronym> <acronym>JAR</acronym>)
          versus a freely distributed version of the same
          <acronym>API</acronym> available in the central Maven repository
          (Geronimo's <acronym>JTA</acronym> implementation).</para>
        </listitem>
      </orderedlist>
    </section>

    <section id="pom-relationships-sect-dep-manage">
      <title>Dependency Management</title>

      <para><indexterm>
          <primary>dependency management</primary>
        </indexterm>Once you've adopted Maven at your super complex enterprise
      and you have two hundred and twenty inter-related Maven projects, you
      are going to start wondering if there is a better way to get a handle on
      dependency versions. If every single project that uses a dependency like
      the MySQL Java connector needs to independently list the version number
      of the dependency, you are going to run into problems when you need to
      upgrade to a new version. Because the version numbers are distributed
      throughout your project tree, you are going to have to manually edit
      each of the <filename>pom.xml</filename> files that reference a
      dependency to make sure that you are changing the version number
      everywhere. Even with <command>find</command>, <command>xargs</command>,
      and <command>awk</command>, you are still running the risk of missing a
      single <acronym>POM</acronym>.</para>

      <para>Luckily, Maven provides a way for you to consolidate dependency
      version numbers in the <sgmltag>dependencyManagement</sgmltag> element.
      You'll usually see the <sgmltag>dependencyManagement</sgmltag> element
      in a top-level parent <acronym>POM</acronym> for an organization or
      project. Using the <sgmltag>dependencyManagement</sgmltag> element in a
      <filename>pom.xml</filename> allows you to reference a dependency in a
      child project without having to explicitly list the version. Maven will
      walk up the parent-child hierarchy until it finds a project with a
      <sgmltag>dependencyManagement</sgmltag> element, it will then use the
      version specified in this <sgmltag>dependencyManagement</sgmltag>
      element.</para>

      <para>For example, if you have a large set of projects which make use of
      the MySQL Java connector version 5.1.2, you could define the following
      <sgmltag>dependencyManagement</sgmltag> element in your multi-module
      project's top-level <acronym>POM</acronym>.</para>

      <para><example>
          <title>Defining Dependency Versions in a Top-level POM</title>

          <programlisting language="xml">&lt;project&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;groupId&gt;org.sonatype.mavenbook&lt;/groupId&gt;
  &lt;artifactId&gt;a-parent&lt;/artifactId&gt;
  &lt;version&gt;1.0.0&lt;/version&gt;
  ...
  &lt;dependencyManagement&gt;
    &lt;dependencies&gt;
      &lt;dependency&gt;
        &lt;groupId&gt;mysql&lt;/groupId&gt;
        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
        &lt;version&gt;5.1.2&lt;/version&gt;
      &lt;/dependency&gt;
      ...
    &lt;dependencies&gt;
  &lt;/dependencyManagement&gt;
</programlisting>

          <para>Then, in a child project, you can add a dependency to the
          MySQL Java Connector using the following dependency
          <acronym>XML</acronym>:</para>

          <programlisting language="xml">&lt;project&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;parent&gt;
    &lt;groupId&gt;org.sonatype.mavenbook&lt;/groupId&gt;
    &lt;artifactId&gt;a-parent&lt;/artifactId&gt;
    &lt;version&gt;1.0.0&lt;/version&gt;
  &lt;/parent&gt;
  &lt;artifactId&gt;project-a&lt;/artifactId&gt;
  ...
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;mysql&lt;/groupId&gt;
      &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
&lt;/project&gt;</programlisting>

          <para>You should notice that the child project did not have to
          explicitly list the version of the
          <varname>mysql-connector-java</varname> dependency. Because this
          dependency was defined in the top-level <acronym>POM</acronym>'s
          <sgmltag>dependencyManagement</sgmltag> element, the version number
          is going to propagate to the child project's dependency on
          <varname>mysql-connector-java</varname>. Note that if this child
          project did define a version, it would override the version listed
          in the top-level <acronym>POM</acronym>'s
          <sgmltag>dependencyManagement</sgmltag> section. That is, the
          <sgmltag>dependencyManagement</sgmltag> version is only used when
          the child does not declare a version directly.</para>

          <para>Dependency management in a top-level <acronym>POM</acronym> is
          different from just defining a dependency on a widely shared parent
          <acronym>POM</acronym>. For starters, all dependencies are
          inherited. If <varname>mysql-connector-java</varname> were listed as
          a dependency of the top-level parent project, every single project
          in the hierarchy would have a reference to this dependency. Instead
          of adding in unnecessary dependencies, using
          <sgmltag>dependencyManagement</sgmltag> allows you to consolidate
          and centralize the management of dependency versions without adding
          dependencies which are inherited by all children. In other words,
          the <sgmltag>dependencyManagement</sgmltag> element is equivalent to
          an environment variable which allows you to declare a dependency
          anywhere below a project without specifying a version number.</para>
        </example></para>
    </section>
  </section>

  <section id="pom-relationships-sect-project-relationships">
    <title>Project Relationships</title>

    <para><indexterm>
        <primary>project relationships</primary>
      </indexterm>One of the compelling reasons to use Maven is that it makes
    the process of tracking down dependencies (and dependencies of
    dependencies) very easy. When a project depends on an artifact produced by
    another project we say that this artifact is a dependency. In the case of
    a Java project, this can be as simple as a project depending on an
    external dependency like Log4J or JUnit. While dependencies can model
    external dependencies, they can also manage the dependencies between a set
    of related projects. If <varname>project-a</varname> depends on
    <varname>project-b</varname>, Maven is smart enough to know that
    <varname>project-b</varname> must be built before
    <varname>project-a</varname>.</para>

    <para>Relationships are not only about dependencies and figuring out what
    one project needs to be able to build an artifact. Maven can model the
    relationship of a project to a parent, and the relationship of a project
    to submodules. This section gives an overview of the various relationships
    between projects and how such relationships are configured.</para>

    <section id="pom-relationships-sect-more-coordinates">
      <title>More on Coordinates</title>

      <para><indexterm>
          <primary>maven coordinates</primary>
        </indexterm>Coordinates define a unique location for a project.
      Projects are related to one another using Maven Coordinates.
      <varname>project-a</varname> doesn't just depend on
      <varname>project-b</varname>; a project with a
      <varname>groupId</varname>, <varname>artifactId</varname>, and
      <varname>version</varname> depends on another project with a
      <varname>groupId</varname>, <varname>artifactId</varname>, and
      <varname>version</varname>. To review, a Maven Coordinate is made up of
      three components:</para>

      <variablelist>
        <varlistentry>
          <term>groupId</term>

          <listitem>
            <para><indexterm>
                <primary>group identifier</primary>
              </indexterm><indexterm>
                <primary>maven coordinates</primary>

                <secondary>groupId</secondary>
              </indexterm>A <varname>groupId</varname> groups a set of related
            artifacts. Group identifiers generally resemble a Java package
            name. For example, the <varname>groupId</varname>
            <varname>org.apache.maven</varname> is the base groupId for all
            artifacts produced by the Apache Maven project. Group identifiers
            are translated into paths in the Maven Repository; for example,
            the org.apache.maven groupId can be found in
            <filename>/maven2/org/apache/maven</filename> on <ulink
            url="http://repo1.maven.org/maven2/org/apache/maven">repo1.maven.org</ulink>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>artifactId</term>

          <listitem>
            <para><indexterm>
                <primary>artifact identifier</primary>
              </indexterm><indexterm>
                <primary>maven coordinates</primary>

                <secondary>artifactId</secondary>
              </indexterm>The <varname>artifactId</varname> is the project's
            main identifier. When you generate an artifact, this artifact is
            going to be named with the <varname>artifactId</varname>. When you
            refer to a project, you are going to refer to it using the
            <varname>artifactId</varname>. The <varname>artifactId</varname>,
            <varname>groupId</varname> combination must be unique. In other
            words, you can't have two separate projects with the same
            <varname>artifactId</varname> and <varname>groupId</varname>;
            <varname>artifactId</varname>s are unique within a particular
            <varname>groupId</varname>.</para>

            <note>
              <para>While '.'s are commonly used in
              <varname>groupId</varname>s, you should try to avoid using them
              in <varname>artifactId</varname>s. This can cause issues when
              trying to parse a fully qualified name down into the
              subcomponents.</para>
            </note>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>version</term>

          <listitem>
            <para><indexterm>
                <primary>version identifier</primary>
              </indexterm><indexterm>
                <primary>maven coordinates</primary>

                <secondary>version</secondary>
              </indexterm>When an artifact is released, it is released with a
            version number. This version number is a numeric identifier such
            as "1.0", "1.1.1", or "1.1.2-alpha-01". You can also use what is
            known as a snapshot version. A snapshot version is a version for a
            component which is under development, snapshot version numbers
            always end in SNAPSHOT; for example, "1.0-SNAPSHOT",
            "1.1.1-SNAPSHOT", and "1-SNAPSHOT". <xref
            linkend="pom-relationships-sect-version-build-numbers" />
            introduces versions and version ranges.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>There is a fourth, less-used qualifier:</para>

      <variablelist>
        <varlistentry>
          <term>classifier</term>

          <listitem>
            <para><indexterm>
                <primary>classifier</primary>
              </indexterm><indexterm>
                <primary>maven coordinates</primary>

                <secondary>classifier</secondary>
              </indexterm>You would use a classifier if you were releasing the
            same code but needed to produce two separate artifacts for
            technical reasons. For example, if you wanted to build two
            separate artifacts of a <acronym>JAR</acronym>, one compiled with
            the Java 1.4 compiler and another compiled with the Java 6
            compiler, you might use the classifier to produce two separate
            <acronym>JAR</acronym> artifacts under the same
            groupId:artifactId:version combination. If your project uses
            native extensions, you might use the classifier to produce an
            artifact for each target platform. Classifiers are commonly used
            to package up an artifact's sources, JavaDocs or binary
            assemblies.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>When we talk of dependencies in this book, we often use the
      following shorthand notation to describe a dependency:
      <varname>groupId</varname>:<varname>artifactId</varname>:<varname>version</varname>.
      To refer to the 2.5 release of the Spring Framework, we would refer to
      it as <varname>org.springframework:spring:2.5</varname>. When you ask
      Maven to print out a list of dependencies with the Maven Dependency
      plugin, you will also see that Maven tends to print out log messages
      with this shorthand dependency notation.</para>
    </section>

    <section id="pom-relationships-sect-project-inheritance">
      <title>Project Inheritance</title>

      <para><indexterm>
          <primary>project inheritance</primary>
        </indexterm><indexterm>
          <primary>project relationships</primary>

          <secondary>inheritance</secondary>
        </indexterm><indexterm>
          <primary>parent project</primary>
        </indexterm>There are going to be times when you want a project to
      inherit values from a parent POM. You might be building a large system,
      and you don't want to have to repeat the same dependency elements over
      and over again. You can avoid repeating yourself if your projects make
      use of inheritance via the parent element. When a project specifies a
      parent, it inherits the information in the parent project's POM. It can
      then override and add to the values specified in this parent POM.</para>

      <para>All Maven <acronym>POM</acronym>s inherit values from a parent
      <acronym>POM</acronym>. If a <acronym>POM</acronym> does not specify a
      direct parent using the <sgmltag>parent</sgmltag> element, that
      <acronym>POM</acronym> will inherit values from the Super
      <acronym>POM</acronym>. <xref linkend="ex-inheritance" /> shows the
      <sgmltag>parent</sgmltag> element of <varname>project-a</varname> which
      inherits the <acronym>POM</acronym> defined by the
      <varname>a-parent</varname> project.</para>

      <example id="ex-inheritance">
        <title>Project Inheritance</title>

        <programlisting language="xml">&lt;project&gt;
  &lt;parent&gt;
    &lt;groupId&gt;com.training.killerapp&lt;/groupId&gt;
    &lt;artifactId&gt;a-parent&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
  &lt;/parent&gt;
  &lt;artifactId&gt;project-a&lt;/artifactId&gt;
  ...
&lt;/project&gt;
</programlisting>
      </example>

      <para>Running <command>mvn help:effective-pom</command> in
      <varname>project-a</varname> would show a <acronym>POM</acronym> that is
      the result of merging the Super <acronym>POM</acronym> with the
      <acronym>POM</acronym> defined by <varname>a-parent</varname> and the
      <acronym>POM</acronym> defined in <varname>project-a</varname>. The
      implicit and explicit inheritance relationships for
      <varname>project-a</varname> are shown in <xref
      linkend="fig-inheritance" />.<figure id="fig-inheritance">
          <title>Project Inheritance for a-parent and project-a</title>

          <mediaobject>
            <imageobject role="web">
              <imagedata fileref="figs/web/pom_inheritance.png" />
            </imageobject>

            <imageobject role="print">
              <imagedata align="center"
                         fileref="figs/print/pom_inheritance.pdf" format="PDF"
                         scalefit="0" width="100%" />
            </imageobject>
          </mediaobject>
        </figure>When a project specifies a parent project, Maven uses that
      parent <acronym>POM</acronym> as a starting point before it reads the
      current project's <acronym>POM</acronym>. It inherits everything,
      including the <varname>groupId</varname> and <varname>version</varname>
      number. You'll notice that <varname>project-a</varname> does not specify
      either, both <varname>groupId</varname> and <varname>version</varname>
      are inherited from <varname>a-parent</varname>. With a parent element,
      all a <acronym>POM</acronym> really needs to define is an
      <varname>artifactId</varname>. This isn't mandatory,
      <varname>project-a</varname> could have a different
      <varname>groupId</varname> and <varname>version</varname>, but by not
      providing values, Maven will use the values specified in the parent
      <acronym>POM</acronym>. If you start using Maven to manage and build
      large multi-module projects, you will often be creating many projects
      which share a common <varname>groupId</varname> and
      <varname>version</varname>.</para>

      <para>When you inherit a <acronym>POM</acronym>, you can choose to live
      with the inherited <acronym>POM</acronym> information or to selectively
      override it. The following is a list of items a Maven
      <acronym>POM</acronym> inherits from its parent
      <acronym>POM</acronym>:</para>

      <itemizedlist>
        <listitem>
          <para>identifiers (at least one of <varname>groupId</varname> or
          <varname>artifactId</varname> must be overridden.)</para>
        </listitem>

        <listitem>
          <para>dependencies</para>
        </listitem>

        <listitem>
          <para>developers and contributors</para>
        </listitem>

        <listitem>
          <para>plugin lists</para>
        </listitem>

        <listitem>
          <para>reports lists</para>
        </listitem>

        <listitem>
          <para>plugin executions (executions with matching ids are
          merged)</para>
        </listitem>

        <listitem>
          <para>plugin configuration</para>
        </listitem>
      </itemizedlist>

      <para>When Maven inherits dependencies, it will add dependencies of
      child projects to the dependencies defined in parent projects. You can
      use this feature of Maven to specify widely used dependencies across all
      projects which inherit from a top-level <acronym>POM</acronym>. For
      example, if your system makes universal use of the Log4J logging
      framework, you can list this dependency in your top-level
      <acronym>POM</acronym>. Any projects which inherit
      <acronym>POM</acronym> information from this project will automatically
      have Log4J as a dependency. Similarly, if you need to make sure that
      every project is using the same version of a Maven plugin, you can list
      this Maven plugin version explicitly in a top-level parent
      <acronym>POM</acronym>'s <sgmltag>pluginManagement</sgmltag>
      section.</para>

      <para>Maven assumes that the parent <acronym>POM</acronym> is available
      from the local repository, or available in the parent directory
      (<filename>../pom.xml</filename>) of the current project. If neither
      location is valid this default behavior may be overridden via the
      <sgmltag>relativePath</sgmltag> element. For example, some organizations
      prefer a flat project structure where a parent project's
      <filename>pom.xml</filename> isn't in the parent directory of a child
      project. It might be in a sibling directory to the project. If your
      child project were in a directory <filename>./project-a</filename> and
      the parent project were in a directory named
      <filename>./a-parent</filename>, you could specify the relative location
      of <varname>parent-a</varname>'s <acronym>POM</acronym> with the
      following configuration:</para>

      <programlisting language="xml">&lt;project&gt;
  &lt;parent&gt;
    &lt;groupId&gt;org.sonatype.mavenbook&lt;/groupId&gt;
    &lt;artifactId&gt;a-parent&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;relativePath&gt;../a-parent/pom.xml&lt;/relativePath&gt;
  &lt;/parent&gt;
  &lt;artifactId&gt;project-a&lt;/artifactId&gt;
&lt;/project&gt;</programlisting>
    </section>
  </section>

  <section id="pom-relationships-sect-pom-best-practice">
    <title>POM Best Practices</title>

    <para><indexterm>
        <primary>Project Object Model (POM)</primary>

        <secondary>best practices</secondary>
      </indexterm><indexterm>
        <primary>best practices</primary>
      </indexterm>Maven can be used to manage everything from simple,
    single-project systems to builds that involve hundreds of inter-related
    submodules. Part of the learning process with Maven isn't just figuring
    out the syntax for configuring Maven, it is learning the "Maven Way"—the
    current set of best practices for organizing and building projects using
    Maven. This section attempts to distill some of this knowledge to help you
    adopt best practices from the start without having to wade through years
    of discussions on the Maven mailing lists.</para>

    <section id="pom-relationships-sect-grouping-deps">
      <title>Grouping Dependencies</title>

      <para><indexterm>
          <primary>grouping dependencies</primary>
        </indexterm><indexterm>
          <primary>best practices</primary>

          <secondary>grouping dependencies</secondary>
        </indexterm>If you have a set of dependencies which are logically
      grouped together. You can create a project with pom packaging that
      groups dependencies together. For example, let's assume that your
      application uses Hibernate, a popular Object-Relational mapping
      framework. Every project which uses Hibernate might also have a
      dependency on the Spring Framework and a MySQL <acronym>JDBC</acronym>
      driver. Instead of having to include these dependencies in every project
      that uses Hibernate, Spring, and MySQL you could create a special
      <acronym>POM</acronym> that does nothing more than declare a set of
      common dependencies. You could create a project called
      <varname>persistence-deps</varname> (short for Persistence
      Dependencies), and have every project that needs to do persistence
      depend on this convenience project:</para>

      <para><example>
          <title>Consolidating Dependencies in a Single POM Project</title>

          <programlisting language="xml">&lt;project&gt;
  &lt;groupId&gt;org.sonatype.mavenbook&lt;/groupId&gt;
  &lt;artifactId&gt;persistence-deps&lt;/artifactId&gt;
  &lt;version&gt;1.0&lt;/version&gt;
  &lt;packaging&gt;pom&lt;/packaging&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
      &lt;artifactId&gt;hibernate&lt;/artifactId&gt;
      &lt;version&gt;\${hibernateVersion}&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
      &lt;artifactId&gt;hibernate-annotations&lt;/artifactId&gt;
      &lt;version&gt;\${hibernateAnnotationsVersion}&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework&lt;/groupId&gt;
      &lt;artifactId&gt;spring-hibernate3&lt;/artifactId&gt;
      &lt;version&gt;\${springVersion}&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;mysql&lt;/groupId&gt;
      &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
      &lt;version&gt;\${mysqlVersion}&lt;/version&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
  &lt;properties&gt;
    &lt;mysqlVersion&gt;(5.1,)&lt;/mysqlVersion&gt;
    &lt;springVersion&gt;(2.0.6,)&lt;/springVersion&gt;
    &lt;hibernateVersion&gt;3.2.5.ga&lt;/hibernateVersion&gt;
    &lt;hibernateAnnotationsVersion&gt;3.3.0.ga&lt;/hibernateAnnotationsVersion&gt;
  &lt;/properties&gt;
&lt;/project&gt;
</programlisting>
        </example></para>

      <para>If you create this project in a directory named
      <varname>persistence-deps</varname>, all you need to do is create this
      <filename>pom.xml</filename> and run <command>mvn install</command>.
      Since the packaging type is <varname>pom</varname>, this POM is
      installed in your local repository. You can now add this project as a
      dependency and all of its dependencies will be added as transitive
      dependencies to your project. When you declare a dependency on this
      persistence-deps project, don't forget to specify the dependency type as
      pom.</para>

      <para><example>
          <title>Declaring a Dependency on a POM</title>

          <programlisting language="xml">&lt;project&gt;
  &lt;description&gt;This is a project requiring JDBC&lt;/description&gt;
  ...
  &lt;dependencies&gt;
    ...
    &lt;dependency&gt;
      &lt;groupId&gt;org.sonatype.mavenbook&lt;/groupId&gt;
      &lt;artifactId&gt;persistence-deps&lt;/artifactId&gt;
      &lt;version&gt;1.0&lt;/version&gt;
      &lt;type&gt;pom&lt;/type&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
&lt;/project&gt;
</programlisting>
        </example></para>

      <para>If you later decide to switch to a different
      <acronym>JDBC</acronym> driver (for example, <acronym>JTDS</acronym>),
      just replace the dependencies in the <varname>persistence-deps</varname>
      project to use
      <varname>net.</varname><varname>sourceforge.jtds:jtds</varname> instead
      of <varname>mysql:mysql-java-connector</varname> and update the version
      number. All projects depending on <varname>persistence-deps</varname>
      will use <acronym>JTDS</acronym> if they decide to update to the newer
      version. Consolidating related dependencies is a good way to cut down on
      the length of <filename>pom.xml</filename> files that start having to
      depend on a large number of dependencies. If you need to share a large
      number of dependencies between projects, you could also just establish
      parent-child relationships between projects and refactor all common
      dependencies to the parent project, but the disadvantage of the
      parent-child approach is that a project can have only one parent.
      Sometimes it makes more sense to group similar dependencies together and
      reference a <literal>pom</literal> dependency. This way, your project
      can reference as many of these consolidated dependency
      <acronym>POM</acronym>s as it needs.</para>

      <note>
        <para>Maven uses the depth of a dependency in the tree when resolving
        conflicts using a nearest-wins approach. Using the dependency grouping
        technique above pushes those dependencies one level down in the tree.
        Keep this in mind when choosing between grouping in a pom or using
        <sgmltag>dependencyManagement</sgmltag> in a parent
        <acronym>POM</acronym></para>
      </note>
    </section>

    <section id="pom-relationships-sect-multi-vs-inherit">
      <title>Multi-module vs. Inheritance</title>

      <para><indexterm>
          <primary>multi-module projects</primary>
        </indexterm>There is a difference between inheriting from a parent
      project and<indexterm>
          <primary>multimodule projects, in general</primary>

          <secondary>inheritance versus</secondary>
        </indexterm><indexterm>
          <primary>project inheritance</primary>

          <secondary>choosing multimodule projects instead of</secondary>
        </indexterm><indexterm>
          <primary>inheritance between projects or modules</primary>

          <secondary>choosing multimodule projects instead of</secondary>
        </indexterm><indexterm>
          <primary>module inheritance</primary>

          <secondary>choosing multimodule projects instead of</secondary>
        </indexterm> being managed by a multimodule project. A parent project
      is one that passes its values to its children. A multimodule project
      simply manages a group of other subprojects or modules. The multimodule
      relationship is defined from the topmost level downwards. When setting
      up a multimodule project, you are simply telling a project that its
      build should include the specified modules. Multimodule builds are to be
      used to group modules together in a single build. The parent-child
      relationship is defined from the leaf node upwards. The parent-child
      relationship deals more with the definition of a particular project.
      When you associate a child with its parent, you are telling Maven that a
      project’s <acronym>POM</acronym> is derived from another.</para>

      <para>To illustrate the decision process that goes into choosing a
      design that uses inheritance vs. multi-module or both approaches
      consider the following two examples: the Maven project used to generate
      this book and a hypothetical project that contains a number of logically
      grouped modules.</para>

      <section id="pom-relationships-sect-simple-project">
        <title>Simple Project</title>

        <para>First, let's take a look at the maven-book project. The
        inheritance and multi-module relationships are shown in <xref
        linkend="fig-maven-book" />.</para>

        <figure id="fig-maven-book">
          <title>maven-book Multi-module vs. Inheritance</title>

          <mediaobject>
            <imageobject role="web">
              <imagedata fileref="figs/web/pom_book-example.png" />
            </imageobject>

            <imageobject role="print">
              <imagedata align="center"
                         fileref="figs/print/pom_book-example.pdf"
                         format="PDF" scalefit="0" width="100%" />
            </imageobject>
          </mediaobject>
        </figure>

        <para>When we build this Maven book you are reading, we run
        <command>mvn package</command> in a multi-module project named
        <varname>maven-book</varname>. This multi-module project includes two
        submodules: <varname>book-examples</varname> and
        <varname>book-chapters</varname>. Neither of these projects share the
        same parent, they are related only in that they are modules in the
        <varname>maven-book</varname> project.
        <varname>book-examples</varname> builds the <acronym>ZIP</acronym> and
        <acronym>TGZ</acronym> archives you downloaded to get this book's
        example. When we run the <varname>book-examples</varname> build from
        <filename>book-examples/</filename> directory with <command>mvn
        package</command>, it has no knowledge that it is a part of the larger
        <varname>maven-book</varname> project.
        <varname>book-examples</varname> doesn't really care about
        <varname>maven-book</varname>, all it knows in life is that its parent
        is the top-most <varname>sonatype</varname> <acronym>POM</acronym> and
        that it creates an archive of examples. In this case, the
        <varname>maven-book</varname> project exists only as a convenience and
        as a aggregator of modules.</para>

        <para>Each of the three projects: <varname>maven-book</varname>,
        <varname>book-examples</varname>, and <varname>book-chapters</varname>
        all list a shared "corporate" parent — <varname>sonatype</varname>.
        This is a common practice in organizations which have adopted Maven,
        instead of having every project extend the Super
        <acronym>POM</acronym> by default, some organizations define a
        top-level corporate <acronym>POM</acronym> that serves as the default
        parent when a project doesn't have any good reason to depend on
        another. In this book example, there is no compelling reason to have
        <varname>book-examples</varname> and <varname>book-chapters</varname>
        share the same parent <acronym>POM</acronym>, they are entirely
        different projects which have a different set of dependencies, a
        different build configuration, and use drastically different plugins
        to create the content you are now reading. The
        <varname>sonatype</varname> <acronym>POM</acronym> gives the
        organization a chance to customize the default behavior of Maven and
        supply some organization-specific information to configure deployment
        settings and build profiles.</para>
      </section>

      <section id="pom-relationships-sect-multi-module-enterprise">
        <title>Multi-module Enterprise Project</title>

        <para><indexterm>
            <primary>multi-module project</primary>
          </indexterm>Let's take a look at an example that provides a more
        accurate picture of a real-world project where inheritance and
        multi-module relationships exist side by side. <xref
        linkend="fig-multi-module" /> shows a collection of projects that
        resemble a typical set of projects in an enterprise application. There
        is a top-level <acronym>POM</acronym> for the corporation with an
        <varname>artifactId</varname> of <varname>sonatype</varname>. There is
        a multi-module project named <varname>big-system</varname> which
        references sub-modules <varname>server-side</varname> and
        <varname>client-side</varname>.</para>

        <figure id="fig-multi-module">
          <title>Enterprise Multi-module vs. Inheritance</title>

          <mediaobject>
            <imageobject role="web">
              <imagedata fileref="figs/web/pom_real_multi.png" />
            </imageobject>

            <imageobject role="print">
              <imagedata align="center"
                         fileref="figs/print/pom_real_multi.pdf" format="PDF"
                         scalefit="0" width="100%" />
            </imageobject>
          </mediaobject>
        </figure>

        <para>What's going on here? Let's try to deconstruct this confusing
        set of arrows. First, let's take a look at
        <varname>big-system</varname>. The <varname>big-system</varname> might
        be the project that you would run <command>mvn package</command> on to
        build and test the entire system. <varname>big-system</varname>
        references submodules <varname>client-side</varname> and
        <varname>server-side</varname>. Each of these projects effectively
        rolls up all of the code that runs on either the server or on the
        client. Let's focus on the <varname>server-side</varname> project.
        Under the <varname>server-side</varname> project we have a project
        called <varname>server-lib</varname> and a multi-module project named
        <varname>web-apps</varname>. Under <varname>web-apps</varname> we have
        two Java web applications: <varname>client-web</varname> and
        <varname>admin-web</varname>.</para>

        <para>Let's start with the parent/child relationships from
        <varname>client-web</varname> and <varname>admin-web</varname> to
        <varname>web-apps</varname>. Since both of the web applications are
        implemented in the same web application framework (let's say Wicket),
        both projects would share the same set of core dependencies. The
        dependencies on the Servlet <acronym>API</acronym>, the
        <acronym>JSP</acronym> <acronym>API</acronym>, and Wicket would all be
        captured in the <varname>web-apps</varname> project. Both
        <varname>client-web</varname> and <varname>admin-web</varname> also
        need to depend on <varname>server-lib</varname>, this dependency would
        be defined as a dependency between <varname>web-apps</varname> and
        <varname>server-lib</varname>. Because <varname>client-web</varname>
        and <varname>admin-web</varname> share so much configuration by
        inheriting from <varname>web-apps</varname>, both
        <varname>client-web</varname> and <varname>admin-web</varname> will
        have very small <acronym>POM</acronym>s containing little more than
        identifiers, a parent declaration, and a final build name.</para>

        <para>Next we focus on the parent/child relationship from
        <varname>web-apps</varname> and <varname>server-lib</varname> to
        <varname>server-side</varname>. In this case, let's just assume that
        there is a separate working group of developers which work on the
        server-side code and another group of developers that work on the
        client-side code. The list of developers would be configured in the
        <varname>server-side</varname> POM and inherited by all of the child
        projects underneath it: <varname>web-apps</varname>,
        <varname>server-lib</varname>, <varname>client-web</varname>, and
        <varname>admin-web</varname>. We could also imagine that the
        <varname>server-side</varname> project might have different build and
        deployment settings which are unique to the development for the server
        side. The <varname>server-side</varname> project might define a build
        profile that only makes sense for all of the
        <varname>server-side</varname> projects. This build profile might
        contain the database host and credentials, or the
        <varname>server-side</varname> project's <acronym>POM</acronym> might
        configure a specific version of the Maven Jetty plugin which should be
        universal across all projects that inherit the
        <varname>server-side</varname> <acronym>POM</acronym>.</para>

        <para>In this example, the main reason to use parent/child
        relationships is shared dependencies and common configuration for a
        group of projects which are logically related. All of the projects
        below <varname>big-system</varname> are related to one another as
        submodules, but not all submodules are configured to point back to
        parent project that included it as a submodule. Everything is a
        submodule for reasons of convenience, to build the entire system just
        go to the <varname>big-system</varname> project directory and run
        <command>mvn package</command>. Look more closely at the figure and
        you'll see that there is no parent/child relationship between
        <varname>server-side</varname> and <varname>big-system</varname>. Why
        is this? <acronym>POM</acronym> inheritance is very powerful, but it
        can be overused. When it makes sense to share dependencies and build
        configuration, a parent/child relationship should be used. When it
        doesn't make sense is when there are distinct differences between two
        projects. Take, for example, the <varname>server-side</varname> and
        <varname>client-side</varname> projects. It is possible to create a
        system where <varname>client-side</varname> and
        <varname>server-side</varname> inherited a common
        <acronym>POM</acronym> from <varname>big-system</varname>, but as soon
        as a significant divergence between the two child projects develops,
        you then have to figure out creative ways to factor out common build
        configuration to <varname>big-system</varname> without affecting all
        of the children. Even though <varname>client-side</varname> and
        <varname>server-side</varname> might both depend on Log4J, they also
        might have distinct plugin configurations.</para>

        <para>There's a certain point defined more by style and experience
        where you decide that minimal duplication of configuration is a small
        price to pay for allowing projects like <varname>client-side</varname>
        and <varname>server-side</varname> to remain completely independent.
        Designing a huge set of thirty plus projects which all inherit five
        levels of POM configuration isn't always the best idea. In such a
        setup, you might not have to duplicate your Log4J dependency more than
        once, but you'll also end up having to wade through five levels of POM
        just figure out how Maven calculated your effective POM. All of this
        complexity to avoid duplicating five lines of dependency declaration.
        In Maven, there is a "Maven Way", but there are also many ways to
        accomplish the same thing. It all boils down to preference and style.
        For the most part, you won't go wrong if all of your submodules turn
        out to define back-references to the same project as a parent, but
        your use of Maven may evolve over time.</para>
      </section>
    </section>
  </section>
</chapter>
