= Maven: The Complete Reference
:author:    Sonatype, Inc.
:data-uri:
:icons:
:docinfo:
:quotes.~:

[[preface-copyright]]
[preface]
== Copyright

Copyright © 2008-2011 Sonatype, Inc.

Online version published by Sonatype, Inc.

This work is licensed under a Creative Commons
Attribution-Noncommercial-No Derivative Works 3.0 United States
license. For more information about this license, see
http://creativecommons.org/licenses/by-nc-nd/3.0/us/[creativecommons.org/licenses/by-nc-nd/3.0/us/].

Nexus™, Nexus Professional™, and all Nexus-related logos are
trademarks or registered trademarks of Sonatype, Inc., in the United
States and other countries.

Java™ and all Java-based trademarks and logos are trademarks or
registered trademarks of Sun Microsystems, Inc., in the United States
and other countries.

IBM® and WebSphere® are trademarks or registered trademarks of
International Business Machines, Inc., in the United States and other
countries.

Eclipse™ is a trademark of the Eclipse Foundation, Inc., in the United
States and other countries.

Apache and the Apache feather logo are trademarks of The Apache
Software Foundation.

Linux® is the registered trademark of Linus Torvalds in the U.S. and
other countries.

Many of the designations used by manufacturers and sellers to
distinguish their products are claimed as trademarks. Where those
designations appear in this book, and Sonatype, Inc. was
aware of a trademark claim, the designations have been printed in caps
or initial caps.

While every precaution has been taken in the preparation of this book,
the publisher and authors assume no responsibility for errors or
omissions, or for damages resulting from the use of the information
contained herein.

[[public-foreward]]
[preface]
== Foreword: 1.0

In this edition of Maven: The Complete Reference, we are beginning our
transition to Maven 3.0. Maven 3.0 is approaching the end of a lengthy
beta testing period, and it has already been in wide use by very
large, mission-critical projects. We feel the Maven 3.0 is ready to
for use, and this edition has added some supplemental information for
developers who are looking to use Maven 3.0.

We've had some great feedback so far, please keep it coming. Your
feedback is greatly appreciated, send it to book@sonatype.com. To keep
yourself informed of updates, read the book blog at:
http://blogs.sonatype.com/book[blogs.sonatype.com/book]. Everyone at
Sonatype has had a hand in this version of the book, so the author is
officially "Sonatype".

Please report any bugs or issues on this book's GetSatisfaction page,
here:
http://www.getsatisfaction.com/sonatype/products/sonatype_maven_the_complete_reference[getsatisfaction.com/sonatype].

Tim O'Brien (tobrien@sonatype.com)

May, 2011

[[preface-1]]
[preface]
== Preface

Maven is a build tool, a project management tool, an abstract
container for running build tasks. It is a tool that has shown itself
indispensable for projects that graduate beyond the simple and need to
start finding consistent ways to manage and build large collections of
interdependent modules and libraries which make use of tens or
hundreds of third-party components. It is a tool that has removed much
of the burden of 3rd party dependency management from the daily work
schedule of millions of engineers, and it has enabled many
organizations to evolve beyond the toil and struggle of build
management into a new phase where the effort required to build and
maintain software is no longer a limiting factor in software design.

This work is the first attempt at a comprehensive title on Maven. It
builds upon the combined experience and work of the authors of all
previous Maven titles, and you should view it not as a finished work
but as the first edition in a long line of updates to follow. While
Maven has been around for a few years, the authors of this book
believe that it has just begun to deliver on the audacious promises it
makes. The authors, and company behind this book,
http://www.sonatype.com[Sonatype], believe that the publishing of this
book marks the beginning of a new phase of innovation and development
surrounding Maven and the software ecosystem that surrounds it.

[[preface-1-sect-how-to-use]]
=== How to Use this Book

Pick it up, read some of the text on the pages. Once you reach the end
of a page, you'll want to either click on a link if you are looking at
the HTML version, or, if you have the printed book,
you'll lift up a corner of a page and turn it. If you are sitting next
to a computer, you can type in some of the examples and try to follow
along. Please don't throw a book this large at anyone in anger.

This book introduces Maven by developing some real examples and
walking you through the structure of those examples providing
motivation and explanation along the way.

[[preface-1-sect-feedback]]
=== Your Feedback

We didn't write this book so we could send off a Word document to our publisher and go to a launch party to congratulate ourselves on a job well done. This book isn't "done"; in fact, this book will never be completely "done". The subject it covers is constantly changing and expanding, and we consider this work an ongoing conversation with the community. Publishing the book means that the real work has just begun, and you, as a reader, play a pivotal role to helping to maintain and improve this book. If you see something in this book that is wrong: a spelling mistake, some bad code, a blatant lie, then you should tell us, send us an email at: mailto:tobrien@sonatype.com[book@sonatype.com].

The ongoing relevance of this book depends upon your feedback. We want to know what works and what doesn't work. We want to know if there is any information you couldn't understand. We especially want to know if you think that the book is awful. Positive or negative comments are all welcome. Of course, we reserve the right to disagree, but all feedback will be rewarded with a gracious response.

[[preface-1-sect-writing-conventions]]
=== Maven Writing Conventions

The book follows certain conventions for naming and font usage in
relation to Apache Maven. Understanding these conventions up-front
makes it easier to read this book.

Compiler plugin::

  Maven plugins are capitalized.

+create+ goal::

  Maven goal names are displayed in a constant width font.

"plugin"::

  While "plug-in" (with hyphen) would be the grammatically correct
  form, this book writes the term as "plugin" both because it is
  easier to read and write and because it is a standard throughout the
  Maven community.

Maven Lifecycle, Maven Standard Directory Layout, Maven Plugin, Project Object Model::

  Core Maven concepts are capitalized whenever they are being
  referenced in the text.


+goalParameter+::

  A Maven goal parameter is displayed in a constant width font.


+compile+ phase::

  Lifecycle phases are displayed in a constant width font.

[[preface-1-sect-acknowledgements]]
=== Acknowledgements

Sonatype would like to thank the following contributors. The people listed below have provided feedback which has helped improve the quality of this book. Thanks to Raymond Toal, Steve Daly, Paul Strack, Paul Reinerfelt, Chad Gorshing, Marcus Biel, Brian Dols, Mangalaganesh Balasubramanian, Marius Kruger, and Mark Stewart. Special thanks to Joel Costigliola for helping to debug and correct the Spring web chapter. Stan Guillory was practically a contributing author given the number of corrections he posted to the book's Get Satisfaction. Thank you Stan. Special thanks to Richard Coasby of Bamboo for acting as the provisional grammar consultant.

Thanks to our contributing authors including Eric Redmond.

Thanks to the following contributors who reported errors either in an email or using the Get Satisfaction site: Paco Soberón, Ray Krueger, Steinar Cook, Henning Saul, Anders Hammar, "george_007", "ksangani", Niko Mahle, Arun Kumar, Harold Shinsato, "mimil", "-thrawn-", Matt Gumbley. If you see your Get Satisfaction username in this list, and you would like it replaced with your real name, send an email to mailto:book@sonatype.com[book@sonatype.com].

Special thanks to Grant Birchmeier for taking the time to proofread portions of the book and file extremely detailed feedback via GetSatisfaction.

[[introduction]]
== Introducing Apache Maven


Although there are a number of references for Maven online, there is no single, well-written narrative for introducing Maven that can serve as both an authoritative reference and an introduction. What we’ve tried to do with this effort is provide such a narrative coupled with useful reference material.

[[introduction-sect-whatIsMaven]]
=== Maven... What is it?

The answer to this question depends on your own perspective. The great majority of Maven users are going to call Maven a “build tool”: a tool used to build deployable artifacts from source code. Build engineers and project managers might refer to Maven as something more comprehensive: a project management tool. What is the difference? A build tool such as Ant is focused solely on preprocessing, compilation, packaging, testing, and distribution. A project management tool such as Maven provides a superset of features found in a build tool. In addition to providing build capabilities, Maven can also run reports, generate a web site, and facilitate communication among members of a working team.

A more formal definition of http://maven.apache.org[Apache Maven]: Maven is a project management tool which encompasses a project object model, a set of standards, a project lifecycle, a dependency management system, and logic for executing plugin goals at defined phases in a lifecycle. When you use Maven, you describe your project using a well-defined project object model, Maven can then apply cross-cutting logic from a set of shared (or custom) plugins.

Don't let the fact that Maven is a "project management" tool scare you away. If you were just looking for a build tool, Maven will do the job. In fact, the first few chapters of this book will deal with the most common use case: using Maven to build and distribute your project.

[[installation-sect-conventionConfiguration]]
=== Convention Over Configuration

Convention over configuration is a simple concept. Systems, libraries, and frameworks should assume reasonable defaults. Without requiring unnecessary configuration, systems should "just work". Popular frameworks such as http://www.rubyonrails.org/[Ruby on Rails] and EJB3 have started to adhere to these principles in reaction to the configuration complexity of frameworks such as the initial EJB 2.1 specifications. An illustration of convention over configuration is something like EJB3 persistence: all you need to do to make a particular bean persistent is to annotate that class with +@Entity. + The framework assumes table and column names based on the name of the class and the names of the properties. Hooks are provided for you to override these default, assumed names if the need arises, but, in most cases, you will find that using the framework-supplied defaults results in a faster project execution.

Maven incorporates this concept by providing sensible default behavior for projects. Without customization, source code is assumed to be in '+++${basedir}/src/main/java+++' and resources are assumed to be in '+++${basedir}/src/main/resources+++'. Tests are assumed to be in '+++${basedir}/src/test+++', and a project is assumed to produce a JAR file. Maven assumes that you want the compile byte code to '+++${basedir}/target/classes+++' and then create a distributable JAR file in '+++${basedir}/target+++'. While this might seem trivial, consider the fact that most Ant-based builds have to define the locations of these directories. Ant doesn't ship with any built-in idea of where source code or resources might be in a project; you have to supply this information. Maven's adoption of convention over configuration goes farther than just simple directory locations, Maven's core plugins apply a common set of conventions for compiling source code, packaging distributions, generating web sites, and many other processes. Maven's strength comes from the fact that it is "opinionated", it has a defined life-cycle and a set of common plugins that know how to build and assemble software. If you follow the conventions, Maven will require almost zero effort - just put your source in the correct directory, and Maven will take care of the rest.

One side-effect of using systems that follow "convention over configuration" is that end-users might feel that they are forced to use a particular methodology or approach. While it is certainly true that Maven has some core opinions that shouldn't be challenged, most of the defaults can be customized. For example, the location of a project's source code and resources can be customized, names of JAR files can be customized, and through the development of custom plugins, almost any behavior can be tailored to your specific environment's requirements. If you don't care to follow convention, Maven will allow you to customize defaults in order to adapt to your specific requirements.

[[installation-sect-common-interface]]
=== A Common Interface

Before Maven provided a common interface for building software, every single project had someone dedicated to managing a fully customized build system. Developers had to take time away from developing software to learn about the idiosyncrasies of each new project they wanted to contribute to. In 2001, you'd have a completely different approach to building a project like http://turbine.apache.org/[Turbine] than you would to building a project like http://tomcat.apache.org[Tomcat]. If a new source code analysis tool came out that would perform static analysis on source code, or if someone developed a new unit testing framework, everybody would have to drop what they were doing and figure out how to fit it into each project's custom build environment. How do you run unit tests? There were a thousand different answers. This environment was characterized by a thousand endless arguments about tools and build procedures. The age before Maven was an age of inefficiency, the age of the "Build Engineer".

Today, most open source developers have used or are currently using Maven to manage new software projects. This transition is less about developers moving from one build tool to another and more about developers starting to adopt a common interface for project builds. As software systems have become more modular, build systems have become more complex, and the number of projects has sky-rocketed. Before Maven, when you wanted to check out a project like http://activemq.apache.org[Apache ActiveMQ] or http://servicemix.apache.org[Apache ServiceMix] from Subversion and build it from source, you really had to set aside about an hour to figure out the build system for each particular project. What does the project need to build? What libraries do I need to download? Where do I put them? What goals can I execute in the build? In the best case, it took a few minutes to figure out a new project's build, and in the worst cases (like the old Servlet API implementation in the Jakarta Project), a project's build was so difficult it would take multiple hours just to get to the point where a new contributor could edit source and compile the project. These days, you check it out from source, and you run +mvn install+.

While Maven provides an array of benefits including dependency management and reuse of common build logic through plugins, the core reason why it has succeeded is that it has defined a common interface for building software. When you see that a project like http://wicket.apache.org[Apache ActiveMQ] uses Maven, you can assume that you'll be able to check it out from source and build it with +mvn install+ without much hassle. You know where the ignition keys goes, you know that the gas pedal is on the right-side, and the brake is on the left.

[[installation-sect-universal-reuse]]
=== Universal Reuse through Maven Plugins

The core of Maven is pretty dumb, it doesn't know how to do much beyond parsing a few XML documents and keeping track of a lifecycle and a few plugins. Maven has been designed to delegate most responsibility to a set of Maven Plugins which can affect the Maven Lifecycle and offer access to goals. Most of the action in Maven happens in plugin goals which take care of things like compiling source, packaging bytecode, publishing sites, and any other task which need to happen in a build. The Maven you download from Apache doesn't know much about packaging a WAR file or running JUnit tests; most of the intelligence of Maven is implemented in the plugins and the plugins are retrieved from the Maven Repository. In fact, the first time you ran something like +mvn install+ with a brand-new Maven installation it retrieved most of the core Maven plugins from the Central Maven Repository. This is more than just a trick to minimize the download size of the Maven distribution, this is behavior which allows you to upgrade a plugin to add capability to your project's build. The fact that Maven retrieves both dependencies and plugins from the remote repository allows for universal reuse of build logic.

The Maven Surefire plugin is the plugin that is responsible for running unit tests. Somewhere between version 1.0 and the version that is in wide use today someone decided to add support for the TestNG unit testing framework in addition to the support for JUnit. This upgrade happened in a way that didn't break backwards compatibility. If you were using the Surefire plugin to compile and execute JUnit 3 unit tests, and you upgraded to the most recent version of the Surefire plugin, your tests continued to execute without fail. But, you gained new functionality, if you want to execute unit tests in TestNG you now have that ability. You also gained the ability to run annotated JUnit 4 unit tests. You gained all of these capabilities without having to upgrade your Maven installation or install new software. Most importantly, nothing about your project had to change aside from a version number for a plugin a single Maven configuration file called the Project Object Model (POM).

It is this mechanism that affects much more than the Surefire plugin. Maven has plugins for everything from compiling Java code, to generating reports, to deploying to an application server. Maven has abstracted common build tasks into plugins which are maintained centrally and shared universally. If the state-of-the-art changes in any area of the build, if some new unit testing framework is released or if some new tool is made available, you don't have to be the one to hack your project's custom build system to support it. You benefit from the fact that plugins are downloaded from a remote repository and maintained centrally. This is what is meant by universal reuse through Maven plugins.

[[installation-sect-conceptual]]
=== Conceptual Model of a "Project"

Maven maintains a model of a project. You are not just compiling source code into bytecode, you are developing a description of a software project and assigning a unique set of coordinates to a project. You are describing the attributes of the project. What is the project's license? Who develops and contributes to the project? What other projects does this project depend upon? Maven is more than just a "build tool", it is more than just an improvement on tools like make and Ant, it is a platform that encompasses a new semantics related to software projects and software development. This definition of a model for every project enables such features as:

Dependency Management::

  Because a project is defined by a unique set of coordinates consisting of a group identifier, an artifact identifier, and a version, projects can now use these coordinates to declare dependencies.

Remote Repositories::

  Related to dependency management, we can use the coordinates defined in the Maven Project Object Model (POM) to create repositories of Maven artifacts.

Universal Reuse of Build Logic::

  Plugins contain logic that works with the descriptive data and configuration parameters defined in Project Object Model (POM); they are not designed to operate upon specific files in known locations.

Tool Portability / Integration::

  Tools like Eclipse, NetBeans, and IntelliJ now have a common place to find information about a project. Before the advent of Maven, every IDE had a different way to store what was essentially a custom Project Object Model (POM). Maven has standardized this description, and while each IDE continues to maintain custom project files, they can be easily generated from the model.

Easy Searching and Filtering of Project Artifacts::

  Tools like Nexus allow you to index and search the contents of a repository using the information stored in the POM.

[[installation-sect-mavenAlternativeAnt]]
=== Is Maven an alternative to XYZ?

So, sure, Maven is an alternative to Ant, but http://ant.apache.org[Apache Ant] continues to be a great, widely-used tool. It has been the reigning champion of Java builds for years, and you can integrate Ant build scripts with your project's Maven build very easily. This is a common usage pattern for a Maven project. On the other hand, as more and more open source projects move to Maven as a project management platform, working developers are starting to realize that Maven not only simplifies the task of build management, it is helping to encourage a common interface between developers and software projects. Maven is more of a platform than a tool, while you could consider Maven an alternative to Ant, you are comparing apples to oranges. "Maven" includes more than just a build tool.

This is the central point that makes all of the Maven vs. Ant, Maven vs. Buildr, Maven vs. Gradle arguments irrelevant. Maven isn't totally defined by the mechanics of your build system. It isn't about scripting the various tasks in your build as much as it is about encouraging a set of standards, a common interface, a life-cycle, a standard repository format, a standard directory layout, etc. It certainly isn't about what format the POM happens to be in (XML vs. YAML vs. Ruby). Maven is much larger than that, and Maven refers to much more than the tool itself. When this book talks of Maven, it is referring to the constellation of software, systems, and standards that support it. Buildr, Ivy, Gradle, all of these tools interact with the repository format that Maven helped create, and you could just as easily use a repository manager like Nexus to support a build written entirely in Ant.

While Maven is an alternative to many of these tools, the community needs to evolve beyond seeing technology as a zero-sum game between unfriendly competitors in a competition for users and developers. This might be how large corporations relate to one another, but it has very little relevance to the way that open source communities work. The headline "Who's winning? Ant or Maven?" isn't very constructive. If you force us to answer this question, we're definitely going to say that Maven is a superior alternative to Ant as a foundational technology for a build; at the same time, Maven's boundaries are constantly shifting and the Maven community is constantly trying to seek out new ways to become more ecumenical, more inter-operable, more cooperative. The core tenets of Maven are declarative builds, dependency management, repository managers, universal reuse through plugins, but the specific incarnation of these ideas at any given moment is less important than the sense that the open source community is collaborating to reduce the inefficiency of "enterprise-scale builds".

[[installation-sect-compare-ant-maven]]
=== Comparing Maven with Ant

The authors of this book have no interest in creating a feud between Apache Ant and Apache Maven, but we are also cognizant of the fact that most organizations have to make a decision between the two standard solutions: Apache Ant and Apache Maven. In this section, we compare and contrast the tools.

Ant excels at build process, it is a build system modeled after make with targets and dependencies. Each target consists of a set of instructions which are coded in XML. There is a +copy+ task and a +javac+ task as well as a +jar+ task. When you use Ant, you supply Ant with specific instructions for compiling and packaging your output. Look at the following example of a simple 'build.xml' file:

[[ex-ant-sample]]
.A Simple Ant build.xml file
----
<project name="my-project" default="dist" basedir=".">
    <description>
        simple example build file
    </description>
    <!-- set global properties for this build -->
    <property name="src" location="src/main/java"/>
    <property name="build" location="target/classes"/>
    <property name="dist"  location="target"/>

    <target name="init">
        <!-- Create the time stamp -->
        <tstamp/>
        <!-- Create the build directory structure used by compile -->
        <mkdir dir="${build}"/>
    </target>

    <target name="compile" depends="init"
            description="compile the source " >
        <!-- Compile the java code from ${src} into ${build} -->
        <javac srcdir="${src}" destdir="${build}"/>
    </target>

    <target name="dist" depends="compile"
            description="generate the distribution" >
        <!-- Create the distribution directory -->
        <mkdir dir="${dist}/lib"/>

        <!-- Put everything in ${build} into the MyProject-${DSTAMP}.jar file -->
        <jar jarfile="${dist}/lib/MyProject-${DSTAMP}.jar" basedir="${build}"/>
    </target>

    <target name="clean"
            description="clean up" >
        <!-- Delete the ${build} and ${dist} directory trees -->
        <delete dir="${build}"/>
        <delete dir="${dist}"/>
    </target>
</project>
----

In this simple Ant example, you can see how you have to tell Ant exactly what to do. There is a compile goal which includes the +javac+ task that compiles the source in the 'src/main/java' directory to the 'target/classes' directory. You have to tell Ant exactly where your source is, where you want the resulting bytecode to be stored, and how to package this all into a JAR file. While there are some recent developments that help make Ant less procedural, a developer's experience with Ant is in coding a procedural language written in XML.

Contrast the previous Ant example with a Maven example. In Maven, to create a JAR file from some Java source, all you need to do is create a simple 'pom.xml', place your source code in '+++${basedir}/src/main/java+++' and then run +mvn install+ from the command line. The example Maven 'pom.xml' that achieves the same results as the simple Ant file listed in <<ex-ant-sample>> is shown in <<ex-maven-sample>>.

[[ex-maven-sample]]
.A Sample Maven pom.xml
----
<project>
    <modelVersion>4.0.0</modelVersion>
    <groupId>org.sonatype.mavenbook</groupId>
    <artifactId>my-project</artifactId>
    <version>1.0</version>
</project>
----

That's all you need in your 'pom.xml'. Running +mvn install+ from the command line will process resources, compile source, execute unit tests, create a JAR, and install the JAR in a local repository for reuse in other projects. Without modification, you can run +mvn site+ and then find an 'index.html' file in 'target/site' that contains links to JavaDoc and a few reports about your source code.

Admittedly, this is the simplest possible example project containing nothing more than some source code and producing a simple JAR. It is a project which closely follows Maven conventions and doesn't require any dependencies or customization. If we wanted to start customizing the behavior, our 'pom.xml' is going to grow in size, and in the largest of projects you can see collections of very complex Maven POMs which contain a great deal of plugin customization and dependency declarations. But, even when your project's POM files become more substantial, they hold an entirely different kind of information from the build file of a similarly sized project using Ant. Maven POMs contain declarations: "This is a JAR project", and "The source code is in 'src/main/java'". Ant build files contain explicit instructions: "This is project", "The source is in 'src/main/java'", "Run javac against this directory", "Put the results in 'target/classes'", "Create a JAR from the ....", etc. Where Ant had to be explicit about the process, there was something "built-in" to Maven that just knew where the source code was and how it should be processed.


The differences between Ant and Maven in this example are:

* Apache Ant

** Ant doesn't have formal conventions like a common project directory structure or default behavior. You have to tell Ant *exactly* where to find the source and where to put the output. Informal conventions have emerged over time, but they haven't been codified into the product.

** Ant is procedural. You have to tell Ant exactly what to do and when to do it. You have to tell it to compile, then copy, then compress.

** Ant doesn't have a lifecycle. You have to define goals and goal dependencies. You have to attach a sequence of tasks to each goal manually.

* Apache Maven

** Maven has conventions. It knows where your source code is because you followed the convention. Maven's Compiler plugin put the bytecode in 'target/classes', and it produces a JAR file in target.

** Maven is declarative. All you had to do was create a 'pom.xml' file and put your source in the default directory. Maven took care of the rest.

** Maven has a lifecycle which was invoked when you executed +mvn install+. This command told Maven to execute a series of sequential lifecycle phases until it reached the install lifecycle phase. As a side-effect of this journey through the lifecycle, Maven executed a number of default plugin goals which did things like compile and create a JAR.

Maven has built-in intelligence about common project tasks in the form of Maven plugins. If you wanted to write and execute unit tests, all you would need to do is write the tests, place them in '+++${basedir}/src/test/java+++', add a test-scoped dependency on either TestNG or JUnit, and run +mvn test+. If you wanted to deploy a web application and not a JAR, all you would need to do is change your project type to +war+ and put your docroot in '+++${basedir}/src/main/webapp+++'. Sure, you can do all of this with Ant, but you will be writing the instructions from scratch. In Ant, you would first have to figure out where the JUnit JAR file should be. Then you would have to create a classpath that includes the JUnit JAR file. Then you would tell Ant where it should look for test source code, write a goal that compiles the test source to bytecode, and execute the unit tests with JUnit.

Without supporting technologies like antlibs and Ivy (even with these supporting technologies), Ant has the feeling of a c`ustom procedural build. An efficient set of Maven POMs in a project which adheres to Maven's assumed conventions has surprisingly little XML compared to the Ant alternative. Another benefit of Maven is the reliance on widely-shared Maven plugins. Everyone uses the Maven Surefire plugin for unit testing, and if someone adds support for a new unit testing framework, you can gain new capabilities in your own build by just incrementing the version of a particular Maven plugin in your project's POM.

The decision to use Maven or Ant isn't a binary one, and Ant still has a place in a complex build. If your current build contains some highly customized process, or if you've written some Ant scripts to complete a specific process in a specific way that cannot be adapted to the Maven standards, you can still use these scripts with Maven. Ant is made available as a core Maven plugin. Custom Maven plugins can be implemented in Ant, and Maven projects can be configured to execute Ant scripts within the Maven project lifecycle.

[[installation]]
== Installing Maven

This chapter contains very detailed instructions for installing Maven on a number of different platforms. Instead of assuming a level of familiarity with installing software and setting environment variables, we've opted to be as thorough as possible to minimize any problems that might arise do to a partial installation. The only thing this chapter assumes is that you've already installed a suitable Java Development Kit (JDK). If you are just interested in installation, you can move on to the rest of the book after reading through <<installation-sect-maven-download>> and <<installation-sect-maven-install>>. If you are interested in the details of your Maven installation, this entire chapter will give you an overview of what you've installed and the meaning of the Apache Software License, Version 2.0.

[[installation-sect-java]]
=== Verify your Java Installation

While Maven can run on Java 1.4, this book assumes that you are running at least Java 5. Go with the most recent stable Java Development Kit (JDK) available for your operating system. Either Java 5 or Java 6 will work with all of the examples in this book.

----
% java -version
java version "1.5.0_16"
Java(TM) 2 Runtime Environment, Standard Edition (build 1.5.0_16-b06-284)
Java HotSpot(TM) Client VM (build 1.5.0_16-133, mixed mode, sharing)
----

Maven works with all certified Java^TM^ compatible development kits, and a few non-certified implementations of Java. The examples in this book were written and tested against the official Java Development Kit releases downloaded from the Sun Microsystems web site. If you’re working with a Linux distribution, you may need to download Sun’s JDK yourself and make sure it’s the version you’re invoking (by running +java -version+). Now that Sun has open-sourced Java, this will hopefully improve in the future, and we’ll get the Sun JRE and JDK by default even in purist Linux distributions. Until that day, you may need to do some of your own downloading.

[[installation-sect-maven-download]]
=== Downloading Maven

You can download Maven from the Apache Maven project website at http://maven.apache.org/download.html[http://maven.apache.org/download.html].

When downloading Maven, you can download the latest available version of Maven 2 or the latest available version of Maven 3. The latest version of Maven 2 when this book was written was Maven 3.0.3, and the latest version of Maven 3 was ${maven3.version}. If you are not familiar with the Apache Software License, you should familiarize yourself with the terms of the license before you start using the product. More information on the Apache Software License can be found in <<installation-sect-license>>.

==== Downloading Maven 2

To download Maven 2, go to http://maven.apache.org/download.html[http://maven.apache.org/download.html] and select the appropriate archive format for your platform. shows the section of the download page that contains links to the Apache Maven 3.0.3 archives.

[[fig-installation-maven2-download]]
.Downloading Maven 2 from the Apache Maven web site
image::figs/web/installing-download-maven2.png[]

==== Downloading Maven 3

To download Maven 3, go to http://maven.apache.org/download.html[http://maven.apache.org/download.html] and select the appropriate archive format for your platform. shows the section of the download page that contains links to the Apache Maven ${maven3.version} archives.

[[fig-installation-maven3-download]]
.Downloading Maven 3 from the Apache Maven web site
image::figs/web/installing-download-maven3.png[]

[[installation-sect-maven-install]]
=== Installing Maven

There are wide differences between operating systems such as Mac OS X and Microsoft Windows, and there are subtle differences between different versions of Windows. Luckily, the process of installing Maven on all of these operating systems is relatively painless and straightforward. The following sections outline the recommended best-practice for installing Maven on a variety of operating systems.

[[installation-sect-maven-osx]]
==== Installing Maven on Mac OSX

You can download a binary release of Maven from http://maven.apache.org/download.html[http://maven.apache.org/download.html]. Download the current release of Maven in a format that is convenient for you to work with. Pick an appropriate place for it to live, and expand the archive there. If you expanded the archive into the directory '/usr/local/apache-maven-3.0.3', you may want to create a symbolic link to make it easier to work with and to avoid the need to change any environment configuration when you upgrade to a newer version:

----
/usr/local % cd /usr/local
/usr/local % ln -s apache-maven-3.0.3 maven
/usr/local % export M2_HOME=/usr/local/maven
/usr/local % export PATH=${M2_HOME}/bin:${PATH}
----

Once Maven is installed, you need to do a couple of things to make it work correctly. You need to add its 'bin' directory in the distribution (in this example, '/usr/local/maven/bin') to your command path. You also need to set the environment variable +M2_HOME+ to the top-level directory you installed (in this example, '/usr/local/maven').

NOTE: Installation instructions are the same for both OSX Tiger and OSX Leopard. It has been reported that Maven 2.0.6 is shipping with a preview release of XCode. If you have installed XCode, run +mvn+ from the command-line to check availability. XCode installs Maven in '/usr/share/maven'. We recommend installing the most recent version of Maven 3.0.3 as there have been a number of critical bug fixes and improvements since Maven 2.0.6 was released.

You'll need to add both +M2_HOME+ and +PATH+ to a script that will run every time you login. To do this, add the following lines to '.bash_login'.

----
export M2_HOME=/usr/local/maven
export PATH=${M2_HOME}/bin:${PATH}
----

Once you've added these lines to your own environment, you will be able to run Maven from the command line.

NOTE: These installation instructions assume that you are running bash.


[[installation-sect-macports]]
===== Installing Maven on OSX using MacPorts

If you are using MacPorts, you can install the maven2 port by executing the following command-line:

----
$ sudo port install maven2
Password: ******
--->  Fetching maven2
--->  Attempting to fetch apache-maven-3.0.3-bin.tar.bz2 
from http://www.apache.org/dist/maven/binaries
--->  Verifying checksum(s) for maven2
--->  Extracting maven2
--->  Configuring maven2
--->  Building maven2 with target all
--->  Staging maven2 into destroot
--->  Installing maven2 3.0.3_0
--->  Activating maven2 3.0.3_0
--->  Cleaning maven2
----

For more information about the maven2 port, see the maven2 http://trac.macports.org/browser/trunk/dports/java/maven2/Portfile[Portfile]. For more information about MacPorts and how to install it, see the http://www.macports.org/index.php[MacPorts project page].

[[installation-sect-windows]]
==== Installing Maven on Microsoft Windows

Installing Maven on Windows is very similar to installing Maven on Mac OSX, the main differences being the installation location and the setting of an environment variable. This book assumes a Maven installation directory of 'c:\Program Files\apache-maven-3.0.3', but it won't make a difference if you install Maven in another directory as long as you configure the proper environment variables. Once you've unpacked Maven to the installation directory, you will need to set two environment variables—+PATH+ and +M2_HOME+. To set these environment variables from the command-line, type in the following commands:

----
C:\Users\tobrien > +set M2_HOME=c:\Program Files\apache-maven-3.0.3+
C:\Users\tobrien > +set PATH=%PATH%;%M2_HOME%\bin+
----

Setting these environment variables on the command-line will allow you to run Maven in your current session, but unless you add them to the System environment variables through the control panel, you'll have to execute these two lines every time you log into your system. You should modify both of these variables through the Control Panel in Microsoft Windows.

[[installation-sect-maven-linux]]
==== Installing Maven on Linux

To install Maven on a Linux machine follow the exact procedure outlined in <<installation-sect-maven-osx>>.

[[installation-sect-bsd]]
==== Installing Maven on FreeBSD or OpenBSD

To install Maven on a FreeBSD or OpenBSD machine, follow the exact procedure outlined in <<installation-sect-maven-osx>>.

[[installation-sect-test-install]]
=== Testing a Maven Installation

Once Maven is installed, you can check the version by running +mvn -v+ from the command-line. If Maven has been installed, you should see something resembling the following output.

----
$ mvn -v
Apache Maven 2.2.0 (r788681; 2009-06-26 08:04:01-0500)
Java version: 1.5.0_19
Java home: /System/Library/Frameworks/JavaVM.framework/Versions/1.5.0/Home
Default locale: en_US, platform encoding: MacRoman
OS name: "mac os x" version: "10.5.7" arch: "i386" Family: "unix"
----

If you see this output, you know that Maven is available and ready to be used. If you do not see this output, and your operating system cannot find the +mvn+ command, make sure that your +PATH+ environment variable and +M2_HOME+ environment variable have been properly set.

[[installation-sect-details]]
=== Maven Installation Details

Maven's download measures in at roughly 1.5 MiB, it has attained such a slim download size because the core of Maven has been designed to retrieve plugins and dependencies from a remote repository on-demand. When you start using Maven, it will start to download plugins to a local repository described in <<installation-sect-user>>. In case you are curious, let's take a quick look at what is in Maven's installation directory. 

----
/usr/local/maven $ ls -p1
LICENSE.txt
NOTICE.txt
README.txt
bin/
boot/
conf/
lib/
----

'LICENSE.txt' contains the software license for Apache Maven. This license is described in some detail later in the section <<installation-sect-license>>. 'NOTICE.txt' contains some notices and attributions required by libraries that Maven depends on. 'README.txt' contains some installation instructions. 'bin/' contains the 'mvn' script that executes Maven. 'boot/' contains a JAR file ('classwords-1.1.jar') that is responsible for creating the Class Loader in which Maven executes. 'conf/' contains a global 'settings.xml' that can be used to customize the behavior of your Maven installation. If you need to customize Maven, it is customary to override any settings in a 'settings.xml' file stored in '~/.m2'. 'lib/' contains a single JAR file ('maven-core-3.0.3-uber.jar') that contains the core of Maven.

NOTE: Unless you are working in a shared Unix environment, you should avoid customizing the 'settings.xml' in 'M2_HOME/conf'. Altering the global 'settings.xml' file in the Maven installation itself is usually unnecessary and it tends to complicate the upgrade procedure for Maven as you'll have to remember to copy the customized 'settings.xml' from the old Maven installation to the new installation. If you need to customize 'settings.xml', you should be editing your own 'settings.xml' in '~/.m2/settings.xml'.

[[installation-sect-user]]
==== User-specific Configuration and Repository

Once you start using Maven extensively, you'll notice that Maven has created some local user-specific configuration files and a local repository in your home directory. In '~/.m2' there will be:

~/.m2/settings.xml::

  A file containing user-specific configuration for authentication, repositories, and other information to customize the behavior of Maven.

~/.m2/repository/::

  This directory contains your local Maven repository. When you download a dependency from a remote Maven repository, Maven stores a copy of the dependency in your local repository.

NOTE: In Unix (and OSX), your home directory will be referred to using a tilde (i.e. '~/bin' refers to '/home/tobrien/bin'). In Windows, we will also be using '~' to refer to your home directory. In Windows XP, your home directory is 'C:\Documents and Settings\tobrien', and in Windows Vista, your home directory is 'C:\Users\tobrien'. From this point forward, you should translate paths such as '~/m2' to your operating system's equivalent.

[[installation-sect-upgrade]]
==== Upgrading a Maven Installation

If you've installed Maven on a Mac OSX or Unix machine according to the details in <<installation-sect-maven-osx>> and <<installation-sect-maven-linux>>, it should be easy to upgrade to newer versions of Maven when they become available. Simply install the newer version of Maven ('/usr/local/maven-2.future') next to the existing version of Maven ('/usr/local/maven-3.0.3'). Then switch the symbolic link '/usr/local/maven' from '/usr/local/maven-3.0.3' to '/usr/local/maven-2.future'. Since, you've already set your +M2_HOME+ variable to point to '/usr/local/maven', you won't need to change any environment variables.

If you have installed Maven on a Windows machine, simply unpack Maven to 'c:\Program Files\maven-2.future' and update your +M2_HOME+ variable.

NOTE: If you have any customizations to the global 'settings.xml' in 'M2_HOME/conf', you will need to copy this 'settings.xml' to the 'conf' directory of the new Maven installation.

[[installation-sect-upgrade-detail]]
==== Upgrading from Maven 1.x to Maven 2.x

If you are upgrading from Maven 1 to Maven 2, you are going to be using an entirely new POM and repository structure. If you have already created a custom Maven 1 repository to hold custom artifacts, you can use the Nexus Repository Manager to expose a Maven 1 repository in a format that can be understood by Maven 2 clients. For more information about the Nexus Repository Manager, see http://www.sonatype.com/books/nexus-book/reference/[Repository Management with Nexus]. In addition to tools like Nexus, you can also configure references to repositories to use the +legacy+ layout format. For more information about configuring a reference to a legacy repository, see <<appendix-settings-sect-settings-repository>>. 

If you have a set of Maven 1 projects, you may want to know about the Maven One Plugin. The Maven One Plugin was designed to help projects migrate from Maven 1 to Maven 2. If you have a Maven 1 project, you can convert the project's POM by running the +one:convert+ goal as follows:

----
$ cd my-project
$ mvn one:convert
----

+one:convert+ will read a 'project.xml' and produce a 'pom.xml' that is compatible with Maven 2. If you've customized a Maven 1 build using Jelly script in a 'maven.xml' file, you will need to investigate other options. While Maven 1 emphasized Jelly scripting for customizing builds, Maven 2 favors custom plugins or customization through scripting Plugins or the Maven Antrun Plugin.

The most important thing to know about when upgrading from Maven 1 to Maven 2 is that Maven 2 is a completely different build framework. Maven 2 introduces the concept of the Maven Lifecycle and redefines the relationships between plugins. If you upgrade from Maven 1 to Maven 2, you need to invest some time in learning about the differences between the two versions. Although it might seem straightforward to start learning about the new POM structure, you should focus on the Lifecycle first. If you understand the Maven Lifecycle, you will be able to use Maven to its fullest potential.

[[installation-sect-uninstalling]]
=== Uninstalling Maven

Most of the installation instructions involve unpacking of the Maven distribution archive in a directory and setting of various environment variables. If you need to remove Maven from your computer, all you need to do is delete your Maven installation directory and remove the environment variables. You will also want to delete the '~/.m2' directory as it contains your local repository.

[[installation-sect-getting-help]]
=== Getting Help with Maven

While this book aims to be a comprehensive reference, there are going to be topics we will miss and special situations and tips which are not covered. While the core of Maven is very simple, the real work in Maven happens in the plugins, and there are too many plugins available to cover them all in one book. You are going to encounter problems and features which have not been covered in this book; in these cases, we suggest searching for answers at the following locations:

maven.apache.org:::

  This will be the first place to look, the Maven web site contains a wealth of information and documentation. Every plugin has a few pages of documentation and there are a series of "quick start" documents which will be helpful in addition to the content of this book. While the Maven site contains a wealth of information, it can also be a frustrating, confusing, and overwhelming. There is a custom Google search box on the main Maven page that will search known Maven sites for information. This provides better results than a generic Google search.

Maven User Mailing List::

  The Maven User mailing list is the place for users to ask questions. Before you ask a question on the user mailing list, you will want to search for any previous discussion that might relate to your question. It is bad form to ask a question that has already been asked without first checking to see if an answer already exists in the archives. There are a number of useful mailing list archive browsers, we've found Nabble to the be the most useful. You can browse the User mailing list archives here: http://www.nabble.com/Maven---Users-f178.html[http://www.nabble.com/Maven---Users-f178.html]. You can join the user mailing list by following the instructions available here http://maven.apache.org/mail-lists.html[http://maven.apache.org/mail-lists.html].

www.sonatype.com::

  Sonatype maintains an online copy of this book and other tutorials related to Apache Maven.

[[installation-sect-license]]
=== About the Apache Software License

Apache Maven is released under the Apache Software License, Version 2.0. If you want to read this license, you can read '+++${M2_HOME}/LICENSE.txt+++' or read this license on the Open Source Initiative's web site here: http://www.opensource.org/licenses/apache2.0.php[http://www.opensource.org/licenses/apache2.0.php].

There's a good chance that, if you are reading this book, you are not a lawyer. If you are wondering what the Apache License, Version 2.0 means, the Apache Software Foundation has assembled a very helpful Frequently Asked Questions (FAQ) page about the license available here: http://www.apache.org/foundation/licence-FAQ.html[http://www.apache.org/foundation/licence-FAQ.html]. Here's is the answer to the question "I am not a lawyer. What does it all mean?"

[This license] allows you to:

* freely download and use Apache software, in whole or in part, for personal, company internal, or commercial purposes;

* use Apache software in packages or distributions that you create.

It forbids you to:

* redistribute any piece of Apache-originated software without proper attribution;

* use any marks owned by The Apache Software Foundation in any way that might state or imply that the Foundation endorses your distribution;

* use any marks owned by The Apache Software Foundation in any way that might state or imply that you created the Apache software in question.

It requires you to:

* include a copy of the license in any redistribution you may make that includes Apache software;

* provide clear attribution to The Apache Software Foundation for any distributions that include Apache software.

It does not require you to:

* include the source of the Apache software itself, or of any modifications you may have made to it, in any redistribution you may assemble that includes it;

* submit changes that you make to the software back to the Apache Software Foundation (though such feedback is encouraged).

[[pom-relationships]]
== The Project Object Model

[[pom-relationships-sect-intro]]
=== Introduction

This chapter covers the central concept of Maven—the Project Object Model. The POM is where a project’s identity and structure are declared, builds are configured, and projects are related to one another. The presence of a 'pom.xml' file defines a Maven project.

[[pom-relationships-sect-pom]]
=== The POM

Maven projects, dependencies, builds, artifacts: all of these are objects to be modeled and described. These objects are described by an XML file called a Project Object Model. The POM tells Maven what sort of project it is dealing with and how to modify default behavior to generate output from source. In the same way a Java web application has a 'web.xml' that describes, configures, and customizes the application, a Maven project is defined by the presence of a 'pom.xml'. It is a descriptive declaration of a project for Maven; it is the figurative “map” that Maven needs to understand what it is looking at when it builds your project.

You could also think of the 'pom.xml' as analogous to a 'Makefile' or an Ant 'build.xml'. When you are using GNU *make* to build something like MySQL, you’ll usually have a file named 'Makefile' that contains explicit instructions for building a binary from source. When you are using Apache Ant, you likely have a file named 'build.xml' that contains explicit instructions for cleaning, compiling, packaging, and deploying an application. *make*, Ant, and Maven are similar in that they rely on the presence of a commonly named file such as 'Makefile', 'build.xml', or 'pom.xml', but that is where the similarities end. If you look at a Maven 'pom.xml', the majority of the POM is going to deal with descriptions: Where is the source code? Where are the resources? What is the packaging? If you look at an Ant 'build.xml' file, you’ll see something entirely different. You’ll see explicit instructions for tasks such as compiling a set of Java classes. The Maven POM is declarative, and although you can certainly choose to include some procedural customizations via the Maven Ant plugin, for the most part you will not need to get into the gritty procedural details of your project’s build.

The POM is also not specific to building Java projects. While most of the examples in this book are geared towards Java applications, there is nothing Java-specific in the definition of a Maven Project Object Model. While Maven's default plugins are targeted at building JAR artifacts from a set of source, tests, and resources, there is nothing preventing you from defining a POM for a project that contains C# sources and produces some proprietary Microsoft binary using Microsoft tools. Similarly, there is nothing stopping you from defining a POM for a technical book. In fact, the source for this book and this book's examples is captured in a multi-module Maven project which uses one of the many Maven Docbook plugins to apply the standard Docbook XSL to a series of chapter XML files. Others have created Maven plugins to build Adobe Flex code into SWCs and SWFs, and yet others have used Maven to build projects written in C.

We've established that the POM describes and declares, it is unlike Ant or Make in that it doesn't provide explicit instructions, and we've noted that POM concepts are not specific to Java. Diving into more specifics, take a look at <<fig-pom>> for a survey of the contents of a POM.

[[fig-pom]]
.The Project Object Model
image::figs/web/pom-relationships_pom-small.png[]

The POM contains four categories of description and configuration:

General project information::

  This includes a project’s name, the URL for a project, the sponsoring organization, and a list of developers and contributors along with the license for a project.

Build settings::

  In this section, we customize the behavior of the default Maven build. We can change the location of source and tests, we can add new plugins, we can attach plugin goals to the lifecycle, and we can customize the site generation parameters.

Build environment::

  The build environment consists of profiles that can be activated for use in different environments. For example, during development you may want to deploy to a development server, whereas in production you want to deploy to a production server. The build environment customizes the build settings for specific environments and is often supplemented by a custom 'settings.xml' in '~/.m2'. This settings file is discussed in <<profiles>> and in the section <<appendix-settings-sect-details>>.

POM relationships::

  A project rarely stands alone; it depends on other projects, inherits POM settings from parent projects, defines its own coordinates, and may include submodules.

[[pom-relationships-sect-super-pom]]
==== The Super POM

Before we dive into some examples of POMs, let's take a quick look at the Super POM. All Maven project POMs extend the Super POM, which defines a set of defaults shared by all projects. This Super POM is a part of the Maven installation and can be found in the 'maven-3.0.3-uber.jar' file in '+++${M2_HOME}/lib+++'. If you look in this JAR file, you will find a file named 'pom-4.0.0.xml' under the +org.apache.maven.project+ package. The Super POM for Maven is shown in <<ex-super-pom>>.

[[ex-super-pom]]
.The Super POM
----
<project>
    <modelVersion>4.0.0</modelVersion>
    <name>Maven Default Project</name>

    <repositories>
        <repository>
            <id>central</id> <1>
                <name>Maven Repository Switchboard</name>
                <layout>default</layout>
                <url>http://repo1.maven.org/maven2</url>
                <snapshots>
                    <enabled>false</enabled>
                </snapshots>
        </repository>
    </repositories>

    <pluginRepositories>
        <pluginRepository>
            <id>central</id> <2>
                <name>Maven Plugin Repository</name>
                <url>http://repo1.maven.org/maven2</url>
                <layout>default</layout>
                <snapshots>
                    <enabled>false</enabled>
                </snapshots>
                <releases>
                    <updatePolicy>never</updatePolicy>
                </releases>
        </pluginRepository>
    </pluginRepositories>

    <build> <3>
            <directory>${project.basedir}/target</directory>
            <outputDirectory>
                ${project.build.directory}/classes
            </outputDirectory>
            <finalName>${project.artifactId}-${project.version}</finalName>
            <testOutputDirectory>
                ${project.build.directory}/test-classes
            </testOutputDirectory>
            <sourceDirectory>
                ${project.basedir}/src/main/java
            </sourceDirectory>
            <scriptSourceDirectory>src/main/scripts</scriptSourceDirectory>
            <testSourceDirectory>
                ${project.basedir}/src/test/java
            </testSourceDirectory>
            <resources>
                <resource>
                    <directory>${project.basedir}/src/main/resources</directory>
                </resource>
            </resources>
            <testResources>
                <testResource>
                    <directory>${project.basedir}/src/test/resources</directory>
                </testResource>
            </testResources>


            <pluginManagement> <4>
                    <plugins>
                        <plugin>
                            <artifactId>maven-antrun-plugin</artifactId>
                            <version>1.3</version>
                        </plugin>
                        <plugin>
                            <artifactId>maven-assembly-plugin</artifactId>
                            <version>2.2-beta-2</version>
                        </plugin>
                        <plugin>
                            <artifactId>maven-clean-plugin</artifactId>
                            <version>2.2</version>
                        </plugin>
                        <plugin>
                            <artifactId>maven-compiler-plugin</artifactId>
                            <version>2.0.2</version>
                        </plugin>
                        <plugin>
                            <artifactId>maven-dependency-plugin</artifactId>
                            <version>2.0</version>
                        </plugin>
                        <plugin>
                            <artifactId>maven-deploy-plugin</artifactId>
                            <version>2.4</version>
                        </plugin>
                        <plugin>
                            <artifactId>maven-ear-plugin</artifactId>
                            <version>2.3.1</version>
                        </plugin>
                        <plugin>
                            <artifactId>maven-ejb-plugin</artifactId>
                            <version>2.1</version>
                        </plugin>
                        <plugin>
                            <artifactId>maven-install-plugin</artifactId>
                            <version>2.2</version>
                        </plugin>
                        <plugin>
                            <artifactId>maven-jar-plugin</artifactId>
                            <version>2.2</version>
                        </plugin>
                        <plugin>
                            <artifactId>maven-javadoc-plugin</artifactId>
                            <version>2.5</version>
                        </plugin>
                        <plugin>
                            <artifactId>maven-plugin-plugin</artifactId>
                            <version>2.4.3</version>
                        </plugin>
                        <plugin>
                            <artifactId>maven-rar-plugin</artifactId>
                            <version>2.2</version>
                        </plugin>
                        <plugin>
                            <artifactId>maven-release-plugin</artifactId>
                            <version>2.0-beta-8</version>
                        </plugin>
                        <plugin>
                            <artifactId>maven-resources-plugin</artifactId>
                            <version>2.3</version>
                        </plugin>
                        <plugin>
                            <artifactId>maven-site-plugin</artifactId>
                            <version>2.0-beta-7</version>
                        </plugin>
                        <plugin>
                            <artifactId>maven-source-plugin</artifactId>
                            <version>2.0.4</version>
                        </plugin>
                        <plugin>
                            <artifactId>maven-surefire-plugin</artifactId>
                            <version>2.4.3</version>
                        </plugin>
                        <plugin>
                            <artifactId>maven-war-plugin</artifactId>
                            <version>2.1-alpha-2</version>
                        </plugin>
                    </plugins>
            </pluginManagement>

            <reporting>
                <outputDirectory>target/site</outputDirectory>
            </reporting>
</project>
----

The Super POM defines some standard configuration variables that are inherited by all projects. Those values are captured in the annotated sections:

<1> The default Super POM defines a single remote Maven repository with an ID of +central+. This is the central Maven repository that all Maven clients are configured to read from by default. This setting can be overridden by a custom 'settings.xml' file. Note that the default Super POM has disabled snapshot artifacts on the central Maven repository. If you need to use a snapshot repository, you will need to customize repository settings in your 'pom.xml' or in your 'settings.xml'. Settings and profiles are covered in <<profiles>> and in <<appendix-settings-sect-details>>.

<2> The central Maven repository also contains Maven plugins. The default plugin repository is the central Maven repository. Snapshots are disabled, and the update policy is set to “never,” which means that Maven will never automatically update a plugin if a new version is released.

<3> The +build+ element sets the default values for directories in the Maven Standard Directory layout.

<4> Starting in Maven 2.0.9, default versions of core plugins have been provided in the Super POM. This was done to provide some stability for users that are not specifying versions in their POMs.

[[fig-super-always-base]]
.The Super POM is always the base Parent
image::figs/web/pom-relationships_pom-inherit-simple-super.png[]

[[pom-relationships-sect-simplest-pom]]
==== The Simplest POM

All Maven POMs inherit defaults from the Super POM (introduced earlier in the section <<pom-relationships-sect-super-pom>>). If you are just writing a simple project that produces a JAR from some source in 'src/main/java', want to run your JUnit tests in 'src/test/java', and want to build a project site using +mvn site+, you don’t have to customize anything. All you would need, in this case, is the simplest possible POM shown in <<ex-simplest-pom>>. This POM defines a +groupId+, +artifactId+, and +version+: the three required coordinates for every project.

[[ex-simplest-pom]]
.The Simplest POM
----
<project>
    <modelVersion>4.0.0</modelVersion>
    <groupId>org.sonatype.mavenbook.ch08</groupId>
    <artifactId>simplest-project</artifactId>
    <version>1</version>
</project>
----

Such a simple POM would be more than adequate for a simple project—e.g., a Java library that produces a JAR file. It isn’t related to any other projects, it has no dependencies, and it lacks basic information such as a name and a URL. If you were to create this file and then create the subdirectory 'src/main/java' with some source code, running +mvn package+ would produce a JAR in 'target/simple-project-1.jar'.

[[pom-relationships-sect-effective-pom]]
==== The Effective POM



----
$ mvn help:effective-pom
----

Executing the +effective-pom+ goal should print out an XML document capturing the merge between the Super POM and the POM from <<ex-simplest-pom>>.

[[pom-relationships-sect-real-poms]]
==== Real POMs

Maven is something of a chameleon; you can pick and choose the features you want to take advantage of. Some open source projects may value the ability to list developers and contributors, generate clean project documentation, and manage releases automatically using the Maven Release plugin. On the other hand, someone working in a corporate environment on a small team might not be interested in the distribution management capabilities of Maven nor the ability to list developers. The remainder of this chapter is going to discuss features of the POM in isolation. Instead of bombarding you with a 10-page listing of a set of related POMs, we’re going to focus on creating a good reference for specific sections of the POM. In this chapter, we discuss relationships between POMs, but we don’t illustrate such a project here.

[[pom-relationships-sect-pom-syntax]]
=== POM Syntax

The POM is always in a file named 'pom.xml' in the base directory of a Maven project. This XML document can start with the XML declaration, or you can choose to omit it. All values in a POM are captured as XML elements.

[[pom-reationships-sect-versions]]
==== Project Versions

A project's version number is used to group and order releases. Maven versions contain the following parts: major version, minor version, incremental version, and qualifier. In a version, these parts correspond to the following format:

----
<major version>.<minor version>.<incremental version>-<qualifier>
----

For example, the version "1.3.5" has a major version of 1, a minor version of 3, and an incremental version of 5. The version "5" has a major version of 5 and no minor or incremental version. The qualifier exists to capture milestone builds: alpha and beta releases, and the qualifier is separated from the major, minor, and incremental versions by a hyphen. For example, the version "1.3-beta-01" has a major version of 1, a minor version of 3, and a qualifier of "beta-01".

Keeping your version numbers aligned with this standard will become very important when you want to start using version ranges in your POMs. Version ranges, introduced in <<pom-relationships-sect-version-ranges>>, allow you to specify a dependency on a range of versions, and they are only supported because Maven has the ability to sort versions based on the version release number format introduced in this section.

If your version release number matches the format +<major>.<minor>.<incremental>-<qualifier>+ then your versions will be compared properly; "1.2.3" will be evaluated as a more recent build than "1.0.2", and the comparison will be made using the numeric values of the major, minor, and incremental versions. If your version release number does not fit the standard introduced in this section, then your versions will be compared as strings; "1.0.1b" will be compared to "1.2.0b" using a String comparison.

[[pom-relationships-sect-version-build-numbers]]
===== Version Build Numbers

One gotcha for release version numbers is the ordering of the qualifiers. Take the version release numbers “1.2.3-alpha-2” and “1.2.3-alpha-10,” where the “alpha-2” build corresponds to the 2nd alpha build, and the “alpha-10” build corresponds to the 10th alpha build. Even though “alpha-10” should be considered more recent than “alpha-2,” Maven is going to sort “alpha-10” before “alpha-2” due to a known issue in the way Maven handles version numbers.

Maven is supposed to treat the number after the qualifier as a build number. In other words, the qualifier should be "alpha", and the build number should be 2. Even though Maven has been designed to separate the build number from the qualifier, this parsing is currently broken. As a result, "alpha-2" and "alpha-10" are compared using a String comparison, and "alpha-10" comes before "alpha-2" alphabetically. To get around this limitation, you will need to left-pad your qualified build numbers. If you use "alpha-02" and "alpha-10" this problem will go away, and it will continue to work once Maven properly parses the version build number. 

[[pom-relationships-sect-snapshot-versions]]
===== SNAPSHOT Versions

Maven versions can contain a string literal to signify that a project is currently under active development. If a version contains the string “SNAPSHOT,” then Maven will expand this token to a date and time value converted to UTC (Coordinated Universal Time) when you install or release this component. For example, if your project has a version of “1.0-SNAPSHOT” and you deploy this project’s artifacts to a Maven repository, Maven would expand this version to “1.0-20080207-230803-1” if you were to deploy a release at 11:08 PM on February 7th, 2008 UTC. In other words, when you deploy a snapshot, you are not making a release of a software component; you are releasing a snapshot of a component at a specific time.

Why would you use this? SNAPSHOT versions are used for projects under active development. If your project depends on a software component that is under active development, you can depend on a SNAPSHOT release, and Maven will periodically attempt to download the latest snapshot from a repository when you run a build. Similarly, if the next release of your system is going to have a version "1.4", your project would have a version "1.4-SNAPSHOT" until it was formally released.

As a default setting, Maven will not check for SNAPSHOT releases on remote repositories. To depend on SNAPSHOT releases, users must explicitly enable the ability to download snapshots using a +repository+ or +pluginRepository+ element in the POM.

When releasing a project, you should resolve all dependencies on SNAPSHOT versions to dependencies on released versions. If a project depends on a SNAPSHOT, it is not stable as the dependencies may change over time. Artifacts published to non-snapshot Maven repositories such as http://repo1.maven.org/maven2[http://repo1.maven.org/maven2] cannot depend on SNAPSHOT versions, as Maven's Super POM has snapshot's disabled from the Central repository. SNAPSHOT versions are for development only.  

[[pom-relationships-sect-property-refs]]
==== Property References

preceded by a dollar sign and surrounded by two curly braces. For example, consider the following POM:

----
<project>
    <modelVersion>4.0.0</modelVersion>
    <groupId>org.sonatype.mavenbook</groupId>
    <artifactId>project-a</artifactId>
    <version>1.0-SNAPSHOT</version>
    <packaging>jar</packaging>
    <build>
        <finalName>${project.groupId}-${project.artifactId}</finalName>
    </build>
</project>
----

If you put this XML in a 'pom.xml' and run +mvn help:effective-pom+, you will see that the output contains the line:

----
...
<finalName>org.sonatype.mavenbook-project-a</finalName>
...
----

When Maven reads a POM, it replaces references to properties when it loads the POM XML. Maven properties occur frequently in advanced Maven usage, and are similar to properties in other systems such as Ant or Velocity. They are simply variables delimited by '+++${...}+++'. Maven provides three implicit variables which can be used to access environment variables, POM information, and Maven Settings:

env::

  The +env+ variable exposes environment variables exposed by your operating system or shell. For example, a reference to '+++${env.PATH}+++' in a Maven POM would be replaced by the '+++${PATH}+++' environment variable (or +%PATH%+ in Windows).

project::

  The +project+ variable exposes the POM. You can use a dot-notated (.) path to reference the value of a POM element. For example, in this section we used the +groupId+ and +artifactId+ to set the +finalName+ element in the build configuration. The syntax for this property reference was: '+++${project.groupId}-${project.artifactId}+++'.

settings::

  The +settings+ variable exposes Maven settings information. You can use a dot-notated (.) path to reference the value of an element in a 'settings.xml' file. For example, '+++${settings.offline}+++' would reference the value of the +offline+ element in '~/.m2/settings.xml'.

NOTE: You may see older builds that use '+++${pom.xxx}+++' or just '+++${xxx}+++' to reference POM properties. These methods have been deprecated and only '+++${project.xxx}+++' should be used.

In addition to the three implicit variables, you can reference system properties and any custom properties set in the Maven POM or in a build profile:

Java System Properties::

  All properties accessible via +getProperties()+ on +java.lang.System+ are exposed as POM properties. Some examples of system properties are: '+++${user.name}+++', <varname role="keep-together">'+++${user.home}+++', '+++${java.home}+++', and '+++${os.name}+++'. A full list of system properties can be found in the Javadoc for the +java.lang.System+ class.

x::

  Arbitrary properties can be set with a +properties+ element in a 'pom.xml' or <filename moreinfo="none" role="keep-together">settings.xml', or properties can be loaded from external files. If you set a property named +fooBar+ in your 'pom.xml', that same property is referenced with '+++${fooBar}+++'. Custom properties come in handy when you are building a system that filters resources and targets different deployment platforms. Here is the syntax for setting '+++${foo}=bar+++' in a POM:

----
<properties>
    <foo>bar</foo>
</properties>
----

For a more comprehensive list of available properties, see <<resource-filtering>>.

[[pom-relationships-sect-project-dependencies]]
=== Project Dependencies

Maven can manage both internal and external dependencies. An external dependency for a Java project might be a library such as Plexus, the Spring Framework, or Log4J. An internal dependency is illustrated by a web application project depending on another project that contains service classes, model objects, or persistence logic. <<ex-dependency>> shows some examples of project dependencies.

[[ex-dependency]]
.Project Dependencies
----
<project>
    ...
    <dependencies>
        <dependency>
            <groupId>org.codehaus.xfire</groupId>
            <artifactId>xfire-java5</artifactId>
            <version>1.2.5</version>
        </dependency>
        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <version>3.8.1</version>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>javax.servlet</groupId>
            <artifactId>servlet-api</artifactId>
            <version>2.4</version>
            <scope>provided</scope>
        </dependency>
    </dependencies>
    ...
</project>
----

The first dependency is a compile dependency on the XFire SOAP library from Codehaus. You would use this type of dependency if your project depended on this library for compilation, testing, and during execution. The second dependency is a +test+-scoped dependency on JUnit. You would use a +test+-scoped dependency when you need to reference this library only during testing. The last dependency in <<ex-dependency>> is a dependency on the Servlet 2.4 API. The last dependency is scoped as a provided dependency. You would use a provided scope when the application you are developing needs a library for compilation and testing, but this library is supplied by a container at runtime.

[[pom-relationships-sect-dependency-scope]]
==== Dependency Scope

<<ex-dependency>> briefly introduced three of the five dependency scopes: +compile+, +test+, and +provided+. Scope controls which dependencies are available in which classpath, and which dependencies are included with an application. Let’s explore each scope in detail:

compile::

  compile+ is the default scope; all dependencies are +compile+-scoped if a scope is not supplied. +compile+ dependencies are available in all classpaths, and they are packaged. 

provided::

  provided+ dependencies are used when you expect the JDK or a container to provide them. For example, if you were developing a web application, you would need the Servlet API available on the compile classpath to compile a servlet, but you wouldn’t want to include the Servlet API in the packaged WAR; the Servlet API JAR is supplied by your application server or servlet container. +provided+ dependencies are available on the compilation classpath (not runtime). They are not transitive, nor are they packaged.

runtime::

  runtime+ dependencies are required to execute and test the system, but they are not required for compilation. For example, you may need a JDBC API JAR at compile time and the JDBC driver implementation only at runtime.

test::

  test+-scoped dependencies are not required during the normal operation of an application, and they are available only during test compilation and execution phases.

system::

  The +system+ scope is similar to +provided+ except that you have to provide an explicit path to the JAR on the local file system. This is intended to allow compilation against native objects that may be part of the system libraries. The artifact is assumed to always be available and is not looked up in a repository. If you declare the scope to be +system+, you must also provide the +systemPath+ element. Note that this scope is not recommended (you should always try to reference dependencies in a public or custom Maven repository).

[[pom-relationships-sect-optional]]
==== Optional Dependencies

Assume that you are working on a library that provides caching behavior. Instead of writing a caching system from scratch, you want to use some of the existing libraries that provide caching on the file system and distributed caches. Also assume that you want to give the end user an option to cache on the file system or to use an in-memory distributed cache. To cache on the file system, you’ll want to use a freely available library called EHCache (http://ehcache.sourceforge.net/[http://ehcache.sourceforge.net/]), and to cache in a distributed in-memory cache, you want to use another freely available caching library named SwarmCache ( http://swarmcache.sourceforge.net/[http://swarmcache.sourceforge.net/] ). You’ll code an interface and create a library that can be configured to use either EHCache or SwarmCache, but you want to avoid adding a dependency on both caching libraries to any project that depends on your library.

In other words, you need both libraries to compile this library project, but you don't want both libraries to show up as transitive runtime dependencies for the project that uses your library. You can accomplish this by using optional dependencies as shown in <<ex-optional-depend>>.

[[ex-optional-depend]]
.Declaring Optional Dependencies
----
<project>
    <modelVersion>4.0.0</modelVersion>
    <groupId>org.sonatype.mavenbook</groupId>
    <artifactId>my-project</artifactId>
    <version>1.0.0</version>
    <dependencies>
        <dependency>
            <groupId>net.sf.ehcache</groupId>
            <artifactId>ehcache</artifactId>
            <version>1.4.1</version>
            <optional>true</optional>
        </dependency>
        <dependency>
            <groupId>swarmcache</groupId>
            <artifactId>swarmcache</artifactId>
            <version>1.0RC2</version>
            <optional>true</optional>
        </dependency>
        <dependency>
            <groupId>log4j</groupId>
            <artifactId>log4j</artifactId>
            <version>1.2.13</version>
        </dependency>
    </dependencies>
</project>
----

Since you've declared these dependencies as optional in +my-project+, if you've defined a project that depends on +my-project+ which needs those dependencies, you'll have to include them explicitly in the project that depends on +my-project+. For example, if you were writing an application which depended on +my-project+ and wanted to use the EHCache implementation, you would need to add the following +dependency+ element to your project.

----
<project>
    <modelVersion>4.0.0</modelVersion>
    <groupId>org.sonatype.mavenbook</groupId>
    <artifactId>my-application</artifactId>
    <version>1.0.0</version>
    <dependencies>
        <dependency>
            <groupId>org.sonatype.mavenbook</groupId>
            <artifactId>my-project</artifactId>
            <version>1.0.0</version>
        </dependency>
        <dependency>
            <groupId>net.sf.ehcache</groupId>
            <artifactId>swarmcache</artifactId>
            <version>1.4.1</version>
        </dependency>
    </dependencies>
</project>
----

In an ideal world, you wouldn’t have to use optional dependencies. Instead of having one large project with a series of optional dependencies, you would separate the EHCache-specific code to a +my-project-ehcache+ submodule and the SwarmCache-specific code to a +my-project-swarmcache+ submodule. This way, instead of requiring projects that reference +my-project+ to specifically add a dependency, projects can just reference a particular implementation project and benefit from the transitive dependency. 

[[pom-relationships-sect-version-ranges]]
==== Dependency Version Ranges

 dependency; you can specify a range of versions that would satisfy a given dependency. For example, you can specify that your project depends on version 3.8 or greater of JUnit, or anything between versions 1.2.10 and 1.2.14 of JUnit. You do this by surrounding one or more version numbers with the following characters:

(, )::

  Exclusive quantifiers

[, ]::

  Inclusive quantifiers

For example, if you wished to access any +JUnit+ version greater than or equal to 3.8 but less than 4.0, your dependency would be as shown in <<ex-dep-range>>.

[[ex-dep-range]]
.Specifying a Dependency Range: JUnit 3.8 - JUnit 4.0
----
<dependency>
    <groupId>junit</groupId>
    <artifactId>junit</artifactId>
    <version>[3.8,4.0)</version>
    <scope>test</scope>
</dependency>
----

If you want to depend on any version of JUnit no higher than 3.8.1, you would specify only an upper inclusive boundary, as shown in <<ex-dep-range-2>>.


[[ex-dep-range-2]]
.Specifying a Dependency Range: JUnit <= 3.8.1
----
<dependency>
    <groupId>junit</groupId>
    <artifactId>junit</artifactId>
    <version>[,3.8.1]</version>
    <scope>test</scope>
</dependency>
----



A version before or after the comma is not required, and means +/- infinity. For example, "[4.0,)" means any version greater than or equal to 4.0. "(,2.0)" is any version less than 2.0. "[1.2]" means only version 1.2, and nothing else.

NOTE: When declaring a "normal" version such as 3.8.2 for Junit, internally this is represented as "allow anything, but prefer 3.8.2." This means that when a conflict is detected, Maven is allowed to use the conflict algorithms to choose the best version. If you specify [3.8.2], it means that only 3.8.2 will be used and nothing else. If somewhere else there is a dependency that specifies [3.8.1], you would get a build failure telling you of the conflict. We point this out to make you aware of the option, but use it sparingly and only when really needed. The preferred way to resolve this is via +dependencyManagement+.  

[[pom-relationships-sect-transitive]]
==== Transitive Dependencies

+project-a+ depends on +project-b+, which in turn depends on +project-c+, then +project-c+ is considered a transitive dependency of +project-a+. If +project-c+ depended on +project-d+, then +project-d+ would also be considered a transitive dependency of +project-a+. Part of Maven’s appeal is that it can manage transitive dependencies and shield the developer from having to keep track of all of the dependencies required to compile and run an application. You can just depend on something like the Spring Framework and not have to worry about tracking down every last dependency of the Spring Framework.

Maven accomplishes this by building a graph of dependencies and dealing with any conflicts and overlaps that might occur. For example, if Maven sees that two projects depend on the same +groupId+ and +artifactId+, it will sort out which dependency to use automatically, always favoring the more recent version of a dependency. Although this sounds convenient, there are some edge cases where transitive dependencies can cause some configuration issues. For these scenarios, you can use a dependency exclusion.

[[pom-relationships-sect-transitive-scope]]
===== Transitive Dependencies and Scope

Each of the scopes outlined earlier in the section <<pom-relationships-sect-dependency-scope>> affects not just the scope of the dependency in the declaring project, but also how it acts as a transitive dependency. The easiest way to convey this information is through a table, as in <<table-transitive-dep-and-scope>>. Scopes in the top row represent the scope of a transitive dependency. Scopes in the leftmost column represent the scope of a direct dependency. The intersection of the row and column is the scope that is assigned to a transitive dependency. A blank cell in this table means that the transitive dependency will be omitted.

[[table-transitive-dep-and-scope]]
.How Scope Affects Transitive Dependencies
[options="header"]
|==========================
| Direct Scope 4+| vs. Transitive Scope
|  | compile  | provided | runtime  | test
| compile  | compile  | -| runtime  | -
| provided | provided | provided | provided | -
| runtime  | runtime  | -| runtime  | -
| test | test | -| test | -
|==========================

To illustrate the relationship of transitive dependency scope to direct dependency scope, consider the following example. If +project-a+ contains a test scoped dependency on +project-b+ which contains a compile scoped dependency on +project-c+. +project-c+ would be a test-scoped transitive dependency of +project-a+.

You can think of this as a transitive boundary which acts as a filter on dependency scope. Transitive dependencies which are provided and test scope usually do not affect a project. The exception to this rule is that a provided scoped transitive dependency to a provided scope direct dependency is still a provided dependency of a project. Transitive dependencies which are compile and runtime scoped usually affect a project regardless of the scope of a direct dependency. Transitive dependencies which are compile scoped will have the same scope regardless of the scope of the direct dependency. Transitive dependencies which are runtime scoped will generally have the same scope of the direct dependency except when the direct dependency has a scope of compile. When a transitive dependency is runtime scoped and a direct is compile scoped the direct dependency the transitive dependency will have an effective scope of runtime.  

[[pom-relationships-sect-conflict]]
==== Conflict Resolution

There will be times when you need to exclude a transitive dependency, such as when you are depending on a project that depends on another project, but you would like to either exclude the dependency altogether or replace the transitive dependency with another dependency that provides the same functionality. <<ex-exclude>> shows an example of a dependency element that adds a dependency on +project-a+, but excludes the transitive dependency +project-b+.

[[ex-exclude]]
.Excluding a Transitive Dependency
----
<dependency>
    <groupId>org.sonatype.mavenbook</groupId>
    <artifactId>project-a</artifactId>
    <version>1.0</version>
    <exclusions>
        <exclusion>
            <groupId>org.sonatype.mavenbook</groupId>
            <artifactId>project-b</artifactId>
        </exclusion>
    </exclusions>
</dependency>
----

Often, you will want to replace a transitive dependency with another implementation. For example, if you are depending on a library that depends on the Sun JTA API, you may want to replace the declared transitive dependency. Hibernate is one example. Hibernate depends on the Sun JTA API JAR, which is not available in the central Maven repository because it cannot be freely redistributed. Fortunately, the Apache Geronimo project has created an independent implementation of this library that can be freely redistributed. To replace a transitive dependency with another dependency, you would exclude the transitive dependency and declare a dependency on the project you wanted instead. <<ex-exclude-replace>> shows an example of a such replacement.

[[ex-exclude-replace]]
.Excluding and Replacing a Transitive Dependency
----
<dependencies>
    <dependency>
        <groupId>org.hibernate</groupId>
        <artifactId>hibernate</artifactId>
        <version>3.2.5.ga</version>
        <exclusions>
            <exclusion>
                <groupId>javax.transaction</groupId>
                <artifactId>jta</artifactId>
            </exclusion>
        </exclusions>
    </dependency>
    <dependency>
        <groupId>org.apache.geronimo.specs</groupId>
        <artifactId>geronimo-jta_1.1_spec</artifactId>
        <version>1.1</version>
    </dependency>
</dependencies>
----

In <<ex-exclude-replace>>, there is nothing marking the dependency on +geronimo-jta_1.1_spec+ as a replacement, it just happens to be a library which provides the same API as the original JTA dependency. Here are some other reasons you might want to exclude or replace transitive dependencies:


. The +groupId+ or +artifactId+ of the artifact has changed, where the current project requires an alternately named version from a dependency's version - resulting in 2 copies of the same project in the classpath. Normally Maven would capture this conflict and use a single version of the project, but when +groupId+ or +artifactId+ are different, Maven will consider this to be two different libraries. 

. An artifact is not used in your project and the transitive dependency has not been marked as an optional dependency. In this case, you might want to exclude a dependency because it isn't something your system needs and you are trying to cut down on the number of libraries distributed with an application. 

. An artifact which is provided by your runtime container thus should not be included with your build. An example of this is if a dependency depends on something like the Servlet API and you want to make sure that the dependency is not included in a web application's 'WEB-INF/lib' directory. 

. To exclude a dependency which might be an API with multiple implementations. This is the situation illustrated by <<ex-exclude-replace>>; there is a Sun API which requires click-wrap licensing and a time-consuming manual install into a custom repository (Sun's JTA JAR) versus a freely distributed version of the same API available in the central Maven repository (Geronimo's JTA implementation).

[[pom-relationships-sect-dep-manage]]
==== Dependency Management

Once you've adopted Maven at your super complex enterprise and you have two hundred and twenty inter-related Maven projects, you are going to start wondering if there is a better way to get a handle on dependency versions. If every single project that uses a dependency like the MySQL Java connector needs to independently list the version number of the dependency, you are going to run into problems when you need to upgrade to a new version. Because the version numbers are distributed throughout your project tree, you are going to have to manually edit each of the 'pom.xml' files that reference a dependency to make sure that you are changing the version number everywhere. Even with +find+, +xargs+, and +awk+, you are still running the risk of missing a single POM.

Luckily, Maven provides a way for you to consolidate dependency version numbers in the +dependencyManagement+ element. You'll usually see the +dependencyManagement+ element in a top-level parent POM for an organization or project. Using the +dependencyManagement+ element in a 'pom.xml' allows you to reference a dependency in a child project without having to explicitly list the version. Maven will walk up the parent-child hierarchy until it finds a project with a +dependencyManagement+ element, it will then use the version specified in this +dependencyManagement+ element.

For example, if you have a large set of projects which make use of the MySQL Java connector version 5.1.2, you could define the following +dependencyManagement+ element in your multi-module project's top-level POM.

.Defining Dependency Versions in a Top-level POM
----
<project>
    <modelVersion>4.0.0</modelVersion>
    <groupId>org.sonatype.mavenbook</groupId>
    <artifactId>a-parent</artifactId>
    <version>1.0.0</version>
    ...
    <dependencyManagement>
        <dependencies>
            <dependency>
                <groupId>mysql</groupId>
                <artifactId>mysql-connector-java</artifactId>
                <version>5.1.2</version>
                <scope>runtime</scope>
            </dependency>
            ...
            <dependencies>
    </dependencyManagement>
----

Then, in a child project, you can add a dependency to the MySQL Java Connector using the following dependency XML:

----
<project>
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.sonatype.mavenbook</groupId>
        <artifactId>a-parent</artifactId>
        <version>1.0.0</version>
    </parent>
    <artifactId>project-a</artifactId>
    ...
    <dependencies>
        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
        </dependency>
    </dependencies>
</project>
----

You should notice that the child project did not have to explicitly list the version of the +mysql-connector-java+ dependency. Because this dependency was defined in the top-level POM's +dependencyManagement+ element, the version number is going to propagate to the child project's dependency on +mysql-connector-java+. Note that if this child project did define a version, it would override the version listed in the top-level POM's +dependencyManagement+ section. That is, the +dependencyManagement+ version is only used when the child does not declare a version directly.

Dependency management in a top-level POM is different from just defining a dependency on a widely shared parent POM. For starters, all dependencies are inherited. If +mysql-connector-java+ were listed as a dependency of the top-level parent project, every single project in the hierarchy would have a reference to this dependency. Instead of adding in unnecessary dependencies, using +dependencyManagement+ allows you to consolidate and centralize the management of dependency versions without adding dependencies which are inherited by all children. In other words, the +dependencyManagement+ element is equivalent to an environment variable which allows you to declare a dependency anywhere below a project without specifying a version number.   

[[pom-relationships-sect-project-relationships]]
=== Project Relationships

One of the compelling reasons to use Maven is that it makes the process of tracking down dependencies (and dependencies of dependencies) very easy. When a project depends on an artifact produced by another project we say that this artifact is a dependency. In the case of a Java project, this can be as simple as a project depending on an external dependency like Log4J or JUnit. While dependencies can model external dependencies, they can also manage the dependencies between a set of related projects. If +project-a+ depends on +project-b+, Maven is smart enough to know that +project-b+ must be built before +project-a+.

Relationships are not only about dependencies and figuring out what one project needs to be able to build an artifact. Maven can model the relationship of a project to a parent, and the relationship of a project to submodules. This section gives an overview of the various relationships between projects and how such relationships are configured.

[[pom-relationships-sect-more-coordinates]]
==== More on Coordinates

Coordinates define a unique location for a project. Projects are related to one another using Maven Coordinates. +project-a+ doesn't just depend on +project-b+; a project with a +groupId+, +artifactId+, and +version+ depends on another project with a +groupId+, +artifactId+, and +version+. To review, a Maven Coordinate is made up of three components:

groupId::

   A +groupId+ groups a set of related artifacts. Group identifiers generally resemble a Java package name. For example, the +groupId+ +org.apache.maven+ is the base groupId for all artifacts produced by the Apache Maven project. Group identifiers are translated into paths in the Maven Repository; for example, the org.apache.maven groupId can be found in '/maven2/org/apache/maven' on http://repo1.maven.org/maven2/org/apache/maven[repo1.maven.org]. 

artifactId::

   The +artifactId+ is the project's main identifier. When you generate an artifact, this artifact is going to be named with the +artifactId+. When you refer to a project, you are going to refer to it using the +artifactId+. The +artifactId+, +groupId+ combination must be unique. In other words, you can't have two separate projects with the same +artifactId+ and +groupId+; +artifactId+s are unique within a particular +groupId+.

NOTE: While '.'s are commonly used in +groupId+s, you should try to avoid using them in +artifactId+s. This can cause issues when trying to parse a fully qualified name down into the subcomponents.   

version::

   When an artifact is released, it is released with a version number. This version number is a numeric identifier such as "1.0", "1.1.1", or "1.1.2-alpha-01". You can also use what is known as a snapshot version. A snapshot version is a version for a component which is under development, snapshot version numbers always end in SNAPSHOT; for example, "1.0-SNAPSHOT", "1.1.1-SNAPSHOT", and "1-SNAPSHOT". <<pom-relationships-sect-version-build-numbers>> introduces versions and version ranges.   

There is a fourth, less-used qualifier:

classifier::

   You would use a classifier if you were releasing the same code but needed to produce two separate artifacts for technical reasons. For example, if you wanted to build two separate artifacts of a JAR, one compiled with the Java 1.4 compiler and another compiled with the Java 6 compiler, you might use the classifier to produce two separate JAR artifacts under the same groupId:artifactId:version combination. If your project uses native extensions, you might use the classifier to produce an artifact for each target platform. Classifiers are commonly used to package up an artifact's sources, JavaDocs or binary assemblies.   

When we talk of dependencies in this book, we often use the following shorthand notation to describe a dependency: +groupId+:+artifactId+:+version+. To refer to the 2.5 release of the Spring Framework, we would refer to it as +org.springframework:spring:2.5+. When you ask Maven to print out a list of dependencies with the Maven Dependency plugin, you will also see that Maven tends to print out log messages with this shorthand dependency notation. 

[[pom-relationships-sect-project-inheritance]]
==== Project Inheritance

There are going to be times when you want a project to inherit values from a parent POM. You might be building a large system, and you don't want to have to repeat the same dependency elements over and over again. You can avoid repeating yourself if your projects make use of inheritance via the parent element. When a project specifies a parent, it inherits the information in the parent project's POM. It can then override and add to the values specified in this parent POM.

All Maven POMs inherit values from a parent POM. If a POM does not specify a direct parent using the +parent+ element, that POM will inherit values from the Super POM. <<ex-inheritance>> shows the +parent+ element of +project-a+ which inherits the POM defined by the +a-parent+ project.

[[ex-inheritance]]
.Project Inheritance
----
<project>
    <parent>
        <groupId>com.training.killerapp</groupId>
        <artifactId>a-parent</artifactId>
        <version>1.0-SNAPSHOT</version>
    </parent>
    <artifactId>project-a</artifactId>
    ...
</project>
----

Running +mvn help:effective-pom+ in +project-a+ would show a POM that is the result of merging the Super POM with the POM defined by +a-parent+ and the POM defined in +project-a+. The implicit and explicit inheritance relationships for +project-a+ are shown in <<fig-inheritance>>.

[[fig-inheritance]]
.Project Inheritance for a-parent and project-a
image::figs/web/pom_inheritance.png[]

When a project specifies a parent project, Maven uses that parent POM as a starting point before it reads the current project's POM. It inherits everything, including the +groupId+ and +version+ number. You'll notice that +project-a+ does not specify either, both +groupId+ and +version+ are inherited from +a-parent+. With a parent element, all a POM really needs to define is an +artifactId+. This isn't mandatory, +project-a+ could have a different +groupId+ and +version+, but by not providing values, Maven will use the values specified in the parent POM. If you start using Maven to manage and build large multi-module projects, you will often be creating many projects which share a common +groupId+ and +version+.

When you inherit a POM, you can choose to live with the inherited POM information or to selectively override it. The following is a list of items a Maven POM inherits from its parent POM:

* identifiers (at least one of +groupId+ or +artifactId+ must be overridden.) 

* dependencies

* developers and contributors 

* plugin lists 

* reports lists 

* plugin executions (executions with matching ids are merged) 

* plugin configuration  

When Maven inherits dependencies, it will add dependencies of child projects to the dependencies defined in parent projects. You can use this feature of Maven to specify widely used dependencies across all projects which inherit from a top-level POM. For example, if your system makes universal use of the Log4J logging framework, you can list this dependency in your top-level POM. Any projects which inherit POM information from this project will automatically have Log4J as a dependency. Similarly, if you need to make sure that every project is using the same version of a Maven plugin, you can list this Maven plugin version explicitly in a top-level parent POM's +pluginManagement+ section.

Maven assumes that the parent POM is available from the local repository, or available in the parent directory ('../pom.xml') of the current project. If neither location is valid this default behavior may be overridden via the +relativePath+ element. For example, some organizations prefer a flat project structure where a parent project's 'pom.xml' isn't in the parent directory of a child project. It might be in a sibling directory to the project. If your child project were in a directory './project-a' and the parent project were in a directory named './a-parent', you could specify the relative location of +parent-a+'s POM with the following configuration:

----
<project>
    <parent>
        <groupId>org.sonatype.mavenbook</groupId>
        <artifactId>a-parent</artifactId>
        <version>1.0-SNAPSHOT</version>
        <relativePath>../a-parent/pom.xml</relativePath>
    </parent>
    <artifactId>project-a</artifactId>
</project>
----

[[pom-relationships-sect-pom-best-practice]]
=== POM Best Practices

Maven can be used to manage everything from simple, single-project systems to builds that involve hundreds of inter-related submodules. Part of the learning process with Maven isn't just figuring out the syntax for configuring Maven, it is learning the "Maven Way"—the current set of best practices for organizing and building projects using Maven. This section attempts to distill some of this knowledge to help you adopt best practices from the start without having to wade through years of discussions on the Maven mailing lists.

[[pom-relationships-sect-grouping-deps]]
==== Grouping Dependencies

If you have a set of dependencies which are logically grouped together. You can create a project with pom packaging that groups dependencies together. For example, let's assume that your application uses Hibernate, a popular Object-Relational mapping framework. Every project which uses Hibernate might also have a dependency on the Spring Framework and a MySQL JDBC driver. Instead of having to include these dependencies in every project that uses Hibernate, Spring, and MySQL you could create a special POM that does nothing more than declare a set of common dependencies. You could create a project called +persistence-deps+ (short for Persistence Dependencies), and have every project that needs to do persistence depend on this convenience project:

.Consolidating Dependencies in a Single POM Project
----
<project>
    <groupId>org.sonatype.mavenbook</groupId>
    <artifactId>persistence-deps</artifactId>
    <version>1.0</version>
    <packaging>pom</packaging>
    <dependencies>
        <dependency>
            <groupId>org.hibernate</groupId>
            <artifactId>hibernate</artifactId>
            <version>${hibernateVersion}</version>
        </dependency>
        <dependency>
            <groupId>org.hibernate</groupId>
            <artifactId>hibernate-annotations</artifactId>
            <version>${hibernateAnnotationsVersion}</version>
        </dependency>
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-hibernate3</artifactId>
            <version>${springVersion}</version>
        </dependency>
        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
            <version>${mysqlVersion}</version>
        </dependency>
    </dependencies>
    <properties>
        <mysqlVersion>(5.1,)</mysqlVersion>
        <springVersion>(2.0.6,)</springVersion>
        <hibernateVersion>3.2.5.ga</hibernateVersion>
        <hibernateAnnotationsVersion>3.3.0.ga</hibernateAnnotationsVersion>
    </properties>
</project>
----

If you create this project in a directory named +persistence-deps+, all you need to do is create this 'pom.xml' and run +mvn install+. Since the packaging type is +pom+, this POM is installed in your local repository. You can now add this project as a dependency and all of its dependencies will be added as transitive dependencies to your project. When you declare a dependency on this persistence-deps project, don't forget to specify the dependency type as pom.

.Declaring a Dependency on a POM
----
<project>
    <description>This is a project requiring JDBC</description>
    ...
    <dependencies>
        ...
        <dependency>
            <groupId>org.sonatype.mavenbook</groupId>
            <artifactId>persistence-deps</artifactId>
            <version>1.0</version>
            <type>pom</type>
        </dependency>
    </dependencies>
</project>
----

If you later decide to switch to a different JDBC driver (for example, JTDS), just replace the dependencies in the +persistence-deps+ project to use +net.++sourceforge.jtds:jtds+ instead of +mysql:mysql-java-connector+ and update the version number. All projects depending on +persistence-deps+ will use JTDS if they decide to update to the newer version. Consolidating related dependencies is a good way to cut down on the length of 'pom.xml' files that start having to depend on a large number of dependencies. If you need to share a large number of dependencies between projects, you could also just establish parent-child relationships between projects and refactor all common dependencies to the parent project, but the disadvantage of the parent-child approach is that a project can have only one parent. Sometimes it makes more sense to group similar dependencies together and reference a +pom+ dependency. This way, your project can reference as many of these consolidated dependency POMs as it needs.

NOTE: Maven uses the depth of a dependency in the tree when resolving conflicts using a nearest-wins approach. Using the dependency grouping technique above pushes those dependencies one level down in the tree. Keep this in mind when choosing between grouping in a pom or using +dependencyManagement+ in a parent POM

[[pom-relationships-sect-multi-vs-inherit]]
==== Multi-module vs. Inheritance

There is a difference between inheriting from a parent project and being managed by a multimodule project. A parent project is one that passes its values to its children. A multimodule project simply manages a group of other subprojects or modules. The multimodule relationship is defined from the topmost level downwards. When setting up a multimodule project, you are simply telling a project that its build should include the specified modules. Multimodule builds are to be used to group modules together in a single build. The parent-child relationship is defined from the leaf node upwards. The parent-child relationship deals more with the definition of a particular project. When you associate a child with its parent, you are telling Maven that a project’s POM is derived from another.

To illustrate the decision process that goes into choosing a design that uses inheritance vs. multi-module or both approaches consider the following two examples: the Maven project used to generate this book and a hypothetical project that contains a number of logically grouped modules.

[[pom-relationships-sect-simple-project]]
===== Simple Project

First, let's take a look at the maven-book project. The inheritance and multi-module relationships are shown in <<fig-maven-book>>.

[[fig-maven-book]]
.maven-book Multi-module vs. Inheritance
image::figs/web/pom_book-example.png[]

When we build this Maven book you are reading, we run +mvn package+ in a multi-module project named +maven-book+. This multi-module project includes two submodules: +book-examples+ and +book-chapters+. Neither of these projects share the same parent, they are related only in that they are modules in the +maven-book+ project. +book-examples+ builds the ZIP and TGZ archives you downloaded to get this book's example. When we run the +book-examples+ build from 'book-examples/' directory with +mvn package+, it has no knowledge that it is a part of the larger +maven-book+ project. +book-examples+ doesn't really care about +maven-book+, all it knows in life is that its parent is the top-most +sonatype+ POM and that it creates an archive of examples. In this case, the +maven-book+ project exists only as a convenience and as an aggregator of modules.

Each of the three projects: +maven-book+, +book-examples+, and +book-chapters+ all list a shared "corporate" parent — +sonatype+. This is a common practice in organizations which have adopted Maven, instead of having every project extend the Super POM by default, some organizations define a top-level corporate POM that serves as the default parent when a project doesn't have any good reason to depend on another. In this book example, there is no compelling reason to have +book-examples+ and +book-chapters+ share the same parent POM, they are entirely different projects which have a different set of dependencies, a different build configuration, and use drastically different plugins to create the content you are now reading. The +sonatype+ POM gives the organization a chance to customize the default behavior of Maven and supply some organization-specific information to configure deployment settings and build profiles.

[[pom-relationships-sect-multi-module-enterprise]]
===== Multi-module Enterprise Project

Let's take a look at an example that provides a more accurate picture of a real-world project where inheritance and multi-module relationships exist side by side. <<fig-multi-module>> shows a collection of projects that resemble a typical set of projects in an enterprise application. There is a top-level POM for the corporation with an +artifactId+ of +sonatype+. There is a multi-module project named +big-system+ which references sub-modules +server-side+ and +client-side+.

[[fig-multi-module]]
.Enterprise Multi-module vs. Inheritance
image::figs/web/pom_real_multi.png[]

What's going on here? Let's try to deconstruct this confusing set of arrows. First, let's take a look at +big-system+. The +big-system+ might be the project that you would run +mvn package+ on to build and test the entire system. +big-system+ references submodules +client-side+ and +server-side+. Each of these projects effectively rolls up all of the code that runs on either the server or on the client. Let's focus on the +server-side+ project. Under the +server-side+ project we have a project called +server-lib+ and a multi-module project named +web-apps+. Under +web-apps+ we have two Java web applications: +client-web+ and +admin-web+.

Let's start with the parent/child relationships from +client-web+ and +admin-web+ to +web-apps+. Since both of the web applications are implemented in the same web application framework (let's say Wicket), both projects would share the same set of core dependencies. The dependencies on the Servlet API, the JSP API, and Wicket would all be captured in the +web-apps+ project. Both +client-web+ and +admin-web+ also need to depend on +server-lib+, this dependency would be defined as a dependency between +web-apps+ and +server-lib+. Because +client-web+ and +admin-web+ share so much configuration by inheriting from +web-apps+, both +client-web+ and +admin-web+ will have very small POMs containing little more than identifiers, a parent declaration, and a final build name.

Next we focus on the parent/child relationship from +web-apps+ and +server-lib+ to +server-side+. In this case, let's just assume that there is a separate working group of developers which work on the server-side code and another group of developers that work on the client-side code. The list of developers would be configured in the +server-side+ POM and inherited by all of the child projects underneath it: +web-apps+, +server-lib+, +client-web+, and +admin-web+. We could also imagine that the +server-side+ project might have different build and deployment settings which are unique to the development for the server side. The +server-side+ project might define a build profile that only makes sense for all of the +server-side+ projects. This build profile might contain the database host and credentials, or the +server-side+ project's POM might configure a specific version of the Maven Jetty plugin which should be universal across all projects that inherit the +server-side+ POM.

In this example, the main reason to use parent/child relationships is shared dependencies and common configuration for a group of projects which are logically related. All of the projects below +big-system+ are related to one another as submodules, but not all submodules are configured to point back to parent project that included it as a submodule. Everything is a submodule for reasons of convenience, to build the entire system just go to the +big-system+ project directory and run +mvn package+. Look more closely at the figure and you'll see that there is no parent/child relationship between +server-side+ and +big-system+. Why is this? POM inheritance is very powerful, but it can be overused. When it makes sense to share dependencies and build configuration, a parent/child relationship should be used. When it doesn't make sense is when there are distinct differences between two projects. Take, for example, the +server-side+ and +client-side+ projects. It is possible to create a system where +client-side+ and +server-side+ inherited a common POM from +big-system+, but as soon as a significant divergence between the two child projects develops, you then have to figure out creative ways to factor out common build configuration to +big-system+ without affecting all of the children. Even though +client-side+ and +server-side+ might both depend on Log4J, they also might have distinct plugin configurations.

There's a certain point defined more by style and experience where you decide that minimal duplication of configuration is a small price to pay for allowing projects like +client-side+ and +server-side+ to remain completely independent. Designing a huge set of thirty plus projects which all inherit five levels of POM configuration isn't always the best idea. In such a setup, you might not have to duplicate your Log4J dependency more than once, but you'll also end up having to wade through five levels of POM just figure out how Maven calculated your effective POM. All of this complexity to avoid duplicating five lines of dependency declaration. In Maven, there is a "Maven Way", but there are also many ways to accomplish the same thing. It all boils down to preference and style. For the most part, you won't go wrong if all of your submodules turn out to define back-references to the same project as a parent, but your use of Maven may evolve over time.

[[lifecycle]]
== The Build Lifecycle

[[lifecycle-sect-structure]]
=== Introduction

Maven models projects as nouns which are described by a POM. The POM captures the identity of a project: What does a project contain? What type of packaging a project needs? Does the project have a parent? What are the dependencies? We've explored the idea of describing a project in the previous chapters, but we haven't introduced the mechanism that allows Maven to act upon these objects. In Maven the "verbs" are goals packaged in Maven plugins which are tied to a phases in a build lifecycle. A Maven lifecycle consists of a sequence of named phases: prepare-resources, compile, package, and install among other. There is phase that captures compilation and a phase that captures packaging. There are pre- and post- phases which can be used to register goals which must run prior to compilation, or tasks which must be run after a particular phase. When you tell Maven to build a project, you are telling Maven to step through a defined sequence of phases and execute any goals which may have been registered with each phase.

A build lifecycle is an organized sequence of phases that exist to give order to a set of goals. Those goals are chosen and bound by the packaging type of the project being acted upon. There are three standard lifecycles in Maven: clean, default (sometimes called build) and site. In this chapter, you are going to learn how Maven ties goals to lifecycle phases and how the lifecycle can be customized. You will also learn about the default lifecycle phases.

[[lifecycle-sect-clean]]
==== Clean Lifecycle (clean)

The first lifecycle you'll be interested in is the simplest lifecycle in Maven. Running +mvn clean+ invokes the clean lifecycle which consists of three lifecycle phases:

* +pre-clean+
* +clean+
* +post-clean+

The interesting phase in the clean lifecycle is the +clean+ phase. The Clean plugin's clean goal (+clean:clean+) is bound to the +clean+ phase in the +clean+ lifecycle. The +clean:clean+ goal deletes the output of a build by deleting the build directory. If you haven't customized the location of the build directory it will be the '+++${basedir}/target+++' directory as defined by the Super POM. When you execute the +clean:clean+ goal you do not do so by executing the goal directly with +mvn clean:clean+, you do so by executing the +clean+ phase of the clean lifecycle. Executing the +clean+ phase gives Maven an opportunity to execute any other goals which may be bound to the +pre-clean+ phase.

For example, suppose you wanted to trigger an +antrun:run+ goal task to echo a notification on +pre-clean+, or to make an archive of a project's build directory before it is deleted. Simply running the +clean:clean+ goal will not execute the lifecycle at all, but specifying the +clean+ phase will use the +clean+ lifecycle and advance through the three lifecycle phases until it reaches the +clean+ phase. <<ex-trigger-pre-clean>> shows an example of build configuration which binds the +antrun:run+ goal to the +pre-clean+ phase to echo an alert that the project artifact is about to be deleted. In this example, the +antrun:run+ goal is being used to execute some arbitrary Ant commands to check for an existing project artifact. If the project's artifact is about to be deleted it will print this to the screen

[[ex-trigger-pre-clean]]
.Triggering a Goal on pre-clean
----
<project>
    ...
    <build>
        <plugins>... <plugin>
                <artifactId>maven-antrun-plugin</artifactId>
                <executions>
                    <execution>
                        <id>file-exists</id>
                        <phase>pre-clean</phase>
                        <goals>
                            <goal>run</goal>
                        </goals>
                        <configuration>
                            <tasks>
                                <!-- adds the ant-contrib tasks (if/then/else used below) -->
                                <taskdef resource="net/sf/antcontrib/antcontrib.properties" />
                                <available 
                                     file="${project.build.directory}/${project.build.finalName}.${project.packaging}"
                                     property="file.exists" value="true" />

                                <if>
                                    <not>
                                        <isset property="file.exists" />
                                    </not>
                                    <then>
                                        <echo>No
                                            ${project.build.finalName}.${project.packaging} to
                                            delete</echo>
                                    </then>
                                    <else>
                                        <echo>Deleting
                                            ${project.build.finalName}.${project.packaging}</echo>
                                    </else>
                                </if>
                            </tasks>
                        </configuration>
                    </execution>
                </executions>
                <dependencies>
                    <dependency>
                        <groupId>ant-contrib</groupId>
                        <artifactId>ant-contrib</artifactId>
                        <version>1.0b2</version>
                    </dependency>
                </dependencies>
            </plugin>
        </plugins>
    </build> 
</project>
----

Running +mvn clean+ on a project with this build configuration will produce output similar to the following:

----
[INFO] Scanning for projects...
[INFO] ----------------------------------------------------------------------
[INFO] Building Your Project
[INFO]task-segment: [clean]
[INFO] ----------------------------------------------------------------------
[INFO] [antrun:run {execution: file-exists}]
[INFO] Executing tasks
[echo] Deleting your-project-1.0-SNAPSHOT.jar
[INFO] Executed tasks
[INFO] [clean:clean]
[INFO] Deleting directory ~/corp/your-project/target
[INFO] Deleting directory ~/corp/your-project/target/classes
[INFO] Deleting directory ~/corp/your-project/target/test-classes
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESSFUL
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 1 second
[INFO] Finished at: Wed Nov 08 11:46:26 CST 2006
[INFO] Final Memory: 2M/5M
[INFO] ------------------------------------------------------------------------
----

In addition to configuring Maven to run a goal during the+ pre-clean+ phase, you can also customize the Clean plugin to delete files in addition to the build output directory. You can configure the plugin to remove specific files in a +fileSet+. The example below configures clean to remove all '.class' files in a directory named 'target-other/' using standard Ant file wildcards: \* and \**.

.Customizing Behavior of the Clean Plugin
----
<project>
    <modelVersion>4.0.0</modelVersion>
    ...
    <build>
        <plugins>
            <plugin>
                <artifactId>maven-clean-plugin</artifactId>
                <configuration>
                    <filesets>
                        <fileset>
                            <directory>target-other</directory>
                            <includes>
                                <include>*.class</include>
                            </includes>
                        </fileset>
                    </filesets>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>
----

[[lifecycle-sect-default]]
==== Default Lifecycle (default)

Most Maven users will be familiar with the default lifecycle. It is a general model of a build process for a software application. The first phase is +validate+ and the last phase is +deploy+. The phases in the default Maven lifecycle are shown in <<tbl-default-lifecycle>>.

[[tbl-default-lifecycle]]
.Maven Lifecycle Phases
[options="header"]
|======================
| Lifecycle Phase | Description 
| validate | Validate the project is correct and all necessary information is available to complete a build
| generate-sources | Generate any source code for inclusion in compilation
| process-sources | Process the source code, for example to filter any values
| generate-resources | Generate resources for inclusion in the package 
| process-resources | Copy and process the resources into the destination directory, ready for packaging
| compile | Compile the source code of the project 
| process-classes | Post-process the generated files from compilation, for example to do bytecode enhancement on Java classes
| generate-test-sources | Generate any test source code for inclusion in compilation
| process-test-sources | Process the test source code, for example to filter any values
| generate-test-resources | Create resources for testing 
| process-test-resources | Copy and process the resources into the test destination directory
| test-compile | Compile the test source code into the test destination directory
| test | Run tests using a suitable unit testing framework. These tests should not require the code be packaged or deployed
| prepare-package | Perform any operations necessary to prepare a package before the actual packaging. This often results in an unpacked, processed version of the package (coming in Maven 2.1+)
| package | Take the compiled code and package it in its distributable format, such as a JAR, WAR, or EAR
| pre-integration-test | Perform actions required before integration tests are executed. This may involve things such as setting up the required environment
| integration-test | Process and deploy the package if necessary into an environment where integration tests can be run
| post-integration-test | Perform actions required after integration tests have been executed. This may include cleaning up the environment
| verify | Run any checks to verify the package is valid and meets quality criteria
| install | Install the package into the local repository, for use as a dependency in other projects locally
| deploy | Copies the final package to the remote repository for sharing with other developers and projects (usually only relevant during a formal release)
|========================

[[lifecycle-sect-site]]
==== Site Lifecycle (site)

Maven does more than build software artifacts from project, it can also generate project documentation and reports about the project, or a collection of projects. Project documentation and site generation have a dedicated lifecycle which contains four phases:

. pre-site
. site
. post-site
. site-deploy

The default goals bound to the site lifecycle is:

. site - site:site
. site-deploy -site:deploy

The packaging type does not usually alter this lifecycle since packaging types are concerned primarily with artifact creation, not with the type of site generated. The Site plugin kicks off the execution of http://maven.apache.org/doxia/[Doxia] document generation and other report generation plugins. You can generate a site from a Maven project by running the following command:

----
$ mvn site
----

For more information about Maven Site generation, see <<site-generation>>.   

[[lifecycle-sect-package-specific]]
=== Package-specific Lifecycles

The specific goals bound to each phase default to a set of goals specific to a project's packaging. A project with packaging +jar+ has a different set of default goals from a project with a packaging of +war+. The +packaging+ element affects the steps required to build a project. For an example of how the packaging affects the build, consider two projects: one with +pom+ packaging and the other with +jar+ packaging. The project with +pom+ packaging will run the +site:attach-descriptor+ goal during the +package+ phase, and the project with +jar+ packaging will run the +jar:jar+ goal instead.

The following sections describe the lifecycle for all built-in packaging types in Maven. Use these sections to find out what default goals are mapped to default lifecycle phases.

[[lifecycle-sect-jar]]
==== JAR

JAR is the default packaging type, the most common, and thus the most commonly encountered lifecycle configuration. The default goals for the JAR lifecycle are shown in <<tbl-jar-lifecycle>>.


[[tbl-jar-lifecycle]]
.Default Goals for JAR Packaging
|===============================
| Lifecycle Phase | Goal 
| process-resources | resources:resources 
| compile | compiler:compile 
| process-test-resources | resources:testResources 
| test-compile | compiler:testCompile 
| test | surefire:test 
| package | jar:jar 
| install | install:install 
| deploy | deploy:deploy 
|===============================

[[lifecycle-sect-pom]]
==== POM

POM is the simplest packaging type. The artifact that it generates is itself only, rather than a JAR, SAR, or EAR. There is no code to test or compile, and there are no resources the process. The default goals for projects with POM packaging are shown in <<tbl-pom-lifecycle>>.

[[tbl-pom-lifecycle]]
.Default Goals for POM Packaging
|===============================
| Lifecycle Phase | Goal 
| package | site:attach-descriptor
| install | install:install
| deploy | deploy:deploy 
|=========================

[[lifecycle-sect-plugin-lifecycle]]
==== Maven Plugin

This packaging type is similar to JAR packaging type with three additions: +plugin:descriptor+, +plugin:addPluginArtifactMetadata+, and +plugin:updateRegistry+. These goals generate a descriptor file and perform some modifications to the repository data. The default goals for projects with plugin packaging are shown in <<tbl-plugin-lifecycle>>.
[[tbl-plugin-lifecycle]]
.Default Goals for Plugin Packaging
|========================
| Lifecycle Phase | Goal 
| generate-resources | plugin:descriptor
| process-resources | resources:resources
| compile | compiler:compile
| process-test-resources | resources:testResources
| test-compile | compiler:testCompile
| test | surefire:test
| package | jar:jar, plugin:addPluginArtifactMetadata
| install | install:install, plugin:updateRegistry
| deploy | deploy:deploy 
|=========================

[[lifecycle-sect-ejb]]
==== EJB

EJBs, or Enterprise Java Beans, are a common data access mechanism for model-driven development in Enterprise Java. Maven provides support for EJB 2 and 3. Though you must configure the EJB plugin to specifically package for EJB3, else the plugin defaults to 2.1 and looks for the presence of certain EJB configuration files. The default goals for projects with EJB packaging are shown in <<tbl-ejb-lifecycle>>.

[[tbl-ejb-lifecycle]]
.Default Goals for EJB Packaging
|===============================
| Lifecycle Phase | Goal 
| process-resources | resources:resources
| compile | compiler:compile
| process-test-resources | resources:testResources
| test-compile | compiler:testCompile
| test | surefire:test
| package | ejb:ejb
| install | install:install
| deploy | deploy:deploy 
|=========================  

[[lifecycle-sect-war]]
==== WAR

The WAR packaging type is similar to the JAR and EJB types. The exception being the +package+ goal of +war:war+. Note that the +war:war+ goal requires a 'web.xml' configuration in your 'src/main/webapp/WEB-INF' directory. The default goals for projects with WAR packaging are shown in <<tbl-war-lifecycle>>.

[[tbl-war-lifecycle]]
.Default Goals for WAR Packaging
|===============================
| Lifecycle Phase | Goal 
| process-resources | resources:resources
| compile | compiler:compile
| process-test-resources | resources:testResources
| test-compile | compiler:testCompile
| test | surefire:test
| package | war:war
| install | install:install
| deploy | deploy:deploy 
|===============================

[[lifecycle-sect-ear]]
==== EAR

EARs are probably the simplest Java EE constructs, consisting primarily of the deployment descriptor 'application.xml' file, some resources and some modules. The EAR plugin has a goal named +generate-application-xml+ which generates the 'application.xml' based upon the configuration in the EAR project's POM. The default goals for projects with EAR packaging are shown in <<tbl-ear-lifecycle>>.

[[tbl-ear-lifecycle]]
.Default Goals for EAR Packaging
|=========================
| Lifecycle Phase | Goal 
| generate-resources | ear:generate-application-xml
| process-resources | resources:resources
| package | ear:ear
| install | install:install
| deploy | deploy:deploy 
|=========================

[[lifecycle-sect-other-packaging]]
==== Other Packaging Types

This is not an exhaustive list of every packaging type available for Maven. There are a number of packaging formats available through external projects and plugins: the NAR (native archive) packaging type, the SWF and SWC packaging types for projects that produce Adobe Flash and Flex content, and many others. You can also define a custom packaging type and customize the default lifecycle goals to suit your own project packaging requirements.

To use one of these custom packaging types, you need two things: a plugin which defines the lifecycle for a custom packaging type and a repository which contains this plugin. Some custom packaging types are defined in plugins available from the central Maven repository. Here is an example of a project which references the Israfil Flex plugin and uses a custom packaging type of SWF to produce output from Adobe Flex source.

.Custom Packaging Type for Adobe Flex (SWF)
----
<project>
    ...
    <packaging>swf</packaging>
    ...
    <build>
        <plugins>
            <plugin>
                <groupId>net.israfil.mojo</groupId>
                <artifactId>maven-flex2-plugin</artifactId>
                <version>1.4-SNAPSHOT</version>
                <extensions>true</extensions>
                <configuration>
                    <debug>true</debug>
                    <flexHome>${flex.home}</flexHome>
                    <useNetwork>true</useNetwork>
                    <main>org/sonatype/mavenbook/Main.mxml</main>
                </configuration>
            </plugin>
        </plugins>
    </build>
    ...
</project>
----

In <<writing-plugins-sect-plugins-lifecycle>>, we show you how to create your own packaging type with a customized lifecycle. This example should give you an idea of what you'll need to do to reference a custom packaging type. All you need to do is reference the plugin which supplies the custom packaging type. The Israfil Flex plugin is a third-party Maven plugin hosted at Google Code, for more information about this plugin and how to use Maven to compile Adobe Flex go to http://code.google.com/p/israfil-mojo[http://code.google.com/p/israfil-mojo]. This plugin supplies the following lifecycle for the SWF packaging type:

.Default Lifecycle for SWF Packaging
|=========================
| Lifecycle Phase | Goal 
| compile | flex2:compile-swc
| install | install:install
| deploy | deploy:deploy 
|=========================

[[lifecycle-sect-common-goals]]
=== Common Lifecycle Goals

Many of the packaging lifecycles have similar goals. If you look at the goals bound to the WAR and JAR lifecycles, you'll see that they differ only in the +package+ phase. The +package+ phase of the WAR lifecycle calls +war:war+ and the +package+ phase of the JAR lifecycle calls +jar:jar+. Most of the lifecycles you will come into contact with share some common lifecycle goals for managing resources, running tests, and compiling source code. In this section, we'll explore some of these common lifecycle goals in detail.

[[lifecycle-sect-process-resources-phase]]
==== Process Resources

The +process-resources+ phase "processes" resources and copies them to the output directory. If you haven't customized the default directory locations defined in the Super POM, this means that Maven will copy the files from '+++${basedir}/src/main/resources+++' to '+++${basedir}/target/classes+++' or the directory defined in '+++${project.build.outputDirectory}+++'. In addition to copying the resources to the output directory, Maven can also apply a filter to the resources that allows you to replace tokens within resource file. Just like variables are referenced in a POM using '+++${...}+++' notation, you can reference variables in your project's resources using the same syntax. Coupled with build profiles, such a facility can be used to produce build artifacts which target different deployment platforms. This is something that is common in environments which need to produce output for development, testing, staging, and production platforms from the same project. For more information about build profiles, see <<profiles>>.

To illustrate resource filtering, assume that you have a project with an XML file in 'src/main/resources/META-INF/service.xml'. You want to externalize some configuration variables to a properties file. In other words, you might want to reference a JDBC URL, username, and password for your database, and you don't want to put these values directly into the 'service.xml' file. Instead, you would like to use a properties file to capture all of the configuration points for your program. Doing this will allow you to consolidate all configuration into a single properties file and make it easier to change configuration values when you need to target a new deployment environment. First, take a look at the contents of 'service.xml' in 'src/main/resources/META-INF'.

.Using Properties in Project Resources
----
<service>
    <!-- This URL was set by project version ${project.version} -->
    <url>${jdbc.url}</url>
    <user>${jdbc.username}</user>
    <password>${jdbc.password}</password>
</service>
----

This XML file uses the same property reference syntax you can use in the POM. In fact, the first variable referenced is the +project+ variable which is also an implicit variable made available in the POM. The +project+ variable provides access to POM information. The next three variable references are +jdbc.url+, +jdbc.username+, and +jdbc.password+. These custom variables are defined in a properties file 'src/main/filters/default.properties'.

.default.properties in src/main/filters
----
jdbc.url=jdbc:hsqldb:mem:mydb
jdbc.username=sa
jdbc.password=
----

To configure resource filtering with this 'default.properties' file, we need to specify two things in a project's POM: a list of properties files in the +filters+ element of the build configuration, and a flag to Maven that the resources directory is to be filtered. The default Maven behavior is to skip filtering and just copy the resources to the output directory; you'll need to explicitly configure resource filter, or Maven will skip the step altogether. This default ensures that Maven's resource filtering feature doesn't surprise you out of nowhere and clobbering any '+++${...}+++' references you didn't want it to replace.

.Filter Resources (Replacing Properties)
----
<build>
    <filters>
        <filter>src/main/filters/default.properties</filter>
    </filters>
    <resources>
        <resource>
            <directory>src/main/resources</directory>
            <filtering>true</filtering>
        </resource>
    </resources>
</build>
----

As with all directories in Maven, the resources directory does not need to be in 'src/main/resources'. This is just the default value defined in the Super POM. You should also note that you don't need to consolidate all of your resources into a single directory. You can always separate resources into separate directories under 'src/main'. Assume that you have a project which contains hundreds of XML documents and hundreds of images. Instead of mixing the resources in the 'src/main/resources' directory, you might want to create two directories 'src/main/xml' and 'src/main/images' to hold this content. To add directories to the list of resource directories, you would add the following +resource+ elements to your build configuration.

.Configuring Additional Resource Directories
----
<build>
    ...
    <resources>
        <resource>
            <directory>src/main/resources</directory>
        </resource>
        <resource>
            <directory>src/main/xml</directory>
        </resource>
        <resource>
            <directory>src/main/images</directory>
        </resource>
    </resources>
    ...
</build>
----



When you are building a project that produces a console application or a command-line tool, you'll often find yourself writing simple shell scripts that need to reference the JAR produced by a build. When you are using the assembly plugin to produce a distribution for an application as a ZIP or TAR, you might place all of your scripts in a directory like 'src/main/command'. In the following POM resource configuration, you'll see how we can use resource filtering and a reference to the project variable to capture the final output name of the JAR. For more information about the Maven Assembly plugin, see <<assemblies>>.

[[ex-filter-script]]
.Filtering Script Resources
----
<build>
    <groupId>org.sonatype.mavenbook</groupId>
    <artifactId>simple-cmd</artifactId>
    <version>2.3.1</version>
    ...
    <resources>
        <resource>
            <filtering>true</filtering>
            <directory>${basedir}/src/main/command</directory>
            <includes>
                <include>run.bat</include>
                <include>run.sh</include>
            </includes>
            <targetPath>${basedir}</targetPath>
        </resource>
        <resource>
            <directory>${basedir}/src/main/resources</directory>
        </resource>
    </resources>
    ...
</build>
----

If you run 'mvn process-resources' in this project, you will end up with two files, 'run.sh' and 'run.bat', in '+++${basedir}+++'. We've singled out these two files in a +resource+ element, configuring filtering, and set the +targetPath+ to be '+++${basedir}+++'. In a second +resource+ element, we've configured the default resources path to be copied to the default output directory without any filtering. <<ex-filter-script>> shows you how to declare two resource directories and supply them with different filtering and target directory preferences. The project from <<ex-filter-script>> would contain a 'run.bat' file in 'src/main/command' with the following content:

----
@echo off
java -jar ${project.build.finalName}.jar %*
----

After running +mvn process-resources+, a file named 'run.bat' would appear in '+++${basedir}+++' with the following content:

----
@echo off
java -jar simple-cmd-2.3.1.jar %*
----

The ability to customize filtering for specific subsets of resources is another reason why complex projects with many different kinds of resources often find it advantageous to separate resources into multiple directories. The alternative to storing different kinds of resources with different filtering requirements in different directories is to use a more complex set of include and exclude patterns to match all resource files which match a certain pattern. 

[[lifecycle-sect-compile-phase]]
==== Compile

Most lifecycles bind the Compiler plugin's +compile+ goal to the +compile+ phase. This phase calls out to +compile:compile+ which is configured to compile all of the source code and copy the bytecode to the build output directory. If you haven't customized the values defined in the Super POM, +compile:compile+ is going to compile everything from 'src/main/java' to 'target/classes'. The Compiler plugin calls out to 'javac' and uses default source and target settings of 1.3 and 1.1. In other words, the compiler plugin assumes that your Java source conforms to Java 1.3 and that you are targeting a Java 1.1 JVM. If you would like to change these settings, you'll need to supply the target and source configuration to the Compiler plugin in your project's POM as shown in <<ex-compilesrc-target>>.

[[ex-compilesrc-target]]
.Setting the Source and Target Versions for the Compiler Plugin
----
<project>
    ...
    <build>
        ...
        <plugins>
            <plugin>
                <artifactId>maven-compiler-plugin</artifactId>
                <configuration>
                    <source>1.5</source>
                    <target>1.5</target>
                </configuration>
            </plugin>
        </plugins>
        ...
    </build>
    ...
</project>
----

Notice we are configuring the Compiler plugin, and not the specific +compile:compile+ goal. If we were going to configure the source and target for just the +compile:compile+ goal, we would place the +configuration+ element below an +execution+ element for the +compile:compile+ goal. We've configured the target and source for the plugin because +compile:compile+ isn't the only goal we're interested in configuring. The Compiler plugin is reused when Maven compiles tests using the +compile:testCompile+ goal, and configuring target and source at the plugin level allows us to define it once for all goals in a plugin.

If you need to customize the location of the source code, you can do so by changing the build configuration. If you wanted to store your project's source code in 'src/java' instead of 'src/main/java' and if you wanted build output to go to 'classes' instead of 'target/classes', you could always override the default +sourceDirectory+ defined by the Super POM.

.Overriding the Default Source Directory
----
<build>
    ...
    <sourceDirectory>src/java</sourceDirectory>
    <outputDirectory>classes</outputDirectory>
    ...
</build>
----

WARNING: While it might seem necessary to bend Maven to your own idea of project directory structure, we can't emphasize enough that you should sacrifice your own ideas of directory structure in favor of the Maven defaults. This isn't because we're trying to brainwash you into accepting the Maven Way, but it will be easier for people to understand your project if it adheres to the most basic conventions. Just forget about this. Don't do it.

[[lifecycle-sect-process-test-resources-phase]]
==== Process Test Resources

The +process-test-resources+ phase is almost indistinguishable from the +process-resources+ phase. There are some trivial differences in the POM, but most everything the same. You can filter test resources just as you filter regular resources. The default location for test resources is defined in the Super POM as 'src/test/resources', and the default output directory for test resources is 'target/test-classes' as defined in '+++${project.build.testOutputDirectory}+++'. 

[[lifecycle-sect-test-compile-phase]]
==== Test Compile

The +test-compile+ phase is almost identical to the +compile+ phase. The only difference is that +test-compile+ is going to invoke +compile:testCompile+ to compile source from the test source directory to the test build output directory. If you haven't customized the default directories from the Super POM, +compile:testCompile+ is going to compile the source in 'src/test/java' to the 'target/test-classes' directory.

As with the source code directory, if you want to customize the location of the test source code and the output of test compilation, you can do so by overriding the +testSourceDirectory+ and the testOutputDirectory. If you wanted to store test source in 'src-test/' instead of 'src/test/java' and you wanted to save test bytecode to 'classes-test/' instead of 'target/test-classes', you would use the following configuration.


.Overriding the Location of Test Source and Output
----
<build>
    ...
    <testSourceDirectory>src-test</testSourceDirectory>
    <testOutputDirectory>classes-test</testOutputDirectory>
    ...
</build>
----

[[lifecycle-sect-test-phase]]
==== Test

Most lifecycles bind the test goal of the Surefire plugin to the test phase. The Surefire plugin is Maven's unit testing plugin, the default behavior of Surefire is to look for all classes ending in *Test in the test source directory and to run them as http://www.junit.org[JUnit] tests. The Surefire plugin can also be configured to run http://www.testng.org[TestNG] unit tests.

After running +mvn test+, you should also notice that the Surefire produces a number of reports in 'target/surefire-reports'. This reports directory will have two files for each test executed by the Surefire plugin: an XML document containing execution information for the test, and a text file containing the output of the unit test. If there is a problem during the test phase and a unit test has failed, you can use the output of Maven and the contents of this directory to track down the cause of a test failure. This 'surefire-reports/' directory is also used during site generation to create an easy to read summary of all the unit tests in a project.

If you are working on a project that has some failing unit tests, but you want the project to produce output, you'll need to configure the Surefire plugin to continue a build even if it encounters a failure. The default behavior is to stop a build whenever a unit test failure is encountered. To override this behavior, you'll need to set the +testFailureIgnore+ configuration property on the Surefire plugin to true.

.Configuring Surefire to Ignore Test Failures
----
<build>
    <plugins>
        <plugin>
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-surefire-plugin</artifactId>
            <configuration>
                <testFailureIgnore>true</testFailureIgnore>
            </configuration>
        </plugin>
        ...
    </plugins>
</build>
----

If you would like to skip tests altogether, you can do so by executing the following command:

----
$ mvn install -Dmaven.test.skip=true
----

The +maven.test.skip+ variable controls both the Compiler and the Surefire plugin, if you pass in +maven.test.skip+ you've told Maven to ignore tests altogether. 

[[lifecycle-sect-install-phase]]
==== Install

The +install+ goal of the Install plugin is almost always bound to the +install+ lifecycle phase. This +install:install+ goal simply installs a project's main artifact to the local repository. If you have a project with a +groupId+ of +org.sonatype.mavenbook+, an +artifactId+ of +simple-test+, and a +version+ of 1.0.2, the +install:install+ goal is going to copy the JAR file from 'target/simple-test-1.0.2.jar' to '~/.m2/repository/org/sonatype/mavenbook/simple-test/1.0.2/simple-test-1.0.2.jar'. If the project has POM packaging, this goal will copy the POM to the local repository. 

[[lifecycle-sect-deploy-phase]]
==== Deploy

The +deploy+ goal of the Deploy plugin is usually bound to the +deploy+ lifecycle phase. This phase is used to deploy an artifact to a remote Maven repository, this is usually required to update a remote repository when you are performing a release. The deployment procedure can be as simple as copying a file to another directory or as complex as transferring a file over SCP using a public key. Deployment settings usually involve credentials to a remote repository, and, as such, deployment settings are usually not stored in a 'pom.xml'. Instead, deployment settings are more frequently found in an individual user's '~/.m2/settings.xml'. For now, all you need to know is that the +deploy:deploy+ goal is bound to the +deploy+ phase and it takes care of transporting an artifact to a published repository and updating any repository information which might be affected by such a deployment.   

[[profiles]]
== Build Profiles

[[profiles-sect-what]]
=== What Are They For?

Profiles allow for the ability to customize a particular build for a particular environment; profiles enable portability between different build environments.

What do we mean by different build environments? Two example build environments are production and development. When you are working in a development environment, your system might be configured to read from a development database instance running on your local machine while in production, your system is configured to read from the production database. Maven allows you to define any number of build environments (build profiles) which can override any of the settings in the 'pom.xml'. You could configure your application to read from your local, development instance of a database in your "development" profile, and you can configure it to read from the production database in the "production" profile. Profiles can also be activated by the environment and platform, you can customize a build to run differently depending the Operating System or the installed JDK version. Before we talk about using and configuring Maven profiles, we need to define the concept of Build Portability.

[[profiles-sect-portability]]
==== What is Build Portability

A build's "portability" is a measure of how easy it is to take a particular project and build it in different environments. A build which works without any custom configuration or customization of properties files is more portable than a build which requires a great deal of work to build from scratch. The most portable projects tend to be widely used open source projects like Apache Commons or Apache Velocity which ship with Maven builds which require little or no customization. Put simply, the most portable project builds tend to just work, out of the box, and the least portable builds require you to jump through hoops and configure platform specific paths to locate build tools. Before we show you how to achieve build portability, let's survey the different kinds of portability we are talking about.

[[profiles-sect-non-portable]]
===== Non-Portable Builds

The lack of portability is exactly what all build tools are made to prevent - however, any tool can be configured to be non-portable (even Maven). A non-portable project is buildable only under a specific set of circumstances and criteria (e.g., your local machine). Unless you are working by yourself and you have no plans on ever deploying your application to another machine, it is best to avoid non-portability entirely. A non-portable build only runs on a single machine, it is a "one-off". Maven is designed to discourage non-portable builds by offering the ability to customize builds using profiles.

When a new developer gets the source for a non-portable project, they will not be able to build the project without rewriting large portions of a build script. 

[[profiles-sect-environment-portability]]
===== Environment Portability

A build exhibits environment portability if it has a mechanism for customizing behavior and configuration when targeting different environments. A project that contains a reference to a test database in a test environment, for example, and a production database in a production environment, is environmentally portable. It is likely that this build has a different set of properties for each environment. When you move to a different environment, one that is not defined and has no profile created for it, the project will not work. Hence, it is only portable between defined environments.

When a new developer gets the source for an environmentally portable project, they will have to run the build within a defined environment or they will have to create a custom environment to successfully build the project. 

[[profiles-sect-org-portability]]
===== Organizational (In-House) Portability

The center of this level of portability is a project's requirement that only a select few may access internal resources such as source control or an internally-maintained Maven repository. A project at a large corporation may depend on a database available only to in-house developers, or an open source project might require a specific level of credentials to publish a web site and deploy the products of a build to a public repository.

If you attempt to build an in-house project from scratch outside of the in-house network (for example, outside of a corporate firewall), the build will fail. It may fail because certain required custom plugins are unavailable, or project dependencies cannot be found because you don't have the appropriate credentials to retrieve dependencies from a custom remote repository. Such a project is portable only across environments in a single organization. 

[[profiles-sect-wide-portability]]
===== Wide (Universal) Portability

Anyone may download a widely portable project's source, compile, and install it without customizing a build for a specific environment. This is the highest level of portability; anything less requires extra work for those who wish to build your project. This level of portability is especially important for open source projects, which depend on the ability for would-be contributors to easily download and build from source.

Any developer could download the source for a widely portable project.  

[[profiles-sect-select-level]]
==== Selecting an Appropriate Level of Portability

Clearly, you'll want to avoid creating the worst-case scenario: the non-portable build. You may have had the misfortune to work or study at an organization that had critical applications with non-portable builds. In such organizations, you cannot deploy an application without the help of a specific individual on a specific machine. In such an organization, it is also very difficult to introduce new project dependencies or changes without coordinating the change with the single person who maintains such a non-portable build. Non-portable builds tend to grow in highly political environments when one individual or group needs to exert control over how and when a project is built and deployed. "How do we build the system? Oh, we've got to call Jack and ask him to build it for us, no one else deploys to production." That is a dangerous situation which is more common that you would think. If you work for this organization, Maven and Maven profiles provide a way out of this mess.

On the opposite end of the portability spectrum are widely portable builds. Widely portable builds are generally the most difficult build systems to attain. These builds restrict your dependencies to those projects and tools that may be freely distributed and are publicly available. Many commercial software packages might be excluded from the most-portable builds because they cannot be downloaded before you have accepted a certain license. Wide portability also restricts dependencies to those pieces of software that may be distributed as Maven artifacts. For example, if you depend upon Oracle JDBC drivers, your users will have to download and install them manually; this is not widely portable as you will have to distribute a set of environment setup instructions for people interested in building your application. On the other hand, you could use a JDBC driver which is available from the public Maven repositories like MySQL or HSQLDB.

As stated previously, open source projects benefit from having the most widely portable build possible. Widely portable builds reduce the inefficiencies associated with contributing to a project. In an open source project (such as Maven) there are two distinct groups: end-users and developers. When an end-user uses a project like Maven and decides to contribute a patch to Maven, they have to make the transition from using the output of a build to running a build. They have to first become a developer, and if it is difficult to learn how to build a project, this end-user has a disincentive to take the time to contribute to a project. In a widely portable project, an end-user doesn't have to follow a set or arcane build instructions to start becoming a developer, they can download the source, modify the source, build, and submit a contribution without asking someone to help them set up a build environment. When the cost of contributing source back to an open-source project is lower, you'll see an increase in source code contributions, especially casual contributions which can make the difference between a project's success and a project's failure. One side-effect of Maven's adoption across a wide group of open source projects is that it has made it easier for developers to contribute code to various open source projects.  

[[profiles-sect-maven-profiles]]
=== Portability through Maven Profiles

A profile in Maven is an alternative set of configuration values which set or override default values. Using a profile, you can customize a build for different environments. Profiles are configured in the 'pom.xml' and are given an identifier. Then you can run Maven with a command-line flag that tells Maven to execute goals in a specific profile. The following 'pom.xml' uses a +production+ profile to override the default settings of the Compiler plugin.

[[ex-profiles-override-prod]]
.Using a Maven Profile to Override Production Compiler Settings
----
<project xmlns="http://maven.apache.org/POM/4.0.0" 
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
                             http://maven.apache.org/maven-v4_0_0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <groupId>org.sonatype.mavenbook</groupId>
    <artifactId>simple</artifactId>
    <packaging>jar</packaging>
    <version>1.0-SNAPSHOT</version>
    <name>simple</name>
    <url>http://maven.apache.org</url>
    <dependencies>
        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <version>3.8.1</version>
            <scope>test</scope>
        </dependency>
    </dependencies>
    <profiles> <1>
            <profile>
                <id>production</id> <2>
                    <build> <3>
                            <plugins>
                                <plugin>
                                    <groupId>org.apache.maven.plugins</groupId>
                                    <artifactId>maven-compiler-plugin</artifactId>
                                    <configuration>
                                        <debug>false</debug> <4>
                                            <optimize>true</optimize>
                                    </configuration>
                                </plugin>
                            </plugins>
                    </build>
            </profile>
    </profiles>
</project>
----

In this example, we've added a profile named +production+ that overrides the default configuration of the Maven Compiler plugin. Let's examine the syntax of this profile in detail.

<1> The +profiles+ element is in the 'pom.xml', it contains one or more +profile+ elements. Since profiles override the default settings in a 'pom.xml', the +profiles+ element is usually listed as the last element in a 'pom.xml'.

<2> Each profile has to have an +id+ element. This +id+ element contains the name which is used to invoke this profile from the command-line. A profile is invoked by passing the +-P<profile_id>+ command-line argument to Maven.

<3> A +profile+ element can contain many of the elements which can appear under the +project+ element of a POM XML Document. In this example, we're overriding the behavior of the Compiler plugin and we have to override the plugin configuration which is normally enclosed in a +build+ and a +plugins+ element. 

<4> We're overriding the configuration of the Maven Compiler plugin. We're making sure that the bytecode produced by the production profile doesn't contain debug information and that the bytecode has gone through the compiler's optimization routines.

To execute +mvn install+ under the +production+ profile, you need to pass the +-Pproduction+ argument on the command-line. To verify that the +production+ profile overrides the default Compiler plugin configuration, execute Maven with debug output enabled (+-X+) as follows:

----
~/examples/profile $ mvn clean install -Pproduction -X
... (omitting debugging output) ...
[DEBUG] Configuring mojo 'o.a.m.plugins:maven-compiler-plugin:2.0.2:testCompile'
[DEBUG]   (f) basedir = ~\examples\profile
[DEBUG]   (f) buildDirectory = ~\examples\profile\target
...
[DEBUG]   (f) compilerId = javac
[DEBUG]   (f) *debug = false*
[DEBUG]   (f) failOnError = true
[DEBUG]   (f) fork = false
[DEBUG]   (f) *optimize = true*
[DEBUG]   (f) outputDirectory = \
~\svnw\sonatype\examples\profile\target\test-classes
[DEBUG]   (f) outputFileName = simple-1.0-SNAPSHOT
[DEBUG]   (f) showDeprecation = false
[DEBUG]   (f) showWarnings = false
[DEBUG]   (f) staleMillis = 0
[DEBUG]   (f) verbose = false
[DEBUG] -- end configuration --
... (omitting debugging output) ...
----

This excerpt from the debug output of Maven shows the configuration of the Compiler plugin under the production profile. As shown in the output, +debug+ is set to false and +optimize+ is set to true.

[[profiles-sect-overriding-pom]]
==== Overriding a Project Object Model

While the previous example showed you how to override the default configuration properties of a single Maven plugin, you still don't know exactly what a Maven profile is allowed to override. The short-answer to that question is that a Maven profile can override almost everything that you would have in a 'pom.xml'. The Maven POM contains an element under project called +profiles+ containing a project's alternate configurations, and under this element are profile elements which define each profile. Each profile must have an +id+, and other than that, it can contain almost any of the elements one would expect to see under project. The following XML document shows all of the elements, a profile is allowed to override.


.Elements Allowed in a Profile
----
<project>
    <profiles>
        <profile>
            <build>
                <defaultGoal>...</defaultGoal>
                <finalName>...</finalName>
                <resources>...</resources>
                <testResources>...</testResources>
                <plugins>...</plugins>
            </build>
            <reporting>...</reporting>
            <modules>...</modules>
            <dependencies>...</dependencies>
            <dependencyManagement>...</dependencyManagement>
            <distributionManagement>...</distributionManagement>
            <repositories>...</repositories>
            <pluginRepositories>...</pluginRepositories>
            <properties>...</properties>
        </profile>
    </profiles>
</project>
----

 A profile can override an element shown with ellipses. A profile can override the final name of a project's artifact in a profile, the dependencies, and the behavior of a project's build via plugin configuration. A profile can also override the configuration of distribution settings depending on the profile; for example, if you need to publish an artifact to a staging server in a staging profile, you would create a staging profile which overrides the +distributionManagement+ element in a profile.  

[[profiles-sect-activation]]
=== Profile Activation

In the previous section we showed you how to create a profile that overrides default behavior for a specific target environment. In the previous build the default build was designed for development and the +production+ profile exists to provide configuration for a production environment. What happens when you need to provide customizations based on variables like operating systems or JDK version? Maven provides a way to "activate" a profile for different environmental parameters, this is called profile activation.

Take the following example, assume that we have a Java library that has a specific feature only available in the Java 6 release: the Scripting Engine as defined in http://jcp.org/en/jsr/detail?id=223[JSR-223]. You've separated the portion of the library that deals with the scripting library into a separate Maven project, and you want people running Java 5 to be able to build the project without attempting to build the Java 6 specific library extension. You can do this by using a Maven profile that adds the script extension module to the build only when the build is running within a Java 6 JDK. First, let's take a look at our project's directory layout and how we want developers to build the system.

When someone runs +mvn install+ with a Java 6 JDK, you want the build to include the +simple-script+ project's build, when they are running in Java 5, you would like to skip the +simple-script+ project build. If you failed to skip the +simple-script+ project build in Java 5, your build would fail because Java 5 does not have the +ScriptEngine+ on the classpath. Let's take a look at the library project's 'pom.xml':

[[ex-profiles-dyn-inclusion]]
.Dynamic Inclusion of Submodules Using Profile Activation
----
<project xmlns="http://maven.apache.org/POM/4.0.0" 
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
                             http://maven.apache.org/maven-v4_0_0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <groupId>org.sonatype.mavenbook</groupId>
    <artifactId>simple</artifactId>
    <packaging>jar</packaging>
    <version>1.0-SNAPSHOT</version>
    <name>simple</name>
    <url>http://maven.apache.org</url>
    <dependencies>
        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <version>3.8.1</version>
            <scope>test</scope>
        </dependency>
    </dependencies>
    <profiles>
        <profile>
            <id>jdk16</id>
            <activation> <1>
                    <jdk>1.6</jdk>
            </activation>
            <modules> <2>
                    <module>simple-script</module>
            </modules>
        </profile>
    </profiles>
</project>
----

If you run +mvn install+ under Java 1.6, you will see Maven descending into the 'simple-script' subdirectory to build the +simple-script+ project. If you are running +mvn install+ in Java 1.5, the build will not try to build the +simple-script+ submodule. Exploring this activation configuration in more detail:

<1> The +activation+ element lists the conditions for profile activation. In this example, we've specified that this profile will be activated by Java versions that begin with "1.6". This would include "1.6.0_03", "1.6.0_02", or any other string that began with "1.6". Activation parameters are not limited to Java version, for a full list of activation parameters, see <<profiles-sect-activation-config>>. 

<2> In this profile we are adding the module +simple-script+. Adding this module will cause Maven to look in the 'simple-script/' subdirectory for a 'pom.xml'.

[[profiles-sect-activation-config]]
==== Activation Configuration

Activations can contain one of more selectors including JDK versions, Operating System parameters, files, and properties. A profile is activated when all activation criteria has been satisfied. For example, a profile could list an Operating System family of Windows, and a JDK version of 1.4, this profile will only be activated when the build is executed on a Windows machine running Java 1.4. If the profile is active then all elements override the corresponding project-level elements as if the profile were included with the +-P+ command-line argument. The following example, lists a profile which is activated by a very specific combination of operating system parameters, properties, and a JDK version.

[[ex-profiles-active-params]]
.Profile Activation Parameters: JDK Version, OS Parameters, and Properties
----
<project>
    ...
    <profiles>
        <profile>
            <id>dev</id>
            <activation>
                <activeByDefault>false</activeByDefault> <1>
                    <jdk>1.5</jdk> <2>
                        <os>
                            <name>Windows XP</name> <3>
                                <family>Windows</family>
                                <arch>x86</arch>
                                <version>5.1.2600</version>
                        </os>
                        <property>
                            <name>customProperty</name> <4>
                                <value>BLUE</value>
                        </property>
                        <file>
                            <exists>file2.properties</exists> <5>
                                <missing>file1.properties</missing>
                        </file>
            </activation>
            ...
        </profile>
    </profiles>
</project>
----

 This previous example defines a very narrow set of activation parameters. Let's examine each activation criterion in detail:

<1> The +activeByDefault+ element controls whether this profile is considered active by default. 

<2> <callout arearefs="coDef-profiles-active2-2" id="coRef-profiles-active2-2"> This profile will only be active for JDK versions that begin with "1.5". This includes "1.5.0_01", "1.5.1". 

<3> <callout arearefs="coDef-profiles-active2-3" id="coRef-profiles-active2-3"> This profile targets a very specific version of Windows XP, version 5.1.2600 on a 32-bit platform. If your project uses the native plugin to build a C program, you might find yourself writing projects for specific platforms. 

<4> <callout arearefs="coDef-profiles-active2-4" id="coRef-profiles-active2-4"> The +property+ element tells Maven to activate this profile if the property +customProperty+ is set to the value +BLUE+. 

<5> <callout arearefs="coDef-profiles-active2-5" id="coRef-profiles-active2-5"> The +file+ element allows us to activate a profile based on the presence (or absence) of files. The +dev+ profile will be activated if a file named 'file2.properties' exists in the base directory of the project. The +dev+ profile will only be activated if there is no file named 'file1.properties' file in the base directory of the project. 

[[profiles-sect-activation-by-absence]]
==== Activation by the Absence of a Property

You can activate a profile based on the value of a property like +environment.type+. You can activate a +development+ profile if +environment.type+ equals +dev+, or a +production+ profile if +environment.type+ equals +prod+. You can also activate a profile in the absence of a property. The following configuration activates a profile if the property +environment.type+ is not present during Maven execution.

.Activating Profiles in the Absence of a Property
----
<project>
    ...
    <profiles>
        <profile>
            <id>development</id>
            <activation>
                <property>
                    <name>!environment.type</name>
                </property>
            </activation>
        </profile>
    </profiles>
</project>
----

Note the exclamation point prefixing the property name. The exclamation point is often referred to as the "bang" character and signifies "not". This profile is activated when no '+++${environment.type}+++' property is set.  

[[profiles-sect-listing-active-profiles]]
=== Listing Active Profiles

Maven profiles can be defined in either 'pom.xml', 'profiles.xml', '~/.m2/settings.xml', or '+++${M2_HOME}/conf/settings.xml+++'. With these four levels, there's no good way of keeping track of profiles available to a particular project without remembering which profiles are defined in these four files. To make it easier to keep track of which profiles are available, and where they have been defined, the Maven Help plugin defines a goal, +active-profiles+, which lists all the active profiles and where they have been defined. You can run the +active-profiles+ goal, as follows:

----
$ mvn help:active-profiles
Active Profiles for Project 'My Project':

The following profiles are active:

- my-settings-profile (source: settings.xml)
- my-external-profile (source: profiles.xml)
- my-internal-profile (source: pom.xml)
----

[[profiles-sect-tips-tricks]]
=== Tips and Tricks

Profiles can encourage build portability. If your build needs subtle customizations to work on different platforms or if you need your build to produce different results for different target platforms, project profiles increase build portability. Settings profiles generally decrease build portability by adding extra-project information that must be communicated from developer to developer. The following sections provide some guidelines and some ideas for applying Maven profiles to your project. 

[[profiles-sect-common-envs]]
==== Common Environments

One of the core motivations for Maven project profiles was to provide for environment-specific configuration settings. In a development environment, you might want to produce bytecode with debug information and you might want to configure your system to use a development database instance. In a production environment you might want to produce a signed JAR and configure the system to use a production database. In this chapter, we defined a number of environments with identifiers like +dev+ and +prod+. A simpler way to do this would be to define profiles that are activated by environment properties and to use these common environment properties across all of your projects.

For example, if every project had a +development+ profile activated by a property named +environment.type+ having a value of +dev+, and if those same projects had a +production+ profile activated by a property named +environment.type+ having a value of +prod+, you could simply pass in the appropriate property value on the command-line to ensure that your builds target the correct environment. You can then use this property to activate profiles defined in a project's 'pom.xml' as follows. Let's take a look at how a project's 'pom.xml' would define a profile activated by +environment.type+ having the value +dev+.

[[ex-profile-envtype-pom]]
.Project Profile Activated by setting environment.type to 'dev'
----
<project>
    ...
    <profiles>
        <profile>
            <id>development</id>
            <activation>
                <activeByDefault>true</activeByDefault>
                <property>
                    <name>environment.type</name>
                    <value>dev</value>
                </property>
            </activation>
            <properties>
                <database.driverClassName>com.mysql.jdbc.Driver</database.driverClassName>
                <database.url>
                    jdbc:mysql://localhost:3306/app_dev
                </database.url>
                <database.user>development_user</database.user>
                <database.password>development_password</database.password>
            </properties>
        </profile>
        <profile>
            <id>production</id>
            <activation>
                <property>
                    <name>environment.type</name>
                    <value>prod</value>
                </property>
            </activation>
            <properties>
                <database.driverClassName>com.mysql.jdbc.Driver</database.driverClassName>
                <database.url>jdbc:mysql://master01:3306,slave01:3306/app_prod</database.url>
                <database.user>prod_user</database.user>
            </properties>
        </profile>
    </profiles>
</project>
----

This project defines some properties like +database.url+ and +database.user+ which might be used to configure another Maven plugin configured in the 'pom.xml'. There are plugins available that can manipulate the database, run SQL, and plugins like the Maven Hibernate3 plugin which can generate annotated model objects for use in persistence frameworks. A few of these plugins, can be configured in a 'pom.xml' using these properties. These properties could also be used to filter resources. If we needed to target the development environment, we would just run the following command:

----
~/examples/profiles $ mvn install
----

Because the development profile is active by default, and because there are no other profiles activated, running +mvn help:active-profiles+ will show that the development profile is active. Now, the activeByDefault option will only work if no other profiles are active. If you wanted to be sure that the development profile would be active for a given build, you could explicitly pass in the environment.type variable as follows:

----
~/examples/profiles $ mvn install -Denvironment.type=dev
----

Alternatively, if we need to activate the production profile, we could always run Maven with:

----
~/examples/profiles $ mvn install -Denvironment.type=prod
----

To test which profiles are active for a given build, use +mvn help:active-profiles+. 

[[profiles-sect-protecting-secrets]]
==== Protecting Secrets

This best practice builds upon the previous section. In <<ex-profile-envtype-pom>>, the production profile does not contain the +database.password+ property. I've done this on purpose to illustrate the concept of putting secrets in you user-specific 'settings.xml'. If you were developing an application at a large organization which values security, it is likely that the majority of the development group will not know the password to the production database. In an organization that draws a bold line between the development group and the operations group, this will be the norm. Developers may have access to a development and a staging environment, but they might not have (or want to have) access to the production database. There are a number of reasons why this makes sense, particularly if an organization is dealing with extremely sensitive financial, intelligence, or medical information. In this scenario, the production environment build may only be carried out by a lead developer or by a member of the production operations group. When they run this build using the +prod+ +environment.type+, they will need to define this variable in their 'settings.xml' as follows:

.Storing Secrets in a User-specific Settings Profile
----
<settings>
    <profiles>
        <profile>
            <activeByDefault>true</activeByDefault>
            <properties>
                <environment.type>prod</environment.type>
                <database.password>m1ss10nimp0ss1bl3</database.password>
            </properties>
        </profile>
    </profiles>
</settings>
----

This user has defined a default profile which sets the +environment.type+ to +prod+ and which also sets the production password. When the project is executed, the production profile is activated by the +environment.type+ property and the +database.password+ property is populated. This way, you can put all of the production-specific configuration into a project's 'pom.xml' and leave out only the single secret necessary to access the production database.

NOTE: Secrets usually conflict with wide portability, but this makes sense. You wouldn't want to share your secrets openly.  

[[profiles-sect-platform-classifier]]
==== Platform Classifiers

Let's assume that you have a library or a project that produces platform-specific customizations. Even though Java is platform-neutral, there are times when you might need to write some code that invokes platform-specific native code. Another possibility is that you've written some C code which is compiled by the Maven Native plugin and you want to produce a qualified artifact depending on the build platform. You can set a classifier with the Maven Assembly plugin or with the Maven Jar plugin. The following 'pom.xml' produces a qualified artifact using profiles which are activated by Operating System parameters. For more information about the Maven Assembly plugin, see <<assemblies>>.

.Qualifying Artifacts with Platform Activated Project Profiles
----
<project>
    ...
    <profiles>
        <profile>
            <id>windows</id>
            <activation>
                <os>
                    <family>windows</family>
                </os>
            </activation>
            <build>
                <plugins>
                    <plugin>
                        <artifactId>maven-jar-plugin</artifactId>
                        <configuration>
                            <classifier>win</classifier>
                        </configuration>
                    </plugin>
                </plugins>
            </build>
        </profile>
        <profile>
            <id>linux</id>
            <activation>
                <os>
                    <family>unix</family>
                </os>
            </activation>
            <build>
                <plugins>
                    <plugin>
                        <artifactId>maven-jar-plugin</artifactId>
                        <configuration>
                            <classifier>linux</classifier>
                        </configuration>
                    </plugin>
                </plugins>
            </build>
        </profile>
    </profiles>
</project>
----

If the Operating System is in the Windows family, this 'pom.xml' qualifies the JAR artifact with "-win". If the Operating System is in the Unix family, the artifact is qualified with "-linux". This 'pom.xml' successfully adds the qualifiers to the artifacts, but it is more verbose than it need to be due to the redundant configuration of the Maven Jar plugin in both profiles. This example could be rewritten to use variable substitution to minimize redundancy as follows:

.Qualifying Artifacts with Platform Activated Project Profiles and Variable Substitution
----
<project>
    ...
    <build>
        <plugins>
            <plugin>
                <artifactId>maven-jar-plugin</artifactId>
                <configuration>
                    <classifier>${envClassifier}</classifier>
                </configuration>
            </plugin>
        </plugins>
    </build>
    ...
    <profiles>
        <profile>
            <id>windows</id>
            <activation>
                <os>
                    <family>windows</family>
                </os>
            </activation>
            <properties>
                <envClassifier>win</envClassifier>
            </properties>
        </profile>
        <profile>
            <id>linux</id>
            <activation>
                <os>
                    <family>unix</family>
                </os>
            </activation>
            <properties>
                <envClassifier>linux</envClassifier>
            </properties>
        </profile>
    </profiles>
</project>
----

In this 'pom.xml', each profile doesn't need to include a +build+ element to configure the Jar plugin. Instead, each profile is activated by the Operating System family and sets the +envClassifier+ property to either +win+ or +linux+. This +envClassifier+ is then referenced in the default 'pom.xml' +build+ element to add a classifier to the project's JAR artifact. The JAR artifact will be named '+++${finalName}-${envClassifier}.jar+++' and included as a dependency using the following dependency syntax:

.Depending on a Qualified Artifact
----
<dependency>
    <groupId>com.mycompany</groupId>
    <artifactId>my-project</artifactId>
    <version>1.0</version>
    <classifier>linux</classifier>
</dependency>
----

[[profiles-sect-summary]]
=== Summary

When used judiciously, profiles can make it very easy to customize a build for different platforms. If something in your build needs to define a platform-specific path for something like an application server, you can put these configuration points in a profile which is activated by an operating system parameter. If you have a project which needs to produce different artifacts for different environments, you can customize the build behavior for different environments and platforms via profile-specific plugin behavior. Using profiles, builds can become portable, there is no need to rewrite your build logic to support a new environment, just override the configuration that needs to change and share the configuration points which can be shared.

[[running]]
== Running Maven

This chapter focuses on the various ways in which Maven can be customized at runtime. It also provides some documentation of special features such as the ability to customize the behavior of the Maven Reactor and how to use the Maven Help plugin to obtain information about plugins and plugin goals.

[[running-sect-options]]
=== Maven Command Line Options

The following sections detail Maven's command line options.

[[running-sect-define-prop]]
==== Defining Properties

To define a property use the following option on the command line:

-D, --define <arg>::

  Defines a system property

This is the option most frequently used to customized the behavior of Maven plugins. Some examples of using the +-D+ command line argument:

----
$ mvn help:describe -Dcmd=compiler:compile
$ mvn install -Dmaven.test.skip=true
----

Properties defined on the command line are also available as properties to be used in a Maven POM or Maven Plugin. Form more information about referencing Maven properties, see <<resource-filtering>>.

Properties can also be used to activate build profiles. For more information about Maven build profiles, see <<profiles>>.

[[running-sect-help-option]]
==== Getting Help

To list the available command line parameters, use the following command line option:

-h, --help::

  Display help information

Executing Maven with this option produces the following output:

----
$ mvn --help

usage: mvn [options] [<goal(s)>] [<phase(s)>]

Options:
-am,--also-makeIf project list is specified, also
build projects required by the
list
-amd,--also-make-dependentsIf project list is specified, also
build projects that depend on
projects on the list
-B,--batch-modeRun in non-interactive (batch)
mode
-C,--strict-checksums  Fail the build if checksums don't
match
-c,--lax-checksums Warn if checksums don't match
-cpu,--check-plugin-updatesForce upToDate check for any
relevant registered plugins
-D,--define <arg>  Define a system property
-e,--errorsProduce execution error messages
-emp,--encrypt-master-password <arg>   Encrypt master security password
-ep,--encrypt-password <arg>   Encrypt server password
-f,--file  Force the use of an alternate POM
file.
-fae,--fail-at-end Only fail the build afterwards;
allow all non-impacted builds to
continue
-ff,--fail-fastStop at first failure in
reactorized builds
-fn,--fail-never   NEVER fail the build, regardless
of project result
-gs,--global-settings <arg>Alternate path for the global
settings file
-h,--help  Display help information
-N,--non-recursive Do not recurse into sub-projects
-npr,--no-plugin-registry  Don't use
~/.m2/plugin-registry.xml for
plugin versions
-npu,--no-plugin-updates   Suppress upToDate check for any
relevant registered plugins
-o,--offline   Work offline
-P,--activate-profiles <arg>   Comma-delimited list of profiles
to activate
-pl,--projects <arg>   Build specified reactor projects
instead of all projects
-q,--quiet Quiet output - only show errors
-r,--reactor   Dynamically build reactor from
subdirectories
-rf,--resume-from <arg>Resume reactor from specified
project
-s,--settings <arg>Alternate path for the user
settings file
-U,--update-snapshots  Forces a check for updated
releases and snapshots on remote
repositories
-up,--update-plugins   Synonym for cpu
-V,--show-version  Display version information
WITHOUT stopping build
-v,--version   Display version information
-X,--debug Produce execution debug output
----

If you are looking for information about the goals and parameters available from a specific Maven plugin, see <<installation-sect-help-plugin-install>>. 

[[running-sect-profile-option]]
==== Using Build Profiles

To activate one or more build profiles from the command line, use the following option:

-P, --activate-profiles <arg>::

  Comma-delimited list of profiles to activate

For more information about build profiles, see <<profiles>>.

[[running-sect-version-option]]
==== Displaying Version Information

To display Maven version information, use one of the following options on the command line:

-V, --show-version::

  Display version information WITHOUT stopping build

-v, --version::

  Display version information

Both of these options produce the same version information output, but the -v option will terminate the Maven process after printing out the version. You would use the -V option if you wanted to have the Maven version information present at the beginning of your build's output. This can come in handy if you are running Maven in a continuous build environment and you need to know what version of Maven was used for a particular build.

.Maven Version Information
----
$ mvn -v
Apache Maven 2.2.1 (r801777; 2009-08-06 14:16:01-0500)
Java version: 1.6.0_15
Java home: /System/Library/Frameworks/JavaVM.framework/Versions/1.6.0/Home
Default locale: en_US, platform encoding: MacRoman
OS name: "mac os x" version: "10.6.1" arch: "x86_64" Family: "mac"

----

[[running-sect-offline-option]]
==== Running in Offline Mode

If you ever need to use Maven without having access to a network, you should use the following option to prevent any attempt to check for updates to plugins or dependencies over a network:

-o, --offline::

  Work offline

When running with the offline option enabled, Maven will not attempt to connect to a remote repository to retrieve artifacts. 

[[running-sect-custom-locations-option]]
==== Using a Custom POM or Custom Settings File

If you don't like the 'pom.xml' file name, the location of your user-specific Maven settings, or the default location of your global settings file, you can customize any of these things with the following options:

-f, --file <file>::

  Forces the use of an alternate POM file

-s,--settings <arg>::

  Alternate path for the user settings file

-gs, --global-settings <file>::

  Alternate path for the global settings file

[[running-sect-encrypt-option]]
==== Encrypting Passwords

The following commands allow you to use Maven to encrypt passwords for storage in a Maven settings file:

-emp, --encrypt-master-password <password>::

   Encrypt master security password

-ep, --encrypt-password <password>::

   Encrypt server password

Encrypting passwords is documented in <<appendix-settings-sect-encrypting-passwords>>. 

[[running-sect-failure-option]]
==== Dealing with Failure

The following options control how Maven reacts to a build failure in the middle of a multi-module project build:

-fae, --fail-at-end::

  Only fail the build afterwards; allow all non-impacted builds to continue

-ff, --fail-fast::

  Stop at first failure in reactorized builds

-fn, --fail-never::

  NEVER fail the build, regardless of project result

The +-fn+ and +-fae+ options are useful options for multi-module builds that are running within a continuous integration tool like Hudson. The +-ff+ option is very useful for developers running interactive builds who want to have rapid feedback during the development cycle. 

[[running-sect-verbose-option]]
==== Controlling Maven's Verbosity

If you want to control Maven's logging level, you can use one of the following three command line options:

-e, --errors::

  Produce execution error messages

-X, --debug::

  Produce execution debug output

-q, --quiet::

  Quiet output - only show errors

The +-q+ option only prints a message to the output if there is an error or a problem.

The +-X+ option will print an overwhelming amount of debugging log messages to the output. This option is primarily used by Maven developers and by Maven plugin developers to diagnose problems with Maven code during development. This +-X+ option is also very useful if you are attempting to diagnose a difficult problem with a dependency or a classpath.

The +-e+ option will come in handy if you are a Maven developer, or if you need to diagnose an error in a Maven plugin. If you are reporting an unexpected problem with Maven or a Maven plugin, you will want to pass both the +-X+ and +-e+ options to your Maven process.

[[running-sect-batch-option]]
==== Running Maven in Batch Mode

To run Maven in batch mode use the following option:

-B, --batch-mode::

  Run in non-interactive (batch) mode

Batch mode is essential if you need to run Maven in a non-interactive, continuous integration environment. When running in non-interactive mode, Maven will never stop to accept input from the user. Instead, it will use sensible default values when it requires input. 

[[running-sect-deps-option]]
==== Downloading and Verifying Dependencies

The following command line options affect the way that Maven will interact with remote repositories and how it verifies downloaded artifacts:

-C, --strict-checksums::

  Fail the build if checksums don't match

-c, --lax-checksums::

  Warn if checksums don't match

-U, --update-snapshots::

  Forces a check for updated releases and snapshots on remote repositories

If you are concerned about security, you will want to run Maven with the +-C+ option. Maven repositories maintain an MD5 and SHA1 checksum for every artifact stored in a repository. Maven is configured to warn the end-user if an artifact's checksum doesn't match the downloaded artifact. Passing in the +-C+ option will cause Maven to fail the build if it encounters an artifact with a bad checksum.

The +-U+ option is useful if you want to make sure that Maven is checking for the latest versions of all SNAPSHOT dependencies. 

[[running-sect-plugup-option]]
.Controlling Plugin Updates

The following command line options tell Maven how it should update (or not update) Maven plugins from remote repositories:

-npu, --no-plugin-updates::

   Suppress upToDate check for any relevant registered plugins. Providing this option will have the affect of stabilizing Maven on all of the plugins versions that are currently available in a local Maven repository. With +-npu+ active, Maven will not consult the remote repository for newer Maven versions.  

-cpu, --check-plugin-updates::

   Force upToDate check for any relevant registered plugins. Forces Maven to check for the latest released version of a Maven plugin. Not that this will not affect your build if you are explicitly specifying versions for Maven plugins in your project's POM.  

-up, --update-plugins::

   Synonym for cpu.   


The following command line option that affects the way Maven downloads plugins from a remote repository:

-npr, --no-plugin-registry::

   Don't use ~/.m2/plugin-registry.xml for plugin versions.   

When preset, the +-npr+ command line option will tell Maven not to consult the Plugin Registry. For more information about the Plugin Registry, go here: http://maven.apache.org/guides/introduction/introduction-to-plugin-registry.html[http://maven.apache.org/guides/introduction/introduction-to-plugin-registry.html]. 

[[running-sect-norecurse-option]]
==== Non-recursive Builds

There will be times when you simply want to run a Maven build without having Maven descend into all of a project's submodules. You can do this by using the following command line option:

-N, --non-recursive::

   Prevents Maven from building submodules. Only builds the project contained in the current directory.   

Running this will only cause Maven to execute a goal or step through the lifecycle for the project in the current directory. Maven will not attempt to build all of the projects in a multi-module project when you use the +-N+ command line option.  

=== Using Advanced Reactor Options

Starting with the Maven 2.1 release, there are new Maven command line options which allow you to manipulate the way that Maven will build multimodule projects. These new options are:

-rf, --resume-from::

  Resume reactor from specified project


-pl, --projects::

  Build specified reactor projects instead of all projects


-am, --also-make::

  If project list is specified, also build projects required by the list


-amd, --also-make-dependents::

  If project list is specified, also build projects that depend on projects on the list



[[running-sect-downloading-aro]]
==== Advanced Reactor Options Example Project

The example in this section is a skeleton of a complex multimodule project that is used to illustrate the advanced reactor options. While it is possible to read this section without the example code, you might want to download the example code and follow along, experimenting with the various options as you learn how to use the advanced reactor options. This section’s example project may be downloaded with the book’s example code at:

----
http://www.sonatype.com/books/mvnref-book/mvnref-examples.zip
----

Unzip this archive in any directory, and then go to the 'ch-running/' directory. There you will see a directory named 'sample-parent/'. All of the examples in this section will be executed from the 'examples/ch-running/sample-parent/' directory in the examples distribution. The sample-parent/ directory contains the multimodule project structure shown in <<fig-running-aro-dir-struct>>.

[[fig-running-aro-dir-struct]]
.Directory Structure of Sample Multi-module Project
image::figs/web/running_aro-project-dir.png[]

This project approximates the structure of a real-world enterprise project: the +sample-model+ project contains a set of foundational model objects used throughout the system, the +sample-util+ project would contain utility code, the +sample-persist+ project would contain logic that deals with persisting objects to a database, and the other projects would all be combined to produce the various GUI and Web-based interfaces that comprise a very complex system. <<fig-running-aro-depends>> captures the dependencies between each of these sample modules.

[[fig-running-aro-depends]]
.Dependencies within Sample Multi-module Project
image::figs/web/running_aro-dependencies.png[]

If you go into the 'sample-parent/' project directory and run +mvn clean+, you will see that the Maven Reactor reads all of the project dependencies and comes up with the following build order for these projects as shown in <<ex-running-aro-order>>.

[[ex-running-aro-order]]
.Order of Project Builds in Maven Reactor
----
[INFO] Reactor build order: 
[INFO]   sample-parent
[INFO]   sample-model
[INFO]   sample-persist
[INFO]   sample-services
[INFO]   sample-util
[INFO]   sample-security
[INFO]   sample-admin-webapp
[INFO]   sample-webapp
[INFO]   sample-rest
[INFO]   sample-client-connector
[INFO]   sample-gui
[INFO]   sample-admin-gui
----




==== Resuming Builds

The +-rf+ or +--resume-from+ option can come in handy if you want to tell the Maven Reactor to resume a build from a particular project. This can be useful if you are working with a large multimodule project and you want to restart a build at a particular project in the Reactor without running through all of the projects that precede it in the build order.

Assume that you are working on the multi-module project with the build order shown in <<ex-running-aro-order>> and that your build ran successfully up until Maven encountered a failing unit test in +sample-client-connector+. With the +-rf+ option, you can fix the unit test in +simple-client-connector+ and then run +mvn -rf sample-client-connect+ from the 'sample-parent/' directory to resume the build with the final three projects.

----
$ mvn --resume-from sample-client-connector install
[INFO] Scanning for projects...
[INFO] Reactor build order: 
[INFO]   sample-client-connector
[INFO]   sample-gui
[INFO]   sample-admin-gui
...
----

==== Specifying a Subset of Projects

The +-pl+ or +--projects+ option allows you to select a list of projects from a multimodule project. This option can be useful if you are working on a specific set of projects, and you'd rather not wait for a full build of a multi-module project during a development cycle.

Assume that you are working on the multi-module project with the build order shown in <<ex-running-aro-order>> and that you are a developer focused on the +sample-rest+ and +sample-client-connector+ projects. If you only wanted Maven to build the +sample-rest+ and +sample-client-connector+ project, you would use the following syntax from the 'sample-parent/' directory:

----
$ mvn --projects sample-client-connector,sample-rest install
[INFO] Scanning for projects...
[INFO] Reactor build order: 
[INFO]   sample-rest
[INFO]   sample-client-connector
----



[[running-sect-make-subset]]
==== Making a Subset of Projects

If you wanted to run a portion of the larger build, you would use the +-pl+ or +--projects+ option with the +-am+ or +--also-make option+. When you specify a project with the +-am+ option, Maven will build all of the projects that the specified project depends upon (either directly or indirectly). Maven will examine the list of projects and walk down the dependency tree, finding all of the projects that it needs to build.

If you are working on the multi-module project with the build order shown in <<ex-running-aro-order>> and you were only interested in working on the +sample-services+ project, you would run +mvn -pl simple-services -am+ to build only those projects

----
$ mvn --projects sample-services --also-make install
[INFO] Scanning for projects...
[INFO] Reactor build order: 
[INFO]   sample-parent
[INFO]   sample-model
[INFO]   sample-persist
[INFO]   sample-services
----



==== Making Project Dependents

While the +-am+ command makes all of the projects required by a particular project in a multi-module build, the +-amd+ or +--also-make-dependents+ option configures Maven to build a project and any project that depends on that project. When using +--also-make-dependents+, Maven will examine all of the projects in our reactor to find projects that depend on a particular project. It will automatically build those projects and nothing else.

If you are working on the multi-module project with the build order shown in <<ex-running-aro-order>> and you wanted to make sure that your changes to +sample-services+ did not introduce any errors into the projects that directly or indirectly depend on +sample-services+, you would run the following command:

----
$ mvn --projects sample-services --also-make-dependents install
[INFO] Scanning for projects...
[INFO] Reactor build order: 
[INFO]   sample-services
[INFO]   sample-admin-webapp
[INFO]   sample-webapp
[INFO]   sample-rest
----

[[running-sect-resuming]]
==== Resuming a "make" build

When using +--also-make+, Maven will execute a subset of the larger build as shown in <<running-sect-make-subset>>. Combining +--project+, +--also-make+, and +--resume-from+ provides you with the ability to refine your build even further. The +-rf+ or +--resume-from+ resumes the build from a specific point in the Reactor build order.

----
$ mvn --projects sample-webapp --also-make \
      --resume-from sample-services install
[INFO] Scanning for projects...
[INFO] Reactor build order: 
[INFO]   sample-services
[INFO]   sample-util
[INFO]   sample-security
[INFO]   sample-webapp
----

In this example, the build is resumed from +sample-services+ which omits the +sample-persist+ and +sample-model+ projects from the build. If you are focused on individual components and you need to accelerate your build times, using these advanced reactor options together is a great way to skip portions of your large multi-module project build. The +--resume-from+ argument also works with +--also-make-dependents+.  

[[installation-sect-help-plugin-install]]
=== Using the Maven Help Plugin

Throughout this book, we introduce Maven plugins, talking about Maven Project Object Model (POM) files, settings files, and profiles. There are going to be times when you need a tool to help you make sense of some of the models that Maven is using and what goals are available on a specific plugin. The Maven Help plugin allows you to list active Maven profiles, display an effective POM, print the effective settings, or list the attributes of a Maven plugin.

The Maven Help plugin has four goals. The first three goals—+active-profiles+, +effective-pom+, and +effective-settings+—describe a particular project and must be run in the base directory of a project. The last goal—+describe+—is slightly more complex, showing you information about a plugin or a plugin goal. The following commands provide some general information about the four goals:


help:active-profiles::

   Lists the profiles (project, user, global) which are active for the build.  

help:effective-pom::

   Displays the effective POM for the current build, with the active profiles factored in.  

help:effective-settings::

   Prints out the calculated settings for the project, given any profile enhancement and the inheritance of the global settings into the user-level settings.  

help:describe::

   Describes the attributes of a plugin. This need not run under an existing project directory. You must at least give the +groupId+ and +artifactId+ of the plugin you wish to describe.   

[[installation-sect-describing-plugin]]
==== Describing a Maven Plugin

Once you start using Maven, you'll spend most of your time trying to get more information about Maven Plugins: How do plugins work? What are the configuration parameters? What are the goals? The +help:describe+ goal is something you'll be using very frequently to retrieve this information. With the +plugin+ parameter you can specify a plugin you wish to investigate, passing in either the plugin prefix (e.g. +maven-help-plugin+ as +help+) or the +groupId:artifact[:version]+, where version is optional. For example, the following command uses the Help plugin's +describe+ goal to print out information about the Maven Help plugin.

----
$ mvn help:describe -Dplugin=help
...
Group Id:  org.apache.maven.plugins
Artifact Id: maven-help-plugin
Version: 2.0.1
Goal Prefix: help
Description:

The Maven Help plugin provides goals aimed at helping to make sense out of
the build environment. It includes the ability to view the effective
POM and settings files, after inheritance and active profiles
have been applied, as well as a describe a particular plugin goal to give 
usage information.
...

----

Executing the +describe+ goal with the +plugin+ parameter printed out the Maven coordinates for the plugin, the goal prefix, and a brief description of the plugin. While this information is helpful, you'll usually be looking for more detail than this. If you want the Help plugin to print a full list of goals with parameters, execute the +help:describe+ goal with the parameter +full+ as follows:

----
$ mvn help:describe -Dplugin=help -Dfull
...
Group Id:  org.apache.maven.plugins
Artifact Id: maven-help-plugin
Version: 2.0.1
Goal Prefix: help
Description:

The Maven Help plugin provides goals aimed at helping to make sense out of
the build environment. It includes the ability to view the effective
POM and settings files, after inheritance and active profiles
have been applied, as well as a describe a particular plugin goal to 
give usage information.

Mojos:

Goal: 'active-profiles'
Description:

Lists the profiles which are currently active for this build.

Implementation: org.apache.maven.plugins.help.ActiveProfilesMojo
Language: java

Parameters:

[0] Name: output
Type: java.io.File
Required: false
Directly editable: true
Description:

This is an optional parameter for a file destination for the output of 
this mojo...the listing of active profiles per project.


[1] Name: projects
Type: java.util.List
Required: true
Directly editable: false
Description:

This is the list of projects currently slated to be built by Maven.


This mojo doesn't have any component requirements.

... removed the other goals ...

----

This option is great for discovering all of a plugin's goals as well as their parameters. But sometimes this is far more information than necessary. To get information about a single goal, set the +mojo+ parameter as well as the +plugin+ parameter. The following command lists all of the information about the Compiler plugin's +compile+ goal.

----
$ mvn help:describe -Dplugin=compiler -Dmojo=compile -Dfull
----

[[configuring]]
== Maven Configuration


=== Configuring Maven Plugins

To customize the behavior of a Maven Plugin, you will need to configure the plugin in a project's POM. The following sections outline the various methods available for customizing a Maven plugin's configuration.

==== Plugin Configuration Parameters

Maven plugins are configured using properties that are defined by goals within a plugin. If you look at a goal like the +compile+ goal in the Maven Compiler Plugin you will see a list of configuration parameters like +source+, +target+, +compilerArgument+, +fork+, +optimize+, and many others. If you look at the +testCompile+ goal you will see a different list of configuration parameters for the +testCompile+ goal. If you are looking for details on the available plugin goal configuration parameters, you can use the Maven Help Plugin to describe a particular plugin or a particular plugin goal.

To describe a particular plugin, use the +help:describe+ goal from the command line as follows:

----
$ mvn help:describe -Dcmd=compiler:compile
[INFO] [help:describe {execution: default-cli}]
[INFO] 'compiler:compile' is a plugin goal (aka mojo).
Mojo: 'compiler:compile'
compiler:compile
Description: Compiles application sources
Deprecated. No reason given
----

For more information about the available configuration parameters, run the same command with the +-Ddetail+ argument:

----
$ mvn help:describe -Dcmd=compiler:compile -Ddetail
[INFO] [help:describe {execution: default-cli}]
[INFO] 'compiler:compile' is a plugin goal (aka mojo).
Mojo: 'compiler:compile'
compiler:compile
Description: Compiles application sources
Deprecated. No reason given
Implementation: org.apache.maven.plugin.CompilerMojo
Language: java
Bound to phase: compile

Available parameters:

compilerArgument
Sets the unformatted argument string to be passed to the compiler if fork
is set to true.

This is because the list of valid arguments passed to a Java compiler
varies based on the compiler version.
Deprecated. No reason given

compilerArguments
Sets the arguments to be passed to the compiler (prepending a dash) if
fork is set to true.

This is because the list of valid arguments passed to a Java compiler
varies based on the compiler version.
Deprecated. No reason given

compilerId (Default: javac)
The compiler id of the compiler to use. See this guide for more
information.
Deprecated. No reason given

compilerVersion
Version of the compiler to use, ex. '1.3', '1.5', if fork is set to true.
Deprecated. No reason given

debug (Default: true)
Set to true to include debugging information in the compiled class files.
Deprecated. No reason given

encoding
The -encoding argument for the Java compiler.
Deprecated. No reason given

excludes
A list of exclusion filters for the compiler.
Deprecated. No reason given

executable
Sets the executable of the compiler to use when fork is true.
Deprecated. No reason given

failOnError (Default: true)
Indicates whether the build will continue even if there are compilation
errors; defaults to true.
Deprecated. No reason given

fork (Default: false)
Allows running the compiler in a separate process. If 'false' it uses the
built in compiler, while if 'true' it will use an executable.
Deprecated. No reason given

includes
A list of inclusion filters for the compiler.
Deprecated. No reason given

maxmem
Sets the maximum size, in megabytes, of the memory allocation pool, ex.
'128', '128m' if fork is set to true.
Deprecated. No reason given

meminitial
Initial size, in megabytes, of the memory allocation pool, ex. '64',
'64m' if fork is set to true.
Deprecated. No reason given

optimize (Default: false)
Set to true to optimize the compiled code using the compiler's
optimization methods.
Deprecated. No reason given

outputFileName
Sets the name of the output file when compiling a set of sources to a
single file.
Deprecated. No reason given

showDeprecation (Default: false)
Sets whether to show source locations where deprecated APIs are used.
Deprecated. No reason given

showWarnings (Default: false)
Set to true to show compilation warnings.
Deprecated. No reason given

source
The -source argument for the Java compiler.
Deprecated. No reason given

staleMillis (Default: 0)
Sets the granularity in milliseconds of the last modification date for
testing whether a source needs recompilation.
Deprecated. No reason given

target
The -target argument for the Java compiler.
Deprecated. No reason given

verbose (Default: false)
Set to true to show messages about what the compiler is doing.
Deprecated. No reason given

----

If you need to get a list of plugin goals which are contained in a plugin, you can run the help:describe goal and pass in the plugin parameter. The plugin parameter accepts a plugin prefix or a +groupId+ and an +artifactId+ for a plugin as shown in the following examples:

----
$ mvn help:describe -Dplugin=compiler
[INFO] [help:describe {execution: default-cli}]
[INFO] org.apache.maven.plugins:maven-compiler-plugin:2.0.2

Name: Maven Compiler Plugin
Description: Maven Plugins
Group Id: org.apache.maven.plugins
Artifact Id: maven-compiler-plugin
Version: 2.0.2
Goal Prefix: compiler

This plugin has 2 goals:

compiler:compile
Description: Compiles application sources
Deprecated. No reason given

compiler:testCompile
Description: Compiles application test sources
Deprecated. No reason given

----

You can use the +groupId+ and the +artifactId+ of the plugin and get the same list of plugin goals.

----
$ mvn help:describe -Dplugin=org.apache.maven.plugins:maven-compiler-plugin

----

Passing the +-Ddetail+ argument to the +help:describe+ goal with the plugin parameter will cause Maven to print out all of the goals and all of the goal parameters for the entire plugin. 

==== Adding Plugin Dependencies

If you need to configure a plugin to use specific versions of dependencies, you can define these dependencies under a dependencies element under plugin. When the plugin executes, it will execute with a classpath that contains these dependencies. <<ex-plugin-dependencies>> is an example of a plugin configuration that overrides default dependency versions and adds new dependencies to facilitate goal execution.

[[ex-plugin-dependencies]]
.Adding Dependencies to a Plugin
----
<plugin>
    <groupId>com.agilejava.docbkx</groupId>
    <artifactId>docbkx-maven-plugin</artifactId>
    <version>2.0.9</version>
    <dependencies>
        <dependency>
            <groupId>docbook</groupId>
            <artifactId>docbook-xml</artifactId>
            <version>4.5</version>
        </dependency>
        <dependency>
            <groupId>org.apache.fop</groupId>
            <artifactId>fop-pdf-images</artifactId>
            <version>1.3</version>
        </dependency>
        <dependency>
            <groupId>org.apache.fop</groupId>
            <artifactId>fop-pdf-images-res</artifactId>
            <version>1.3</version>
            <classifier>res</classifier>
        </dependency>
        <dependency>
            <groupId>pdfbox</groupId>
            <artifactId>pdfbox</artifactId>
            <version>0.7.4-dev</version>
            <classifier>dev</classifier>
        </dependency>
    </dependencies>
</plugin>
----

==== Setting Global Plugin Parameters

To set a value for a plugin configuration parameter in a particular project, use the XML shown in <<ex-config-global-plugin-param>>. Unless this configuration is overridden by a more specific plugin parameter configuration, Maven will use the values defined directly under the +plugin+ element for all goals which are executed in this plugin.

[[ex-config-global-plugin-param]]
.Configuring a Maven Plugin
----
<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-compiler-plugin</artifactId>
    <configuration>
        <source>1.5</source>
        <target>1.5</target>
    </configuration>
</plugin>
----

[[configuring-sect-exec-param]]
==== Setting Execution Specific Parameters

You can configure plugin parameters for specific executions of a plugin goal. <<ex-config-plugin-exec-params>> shows an example of configuration parameters being passed to the execution of the run goal of the AntRun plugin during the validate phase. This specific execution will inherit the configuration parameters from the plugin's configuration element and merge them with the values defined for this particular execution.

[[ex-config-plugin-exec-params]]
.Setting Configuration Parameters in an Execution
----
<plugin>
    <artifactId>maven-antrun-plugin</artifactId>
    <executions>
        <execution>
            <phase>validate</phase>
            <goals>
                <goal>run</goal>
            </goals>
            <configuration>
                <tasks>
                    <echo>${PATH}=${env.PATH}</echo>
                    <echo>User's Home Directory: ${user.home}</echo>
                    <echo>Project's Base Director: ${basedir}</echo>
                </tasks>
            </configuration>
        </execution>
    </executions>
</plugin>
----

==== Setting Default Command Line Execution Parameters

Starting with Maven 2.2.0, you can now supply configuration parameters for goals which are executed from the command-line. To do this, use the special execution id value of "default-cli". <<ex-configure-plugin-default-cli>> shows an example that binds the single goal to the package phase of the lifecycle which produces a binary distribution. This example also configures the +default-cli+ execution for the assembly plugin to use the +jar-with-dependencies+ assembly descriptor. The 'bin.xml' descriptor will be used during the lifecycle, and +jar-with-dependencies+ will be used when you execute +mvn assembly:assembly+ from the command line.

[[ex-configure-plugin-default-cli]]
.Configuring Plugin Parameters for Command Line Execution
----
<plugin>
    <artifactId>maven-assembly-plugin</artifactId>
    <configuration>
        <appendAssemblyId>false</appendAssemblyId>
    </configuration>
    <executions>
        <execution>
            <id>assemble-binary</id>
            <phase>package</phase>
            <goals>
                <goal>single</goal>
            </goals>
            <configuration>
                <descriptors>
                    <descriptor>src/main/assembly/bin.xml</descriptor>
                </descriptors>
            </configuration>
        </execution>
        <execution>
            <id>default-cli</id>
            <configuration>
                <descriptorRefs>
                    <descriptorRef>jar-with-dependencies</descriptorRef>
                </descriptorRefs>
            </configuration>
        </execution>
    </executions>
</plugin>
----

==== Setting Parameters for Goals Bound to Default Lifecycle

Starting with Maven 2.2.0, if you need to customize the behavior of a goal which is already bound to the default lifecycle, you can use the execution id "default-<goal>". You can customize the behavior of the Jar plugin's jar goal which is bound to the package phase in the default lifecycle, and you can customize the configuration parameters of a separate goal execution if you follow the example shown in <<ex-configure-default-param>>.

[[ex-configure-default-param]]
.Setting a Parameter for a Default Goal Execution
----
<plugin>
    <artifactId>maven-jar-plugin</artifactId>
    <executions>
        <execution>
            <id>default-jar</id>
            <configuration>
                <excludes>
                    <exclude>**/somepackage/*</exclude>
                </excludes>
            </configuration>
        </execution>
        <execution>
            <id>special-jar</id>
            <phase>package</phase>
            <goals>
                <goal>jar</goal>
            </goals>
            <configuration>
                <includes>
                    <include>**/sompackage/*</include>
                </includes>
                <classifier>somepackage</classifier>
            </configuration>
        </execution>
    </executions>
</plugin>
----

In this example, the default jar goal is customized to exclude contents in a specific package. Another jar goal is bound to the package phase to create a JAR file which contains only the contents of a particular package in a classified JAR file.

Configuring the default goal execution parameters can also come in handy if you need to configure two goals bound to the default lifecycle with separate settings for the same configuration parameter. <<ex-configure-two-default-param>> shows an example that configures the default resources:resources goal to exclude empty directories while configuring the default resources:testResources goal to include empty directories.

[[ex-configure-two-default-param]]
.Setting Two Default Goal Plugin Configuration Parameters
----
<plugin>
    <artifactId>maven-resources-plugin</artifactId>
    <executions>
        <execution>
            <id>default-resources</id>
            <configuration>
                <includeEmptyDirs>false</includeEmptyDirs>
            </configuration>
        </execution>
        <execution>
            <id>default-testResources</id>
            <configuration>
                <includeEmptyDirs>true</includeEmptyDirs>
            </configuration>
        </execution>
    </executions>
</plugin>
----

[[assemblies]]
== Maven Assemblies

[[assemblies-sect-intro]]
=== Introduction

Maven provides plugins that are used to create the most common archive types, most of which are consumable as dependencies of other projects. Some examples include the JAR, WAR, EJB, and EAR plugins. As discussed in <<lifecycle>> these plugins correspond to different project packaging types each with a slightly different build process. While Maven has plugins and customized lifecycles to support standard packaging types, there are times when you'll need to create an archive or directory with a custom layout. Such custom archives are called Maven Assemblies.

There are any number of reasons why you may want to build custom archives for your project. Perhaps the most common is the project distribution. The word ‘distribution’ means many different things to different people (and projects), depending on how the project is meant to be used. Essentially, these are archives that provide a convenient way for users to install or otherwise make use of the project’s releases. In some cases, this may mean bundling a web application with an application server like Jetty. In others, it could mean bundling API documentation alongside source and compiled binaries like jar files. Assemblies usually come in handy when you are building the final distribution of a product. For example, products like Nexus introduced in http://www.sonatype.com/books/nexus-book/reference/[Repository Management with Nexus], are the product of large multi-module Maven products, and the final archive you download from Sonatype was created using a Maven Assembly.

In most cases, the Assembly plugin is ideally suited to the process of building project distributions. However, assemblies don’t have to be distribution archives; assemblies are intended to provide Maven users with the flexibility they need to produce customized archives of all kinds. Essentially, assemblies are intended to fill the gaps between the standard archive formats provided by project package types. Of course, you could write an entire Maven plugin simply to generate your own custom archive format, along with a new lifecycle mapping and artifact-handling configuration to tell Maven how to deploy it. But the Assembly plugin makes this unnecessary in most cases by providing generalized support for creating your own archive recipe without spending so much time writing Maven code.

[[assemblies-sect-basics]]
=== Assembly Basics

Before we go any further, it’s best to take a minute and talk about the two main goals in the Assembly plugin: +assembly:assembly+, and the +single+ mojo. I list these two goals in different ways because it reflects the difference in how they’re used. The +assembly:assembly+ goal is designed to be invoked directly from the command line, and should never be bound to a build lifecycle phase. In contrast, the +single+ mojo is designed to be a part of your everyday build, and should be bound to a phase in your project’s build lifecycle.

The main reason for this difference is that the +assembly:assembly+ goal is what Maven terms an aggregator mojo; that is, a mojo which is designed to run at most once in a build, regardless of how many projects are being built. It draws its configuration from the root project - usually the top-level POM or the command line. When bound to a lifecycle, an aggregator mojo can have some nasty side-effects. It can force the execution of the +package+ lifecycle phase to execute ahead of time, and can result in builds which end up executing the +package+ phase twice.

Because the +assembly:assembly+ goal is an aggregator mojo, it raises some issues in multi-module Maven builds, and it should only be called as a stand-alone mojo from the command-line. Never bind an +assembly:assembly+ execution to a lifecycle phase. +assembly:assembly+ was the original goal in the Assembly plugin, and was never designed to be part of the standard build process for a project. As it became clear that assembly archives were a legitimate requirement for projects to produce, the +single+ mojo was developed. This mojo assumes that it has been bound to the correct part of the build process, so that it will have access to the project files and artifacts it needs to execute within the lifecycle of a large multi-module Maven project. In a multi-module environment, it will execute as many times as it is bound to the different module POMs. Unlike +assembly:assembly+, +single+ will never force the execution of another lifecycle phase ahead of itself.

The Assembly plugin provides several other goals in addition to these two. However, discussion of these other mojos is beyond the scope of this chapter, because they serve exotic or obsolete use cases, and because they are almost never needed. Whenever possible, you should definitely stick to using +assembly:assembly+ for assemblies generated from the command line, and to +single+ for assemblies bound to lifecycle phases.

[[assemblies-sect-predefined]]
==== Predefined Assembly Descriptors

While many people opt to create their own archive recipes - called assembly descriptors - this isn’t strictly necessary. The Assembly plugin provides built-in descriptors for several common archive types that you can use immediately without writing a line of configuration. The following assembly descriptors are predefined in the Maven Assembly plugin:

+bin+::

   The +bin+ descriptor is used to bundle project 'LICENSE', 'README', and 'NOTICE' files with the project’s main artifact, assuming this project builds a jar as its main artifact. Think of this as the smallest possible binary distribution for completely self-contained projects.  

+jar-with-dependencies+::

   The +jar-with-dependencies+ descriptor builds a JAR archive with the contents of the main project jar along with the unpacked contents of all the project’s runtime dependencies. Coupled with an appropriate +Main-Class+ Manifest entry (discussed in “Plugin Configuration” below), this descriptor can produce a self-contained, executable jar for your project, even if the project has dependencies.  

+project+::

   The +project+ descriptor simply archives the project directory structure as it exists in your file-system and, most likely, in your version control system. Of course, the target directory is omitted, as are any version-control metadata files like the 'CVS' and '.svn' directories we’re all used to seeing. Basically, the point of this descriptor is to create a project archive that, when unpacked, can be built using Maven.  

+src+::

   The +src+ descriptor produces an archive of your project source and 'pom.xml' files, along with any 'LICENSE', 'README', and 'NOTICE' files that are in the project’s root directory. This precursor to the project descriptor produces an archive that can be built by Maven in most cases. However, because of its assumption that all source files and resources reside in the standard 'src' directory, it has the potential to leave out non-standard directories and files that are nonetheless critical to some builds.

[[assemblies-sect-building]]
==== Building an Assembly

The Assembly plugin can be executed in two ways: you can invoke it directly from the command line, or you can configure it as part of your standard build process by binding it to a phase of your project’s build lifecycle. Direct invocation has its uses, particularly for one-off assemblies that are not considered part of your project’s core deliverables. In most cases, you’ll probably want to generate the assemblies for your project as part of its standard build process. Doing this has the effect of including your custom assemblies whenever the project is installed or deployed into Maven’s repositories, so they are always available to your users.

As an example of the direct invocation of the Assembly plugin, imagine that you wanted to ship off a copy of your project which people could build from source. Instead of just deploying the end-product of the build, you wanted to include the source as well. You won’t need to do this often, so it doesn’t make sense to add the configuration to your +POM+. Instead, you can use the following command:

----
$ mvn -DdescriptorId=project assembly:single 
...
[INFO] [assembly:single] 
[INFO] Building tar : /Users/~/mvn-examples-1.0/assemblies/direct-invocation/\
target/direct-invocation-1.0-SNAPSHOT-project.tar.gz 
[INFO] Building tar : /Users/~/mvn-examples-1.0/assemblies/direct-invocation/\
target/direct-invocation-1.0-SNAPSHOT-project.tar.bz2
[INFO] Building zip: /Users/~/mvn-examples-1.0/assemblies/direct-invocation/\
target/direct-invocation-1.0-SNAPSHOT-project.zip
...
----

Imagine you want to produce an executable JAR from your project. If your project is totally self-contained with no dependencies, this can be achieved with the main project artifact using the archive configuration of the JAR plugin. However, most projects have dependencies, and those dependencies must be incorporated in any executable JAR. In this case, you want to make sure that every time the main project JAR is installed or deployed, your executable JAR goes along with it.

Assuming the main class for the project is +org.sonatype.mavenbook.App+, the following POM configuration will create an executable JAR:

.Assembly Descriptor for Executable JAR
----
<project xmlns="http://maven.apache.org/POM/4.0.0" 
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
                             http://maven.apache.org/maven-v4_0_0.xsd">

    <modelVersion>4.0.0</modelVersion>
    <groupId>org.sonatype.mavenbook.assemblies</groupId>
    <artifactId>executable-jar</artifactId>
    <version>1.0-SNAPSHOT</version>
    <packaging>jar</packaging>
    <name>Assemblies Executable Jar Example</name>
    <url>http://sonatype.com/book</url>
    <dependencies>
        <dependency>
            <groupId>commons-lang</groupId>
            <artifactId>commons-lang</artifactId>
            <version>2.4</version>
        </dependency>
    </dependencies>
    <build>
        <plugins>
            <plugin>
                <artifactId>maven-assembly-plugin</artifactId>
                <version>2.2-beta-2</version>
                <executions>
                    <execution>
                        <id>create-executable-jar</id>
                        <phase>package</phase>
                        <goals>
                            <goal>single</goal>
                        </goals>
                        <configuration>
                            <descriptorRefs>
                                <descriptorRef>
                                    jar-with-dependencies
                                </descriptorRef>
                            </descriptorRefs>
                            <archive>
                                <manifest>
                                    <mainClass>org.sonatype.mavenbook.App</mainClass>
                                </manifest>
                            </archive>
                        </configuration>
                    </execution>
                </executions>
            </plugin>
        </plugins>
    </build>
</project>
----

There are two things to notice about the configuration above. First, we’re using the +descriptorRefs+ configuration section instead of the +descriptorId+ parameter we used last time. This allows multiple assembly types to be built from the same Assembly plugin execution, while still supporting our use case with relatively little extra configuration. Second, the +archive+ element under +configuration+ sets the +Main-Class+ manifest attribute in the generated JAR. This section is commonly available in plugins that create JAR files, such as the JAR plugin used for the default project package type.

Now, you can produce the executable JAR simply by executing +mvn package+. Afterward, we’ll also get a directory listing for the target directory, just to verify that the executable JAR was generated. Finally, just to prove that we actually do have an executable JAR, we’ll try executing it:

----
$ mvn package
... (output omitted) ...
[INFO] [jar:jar]
[INFO] Building jar: ~/mvn-examples-1.0/assemblies/executable-jar/target/\
executable-jar-1.0-SNAPSHOT.jar
[INFO] [assembly:single {execution: create-executable-jar}]
[INFO] Processing DependencySet (output=)
[INFO] Building jar: ~/mvn-examples-1.0/assemblies/executable-jar/target/\
executable-jar-1.0-SNAPSHOT-jar-with-dependencies.jar
... (output omitted) ...
$ ls -1 target
... (output omitted) ...
executable-jar-1.0-SNAPSHOT-jar-with-dependencies.jar
executable-jar-1.0-SNAPSHOT.jar
... (output omitted) ...
$ java -jar \
target/executable-jar-1.0-SNAPSHOT-jar-with-dependencies.jar
Hello, World!
----

From the output shown above, you can see that the normal project build now produces a new artifact in addition to the main JAR file. The new one has a classifier of +jar-with-dependencies+. Finally, we verified that the new JAR actually is executable, and that executing the JAR produced the desired output of “Hello, World!” 

[[assemblies-sect-as-depend]]
==== Assemblies as Dependencies

When you generate assemblies as part of your normal build process, those assembly archives will be attached to your main project’s artifact. This means they will be installed and deployed alongside the main artifact, and are then resolvable in much the same way. Each assembly artifact is given the same basic coordinates (+groupId+, +artifactId+, and +version+) as the main project. However, these artifacts are attachments, which in Maven means they are derivative works based on some aspect of the main project build. To provide a couple of examples, +source+ assemblies contain the raw inputs for the project build, and +jar-with-dependencies+ assemblies contain the project’s classes plus its dependencies. Attached artifacts are allowed to circumvent the Maven requirement of one project, one artifact precisely because of this derivative quality.

Since assemblies are (normally) attached artifacts, each must have a classifier to distinguish it from the main artifact, in addition to the normal artifact coordinates. By default, the classifier is the same as the assembly descriptor’s identifier. When using the built-in assembly descriptors, as above, the assembly descriptor’s identifier is generally also the same as the identifier used in the +descriptorRef+ for that type of assembly.

Once you’ve deployed an assembly alongside your main project artifact, how can you use that assembly as a dependency in another project? The answer is fairly straightforward. Projects depend on other projects using a combination of four basic elements, referred to as a project’s coordinates: +groupId+, +artifactId+, +version+, and +packaging+. In <<profiles-sect-platform-classifier>>, multiple platform-specific variants of a project’s artifact are available, and the project specifies a +classifier+ element with a value of either +win+ or +linux+ to select the appropriate dependency artifact for the target platform. Assembly artifacts can be used as dependencies using the required coordinates of a project plus the classifier under which the assembly was installed or deployed. If the assembly is not a JAR archive, we also need to declare its type. 

[[assemblies-sect-assembling-via-depend]]
==== Assembling Assemblies via Assembly Dependencies



[[ex-top-pom-assembly]]
.Configuring the project assembly in top-level POM
----
<project>
    ...
    <build>
        <pluginManagement>
            <plugins>
                <plugin>
                    <artifactId>maven-assembly-plugin</artifactId>
                    <version>2.2-beta-2</version>
                    <executions>
                        <execution>
                            <id>create-project-bundle</id>
                            <phase>package</phase>
                            <goals>
                                <goal>single</goal>
                            </goals>
                            <configuration>
                                <descriptorRefs>
                                    <descriptorRef>project</descriptorRef>
                                </descriptorRefs>
                            </configuration>
                        </execution>
                    </executions>
                </plugin>
            </plugins>
        </pluginManagement>
    </build>
    ...
</project>
----

Each project POM references the managed plugin configuration from <<ex-top-pom-assembly>> using a minimal plugin declaration in its build section shown in <<ex-activating-assembly>>.

[[ex-activating-assembly]]
.Activating the Assembly Plugin Configuration in Child Projects
----
<build>
    <plugins>
        <plugin>
            <artifactId>maven-assembly-plugin</artifactId>
        </plugin>
    </plugins>
</build>
----

To produce the set of project assemblies, run +mvn install+ from the top-level directory. You should see Maven installing artifacts with classifiers in your local repository.

----
$ mvn install
...
Installing ~/mvn-examples-1.0/assemblies/as-dependencies/project-parent/\
second-project/target/second-project-1.0-SNAPSHOT-project.tar.gz to 
~/.m2/repository/org/sonatype/mavenbook/assemblies/second-project/1.0-SNAPSHOT/\
second-project-1.0-SNAPSHOT-project.tar.gz
...
Installing ~/mvn-examples-1.0/assemblies/as-dependencies/project-parent/\
second-project/target/second-project-1.0-SNAPSHOT-project.tar.bz2 to 
~/.m2/repository/org/sonatype/mavenbook/assemblies/second-project/1.0-SNAPSHOT/\
second-project-1.0-SNAPSHOT-project.tar.bz2
...
Installing ~/mvn-examples-1.0/assemblies/as-dependencies/project-parent/\
second-project/target/second-project-1.0-SNAPSHOT-project.zip to 
~/.m2/repository/org/sonatype/mavenbook/assemblies/second-project/1.0-SNAPSHOT/\\
second-project-1.0-SNAPSHOT-project.zip
...
----

When you run install, Maven will copy each project's main artifact and each assembly to your local Maven repository. All of these artifacts are now available for reference as dependencies in other projects locally. If your ultimate goal is to create a bundle which includes assemblies from multiple projects, you can do so by creating another project which will include other project's assemblies as dependencies. This bundling project (aptly named project-bundle) is responsible for creating the bundled assembly. The POM for the bundling project would resemble the XML document listed in <<ex-bundling-pom>>.

[[ex-bundling-pom]]
.POM for the Assembly Bundling Project
----
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
                             http://maven.apache.org/maven-v4_0_0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <groupId>org.sonatype.mavenbook.assemblies</groupId>
    <artifactId>project-bundle</artifactId>
    <version>1.0-SNAPSHOT</version>
    <packaging>pom</packaging>
    <name>Assemblies-as-Dependencies Example Project Bundle</name>
    <url>http://sonatype.com/book</url>
    <dependencies>
        <dependency>
            <groupId>org.sonatype.mavenbook.assemblies</groupId>
            <artifactId>first-project</artifactId>
            <version>1.0-SNAPSHOT</version>
            <classifier>project</classifier>
            <type>zip</type>
        </dependency>
        <dependency>
            <groupId>org.sonatype.mavenbook.assemblies</groupId>
            <artifactId>second-project</artifactId>
            <version>1.0-SNAPSHOT</version>
            <classifier>project</classifier>
            <type>zip</type>
        </dependency>
    </dependencies>
    <build>
        <plugins>
            <plugin>
                <artifactId>maven-assembly-plugin</artifactId>
                <version>2.2-beta-2</version>
                <executions>
                    <execution>
                        <id>bundle-project-sources</id>
                        <phase>package</phase>
                        <goals>
                            <goal>single</goal>
                        </goals>
                        <configuration>
                            <descriptorRefs>
                                <descriptorRef>
                                    jar-with-dependencies
                                </descriptorRef>
                            </descriptorRefs>
                        </configuration>
                    </execution>
                </executions>
            </plugin>
        </plugins>
    </build>
</project>
----

This bundling project's POM references the two assemblies from +first-project+ and +second-project+. Instead of referencing the main artifact of each project, the bundling project's POM specifies a classifier of +project+ and a type of +zip+. This tells Maven to resolve the ZIP archive which was created by the +project+ assembly. Note that the bundling project generates a +jar-with-dependencies+ assembly. +jar-with-dependencies+ does not create a particularly elegant bundle, it simply creates a JAR file with the unpacked contents of all of the dependencies. +jar-with-dependencies+ is really just telling Maven to take all of the dependencies, unpack them, and then create a single archive which includes the output of the current project. In this project, it has the effect of creating a single JAR file that puts the two project assemblies from +first-project+ and +second-project+ side-by-side.

This example illustrates how the basic capabilities of the Maven Assembly plugin can be combined without the need for a custom assembly descriptor. It achieves the purpose of creating a single archive that contains the project directories for multiple projects side-by-side. This time, the +jar-with-dependencies+ is just a storage format, so we don’t need to specify a +Main-Class+ manifest attribute. To build the bundle, we just build the +project-bundle+ project normally:

----
$ mvn package
...
[INFO] [assembly:single {execution: bundle-project-sources}]
[INFO] Processing DependencySet (output=)
[INFO] Building jar: ~/downloads/mvn-examples-1.0/assemblies/as-dependencies/\
project-bundle/target/project-bundle-1.0-SNAPSHOT-jar-with-dependencies.jar

----

To verify that the project-bundle assembly contains the unpacked contents of the assembly dependencies, run +jar tf+:

----
$ jar tf \
target/project-bundle-1.0-SNAPSHOT-jar-with-dependencies.jar
...
first-project-1.0-SNAPSHOT/pom.xml
first-project-1.0-SNAPSHOT/src/main/java/org/sonatype/mavenbook/App.java
first-project-1.0-SNAPSHOT/src/test/java/org/sonatype/mavenbook/AppTest.java
...
second-project-1.0-SNAPSHOT/pom.xml
second-project-1.0-SNAPSHOT/src/main/java/org/sonatype/mavenbook/App.java
second-project-1.0-SNAPSHOT/src/test/java/org/sonatype/mavenbook/AppTest.java
----

After reading this section, the title should make more sense. You've assembled assemblies from two projects into an assembly using a bundling project which has a dependency on each of the assemblies.  

[[assemblies-sect-overview-descriptor]]
=== Overview of the Assembly Descriptor

When the standard assembly descriptors introduced in <<assemblies-sect-basics>> are not adequate, you will need to define your own assembly descriptor. The assembly descriptor is an XML document which defines the structure and contents of an assembly. The assembly descriptor contains five main configuration sections, plus two additional sections: one for specifying standard assembly-descriptor fragments, called component descriptors, and another for specifying custom file processor classes to help manage the assembly-production process.

Base Configuration::

   This section contains the information required by all assemblies, plus some additional configuration options related to the format of the entire archive, such as the base path to use for all archive entries. For the assembly descriptor to be valid, you must at least specify the assembly id, at least one format, and at least one of the other sections shown above.  

File Information::

   The configurations in this segment of the assembly descriptor apply to specific files on the file system within the project’s directory structure. This segment contains two main sections: +files+ and +fileSets+. You use +files+ and +fileSets+ to control the permissions of files in an assembly and to include or exclude files from an assembly.  

Dependency Information::

   Almost all projects of any size depend on other projects. When creating distribution archives, project dependencies are usually included in the end-product of an assembly. This section manages the way dependencies are included in the resulting archive. This section allows you to specify whether dependencies are unpacked, added directly to the 'lib/' directory, or mapped to new file names. This section also allows you to control the permissions of dependencies in the assembly, and which dependencies are included in an assembly.  

Repository Information::

   At times, it’s useful to isolate the sum total of all artifacts necessary to build a project, whether they’re dependency artifacts, POMs of dependency artifacts, or even a project’s own POM ancestry (your parent POM, its parent, and so on). This section allows you to include one or more artifact-repository directory structures inside your assembly, with various configuration options. The Assembly plugin does not have the ability to include plugin artifacts in these repositories yet.  

Module Information::

   This section of the assembly descriptor allows you to take advantage of these parent-child relationships when assembling your custom archive, to include source files, artifacts, and dependencies from your project’s modules. This is the most complex section of the assembly descriptor, because it allows you to work with modules and sub-modules in two ways: as a series of +fileSets+ (via the +sources+ section) or as a series of +dependencySets+ (via the +binaries+ section).

[[assemblies-sect-descriptor]]
=== The Assembly Descriptor

This section is a tour of the assembly descriptor which contains some guidelines for developing a custom assembly descriptor. The Assembly plugin is one of the largest plugins in the Maven ensemble, and one of the most flexible.

[[assemblies-sect-prop-refs]]
==== Property References in Assembly Descriptors

Any property discussed in <<resource-filtering-sect-properties>> can be referenced in an assembly descriptor. Before any assembly descriptor is used by Maven, it is interpolated using information from the POM and the current build environment. All properties supported for interpolation within the POM itself are valid for use in assembly descriptors, including POM properties, POM element values, system properties, user-defined properties, and operating-system environment variables.

The only exceptions to this interpolation step are elements in various sections of the descriptor named +outputDirectory+, +outputDirectoryMapping+, or +outputFileNameMapping+. The reason these are held back in their raw form is to allow artifact- or module-specific information to be applied when resolving expressions in these values, on a per-item basis. <!--This last paragraph is not clear.--> 

[[assemblies-sect-required]]
==== Required Assembly Information

There are two essential pieces of information that are required for every assembly: the +id+, and the list of archive formats to produce. In practice, at least one other section of the descriptor is required - since most archive format components will choke if they don’t have at least one file to include - but without at least one +format+ and an +id+, there is no archive to create. The +id+ is used both in the archive’s file name, and as part of the archive’s artifact classifier in the Maven repository. The format string also controls the archiver-component instance that will create the final assembly archive. All assembly descriptors must contain an +id+ and at least one +format+:

[[ex-required-assembly]]
.Required Assembly Descriptor Elements
----
<assembly>
    <id>bundle</id> 
    <formats>
        <format>zip</format>
    </formats>
    ...
</assembly>
----

The assembly +id+ can be any string that does not contain spaces. The standard practice is to use dashes when you must separate words within the assembly +id+. If you were creating an assembly to create an interesting unique package structure, you would give your an +id+ of something like +interesting-unique-package+. It also supports multiple formats within a single assembly descriptor, allowing you to create the familiar '.zip', '.tar.gz', and '.tar.bz2' distribution archive set with ease. If you don't find the archive format you need, you can also create a custom format. Custom formats are discussed in <<assemblies-sect-componentDescriptors>>. The Assembly plugin supports several archive formats natively, including:

* jar
* zip
* tar
* bzip2
* gzip
* tar.gz
* tar.bz2
* rar
* war
* ear
* sar
* dir

The +id+ and +format+ are essential because they will become a part of the coordinates for the assembled archive. The example from <<ex-required-assembly>> will create an assembly artifact of type +zip+ with a classifier of +bundle+.  

[[assemblies-sect-controlling-contents]]
=== Controlling the Contents of an Assembly

In theory, +id+ and +format+ are the only absolute requirements for a valid assembly descriptor; however, many assembly archivers will fail if they do not have at least one file to include in the output archive. The task of defining the files to be included in the assembly is handled by the five main sections of the assembly descriptor: +files+, +fileSets+, +dependencySets+, +repositories+, and +moduleSets+. To explore these sections most effectively, we’ll start by discussing the most elemental section: +files+. Then, we’ll move on to the two most commonly used sections, +fileSets+ and +dependencySets+. Once you understand the workings of +fileSets+ and +dependencySets+, it’s easier to understand +repositories+ and +moduleSets+.

[[assemblies-sect-files]]
==== +Files+ Section

The +files+ section is the simplest part of the assembly descriptor, it is designed for files that have a definite location relative to your project’s directory. Using this section, you have absolute control over the exact set of files that are included in your assembly, exactly what they are named, and where they will reside in the archive.

[[ex-assembly-files]]
.Including a JAR file in an Assembly using +files+
----
<assembly>
    ...
    <files>
        <file>
            <source>target/my-app-1.0.jar</source>
            <outputDirectory>lib</outputDirectory>
            <destName>my-app.jar</destName>
            <fileMode>0644</fileMode>
        </file>
    </files>
    ...
</assembly>
----

Assuming you were building a project called +my-app+ with a version of +1.0+, <<ex-assembly-files>> would include your project's JAR in the assembly’s 'lib/' directory, trimming the version from the file name in the process so the final file name is simply 'my-app.jar'. It would then make the JAR readable by everyone and writable by the user that owns it (this is what the mode 0644 means for files, using Unix four-digit Octal permission notation). For more information about the format of the value in +fileMode+, please see the Wikipedia's explanation of http://en.wikipedia.org/wiki/File_system_permissions#Octal_notation_and_additional_permissions[four-digit Octal notation].

You could build a very complex assembly using file entries, if you knew the full list of files to be included. Even if you didn’t know the full list before the build started, you could probably use a custom Maven plugin to discover that list and generate the assembly descriptor using references like the one above. While the files section gives you fine-grained control over the permission, location, and name of each file in the assembly archive, listing a +file+ element for every file in a large archive would be a tedious exercise. For the most part, you will be operating on groups of files and dependencies using +fileSets+. The remaining four file-inclusion sections are designed to help you include entire sets of files that match a particular criteria. 

[[assemblies-sect-filesets]]
==== +FileSets+ Section

Similar to the +files+ section, +fileSets+ are intended for files that have a definite location relative to your project’s directory structure. However, unlike the +files+ section, +fileSets+ describe sets of files, defined by file and path patterns they match (or don’t match), and the general directory structure in which they are located. The simplest +fileSet+ just specifies the directory where the files are located:

----
<assembly>
    ...
    <fileSets>
        <fileSet>
            <directory>src/main/java</directory>
        </fileSet>
    </fileSets>
    ...
</assembly>
----

This file set simply includes the contents of the 'src/main/java' directory from our project. It takes advantage of many default settings in the section, so let’s discuss those briefly.

First, you’ll notice that we haven’t told the file set where within the assembly matching files should be located. By default, the destination directory (specified with +outputDirectory+) is the same as the source directory (in our case, 'src/main/java'). Additionally, we haven’t specified any inclusion or exclusion file patterns. When these are empty, the file set assumes that all files within the source directory are included, with some important exceptions. The exceptions to this rule pertain mainly to source-control metadata files and directories, and are controlled by the +useDefaultExcludes+ flag, which is defaulted to +true+. When active, +useDefaultExcludes+ will keep directories like '.svn/' and 'CVS/' from being added to the assembly archive. <<assemblies-sect-default-excludes>> provides a detailed list of the default exclusion patterns.

If we want more control over this file set, we can specify it more explicitly. <<ex-explicit-fileSet>> shows a +fileSet+ element with all of the default elements specified.

[[ex-explicit-fileSet]]
.Including Files with +fileSet+
----
<assembly>
    ...
    <fileSets>
        <fileSet>
            <directory>src/main/java</directory>
            <outputDirectory>src/main/java</outputDirectory>
            <includes>
                <include>**</include>
            </includes>
            <useDefaultExcludes>true</useDefaultExcludes>
            <fileMode>0644</fileMode>
            <directoryMode>0755</directoryMode>
        </fileSet>
    </fileSets>
    ...
</assembly>
----

The +includes+ section uses a list of +include+ elements, which contain path patterns. These patterns may contain wildcards such as ‘**’ which matches one or more directories or ‘*’ which matches part of a file name, and ‘?’ which matches a single character in a file name. <<ex-explicit-fileSet>> uses a +fileMode+ entry to specify that files in this set should be readable by all, but only writable by the owner. Since the +fileSet+ includes directories, we also have the option of specifying a +directoryMode+ that works in much the same way as the +fileMode+. Since a directories’ execute permission is what allows users to list their contents, we want to make sure directories are executable in addition to being readable. Like files, only the owner can write to directories in this set.

The +fileSet+ entry offers some other options as well. First, it allows for an +excludes+ section with a form identical to the +includes+ section. These exclusion patterns allow you to exclude specific file patterns from a +fileSet+. Include patterns take precedence over exclude patterns. Additionally, you can set the +filtering+ flag to true if you want to substitute property values for expressions within the included files. Expressions can be delimited either by '+++${+++' and '+++}+++' (standard Maven expressions like '+++${project.groupId}+++') or by +@+ and +@+ (standard Ant expressions like +@project.groupId@+). You can adjust the line ending of your files using the +lineEnding+ element; valid values for +lineEnding+ are:

keep::

   Preserve line endings from original files. (This is the default value.)  

unix::
  
   Unix-style line endings  

lf::

   Only a Line Feed Character  

dos::

   MS-DOS-style line endings  

crlf::

   Carriage-return followed by a Line Feed   

Finally, if you want to ensure that all file-matching patterns are used, you can use the +useStrictFiltering+ element with a value of +true+ (the default is +false+). This can be especially useful if unused patterns may signal missing files in an intermediary output directory. When +useStrictFiltering+ is set to +true+, the Assembly plugin will fail if an include pattern is not satisfied. In other words, if you have an include pattern which includes a file from a build, and that file is not present, setting +useStrictFiltering+ to +true+ will cause a failure if Maven cannot find the file to be included.

[[assemblies-sect-default-excludes]]
==== Default Exclusion Patterns for

When you use the default exclusion patterns, the Maven Assembly plugin is going to be ignoring more than just SVN and CVS information. By default the exclusion patterns are defined by the http://svn.codehaus.org/plexus/plexus-utils/trunk/src/main/java/org/codehaus/plexus/util/DirectoryScanner.java[DirectoryScanner] class in the http://plexus.codehaus.org/plexus-utils/[plexus-utils] project hosted at Codehaus. The array of exclude patterns is defined as a static, final +String+ array named +DEFAULTEXCLUDES+ in +DirectoryScanner+. The contents of this variable are shown in <<ex-default-excludes>>.

[[ex-default-excludes]]
.Definition of Default Exclusion Patterns from Plexus Utils
----
public static final String[] DEFAULTEXCLUDES = {
// Miscellaneous typical temporary files
"**/*~",
"**/#*#",
"**/.#*",
"**/%*%",
"**/._*",

// CVS
"**/CVS",
"**/CVS/**",
"**/.cvsignore",

// SCCS
"**/SCCS",
"**/SCCS/**",

// Visual SourceSafe
"**/vssver.scc",

// Subversion
"**/.svn",
"**/.svn/**",

// Arch
"**/.arch-ids",
"**/.arch-ids/**",

//Bazaar
"**/.bzr",
"**/.bzr/**",

//SurroundSCM
"**/.MySCMServerInfo",

// Mac
"**/.DS_Store"
};
----

This default array of patterns excludes temporary files from editors like http://www.gnu.org/software/emacs/[GNU Emacs], and other common temporary files from Macs and a few common source control systems (although Visual SourceSafe is more of a curse than a source control system). If you need to override these default exclusion patterns you set +useDefaultExcludes+ to false and then define a set of exclusion patterns in your own assembly descriptor. 

[[assemblies-sect-output-algorithm]]
==== +dependencySets+ Section

One of the most common requirements for assemblies is the inclusion of a project’s dependencies in an assembly archive. Where +files+ and +fileSets+ deal with files in your project, dependency files don't have a location in your project. The artifacts your project depends on have to be resolved by Maven during the build. Dependency artifacts are abstract, they lack a definite location, and are resolved using a symbolic set of Maven coordinates. Since +file+ and +fileSet+ specifications require a concrete source path, dependencies are included or excluded from an assembly using a combination of Maven coordinates and dependency scopes.

The simplest +dependencySet+ is an empty element:

----
<assembly>
    ...
    <dependencySets>
        <dependencySet/>
    </dependencySets>
    ...
</assembly>
----

The +dependencySet+ above will match all runtime dependencies of your project (runtime scope includes the compile scope implicitly), and it will add these dependencies to the root directory of your assembly archive. It will also copy the current project’s main artifact into the root of the assembly archive, if it exists.

NOTE: Wait? I thought +dependencySet+ was about including my project's dependencies, not my project's main archive? This counterintuitive side-effect was a widely-used bug in the 2.1 version of the Assembly plugin, and, because Maven puts an emphasis on backward compatibility, this counterintuitive and incorrect behavior needed to be preserved between a 2.1 and 2.2 release. You can control this behavior by changing the +useProjectArtifact+ flag to +false+. 

While the default dependency set can be quite useful with no configuration whatsoever, this section of the assembly descriptor also supports a wide array of configuration options, allowing your to tailor its behavior to your specific requirements. For example, the first thing you might do to the dependency set above is exclude the current project artifact, by setting the +useProjectArtifact+ flag to +false+ (again, its default value is +true+ for legacy reasons). This will allow you to manage the current project’s build output separately from its dependency files. Alternatively, you might choose to unpack the dependency artifacts using by setting the +unpack+ flag to +true+ (this is +false+ by default). When unpack is set to true, the Assembly plugin will combine the unpacked contents of all matching dependencies inside the archive’s root directory.

From this point, there are several things you might choose to do with this dependency set. The next sections discuss how to define the output location for dependency sets and how include and exclude dependencies by scope. Finally, we’ll expand on the unpacking functionality of the dependency set by exploring some advanced options for unpacking dependencies.

[[assemblies-sect-output-location]]
===== Customizing Dependency Output Location

There are two configuration options that are used in concert to define the location for a dependency file within the assembly archive: +outputDirectory+ and +outputFileNameMapping+. You may want to customize the location of dependencies in your assembly using properties of the dependency artifacts themselves. Let's say you want to put all the dependencies in directories that match the dependency artifact's +groupId+. In this case, you would use the +outputDirectory+ element of the +dependencySet+, and you would supply something like:

----
<assembly>
    ...
    <dependencySets>
        <dependencySet>
            <outputDirectory>${artifact.groupId}</outputDirectory>
        </dependencySet>
    </dependencySets>
    ...
</assembly>
----

This would have the effect of placing every single dependency in a subdirectory that matched the name of each dependency artifact's +groupId+.

If you wanted to perform a further customization and remove the version numbers from all dependencies. You could customize the output file name for each dependency using the +outputFileNameMapping+ element as follows:

----
<assembly>
    ...
    <dependencySets>
        <dependencySet>
            <outputDirectory>${artifact.groupId}</outputDirectory>
            <outputFileNameMapping>
                ${artifact.artifactId}.${artifact.extension} 
            </outputFileNameMapping>
        </dependencySet>
    </dependencySets>
    ...
</assembly>
----

In the previous example, a dependency on +commons:commons-codec+ version 1.3, would end up in the file 'commons/commons-codec.jar'. 

[[assemblies-sect-interpolate]]
===== Interpolation of Properties in Dependency Output

As mentioned in the Assembly Interpolation section above, neither of these elements are interpolated with the rest of the assembly descriptor, because their raw values have to be interpreted using additional, artifact-specific expression resolvers.

The artifact expressions available for these two elements vary only slightly. In both cases, all of the '+++${project.\*}+++', '+++${pom.\*}+++', and '+++${*}+++' expressions that are available in the POM and the rest of the assembly descriptor are also available here. For the +outputFileNameMapping+ element, the following process is applied to resolve expressions:

 . If the expression matches the pattern '+++${artifact.*}+++':
 .. Match against the dependency’s +Artifact+ instance (resolves: +groupId+, +artifactId+, +version+, +baseVersion+, +scope+, +classifier+, and +file.*+) 
 .. Match against the dependency’s +ArtifactHandler+ instance (resolves: +expression+) 
 .. Match against the project instance associated with the dependency’s Artifact (resolves: mainly POM properties)   
. If the expression matches the patterns '+++${pom.\*}+++' or '+++${project.*}+++':
.. Match against the project instance (+MavenProject+) of the current build. 
. If the expression matches the pattern '+++${dashClassifier?}+++' and the Artifact instance contains a non-null classifier, resolve to the classifier preceded by a dash (-classifier). Otherwise, resolve to an empty string. 
.. Attempt to resolve the expression against the project instance of the current build. 
.. Attempt to resolve the expression against the POM properties of the current build. 
.. Attempt to resolve the expression against the available system properties. 
.. Attempt to resolve the expression against the available operating-system environment variables.  

The +outputDirectory+ value is interpolated in much the same way, with the difference being that there is no available '+++${artifact.\*}+++' information, only the '+++${project.*}+++' instance for the particular artifact. Therefore, the expressions listed above associated with those classes (1a, 1b, and 3 in the process listing above) are unavailable.

How do you know when to use +outputDirectory+ and +outputFileNameMapping+? When dependencies are unpacked only the +outputDirectory+ is used to calculate the output location. When dependencies are managed as whole files (not unpacked), both +outputDirectory+ and +outputFileNameMapping+ can be used together. When used together, the result is the equivalent of:

----
<archive-root-dir>/<outputDirectory>/<outputFileNameMapping>
----

When +outputDirectory+ is missing, it is not used. When +outputFileNameMapping+ is missing, its default value is: '+++${artifact.artifactId}-${artifact.version}-${dashClassifier?}.${artifact.extension}+++' 

[[assemblies-sect-include-by-scope]]
===== Including and Excluding Dependencies by Scope

In <<pom-relationships-sect-project-dependencies>>, it was noted that all project dependencies have one scope or another. Scope determines when in the build process that dependency normally would be used. For instance, test-scoped dependencies are not included in the classpath during compilation of the main project sources; but they are included in the classpath when compiling unit test sources. This is because your project’s main source code should not contain any code specific to testing, since testing is not a function of the project (it’s a function of the project’s build process). Similarly, provided-scoped dependencies are assumed to be present in the environment of any eventual deployment. However, if a project depends on a particular provided dependency, it is likely to require that dependency in order to compile. Therefore, provided-scoped dependencies are present in the compilation classpath, but not in the dependency set that should be bundled with the project’s artifact or assembly.

Also from <<pom-relationships-sect-project-dependencies>>, recall that some dependency scopes imply others. For instance, the +runtime+ dependency scope implies the +compile+ scope, since all compile-time dependencies (except for those in the +provided+ scope) will be required for the code to execute. There are a number of complex relationships between the various dependency scopes which control how the scope of a direct dependency affects the scope of a transitive dependency. In a Maven Assembly descriptor, we can use scopes to apply different settings to different sets of dependencies accordingly.

For instance, if we plan to bundle a web application with http://www.mortbay.org/jetty-6/[Jetty] to create a completely self-contained application, we’ll need to include all provided-scope dependencies somewhere in the jetty directory structure we’re including. This ensures those provided dependencies actually are present in the runtime environment. Non-provided, runtime dependencies will still land in the WEB-INF/lib directory, so these two dependency sets must be processed separately. These dependency sets might look similar to the following XML.

.Defining Dependency Sets Using Scope
----
<assembly>
    ...
    <dependencySets>
        <dependencySet>
            <scope>provided</scope>
            <outputDirectory>lib/${project.artifactId}</outputDirectory>
        </dependencySet>
        <dependencySet>
            <scope>runtime</scope>
            <outputDirectory>
                webapps/${webContextName}/WEB-INF/lib
            </outputDirectory>
        </dependencySet>
    </dependencySets>
    ...
</assembly>
----

 Provided-scoped dependencies are added to the 'lib/' directory in the assembly root, which is assumed to be a libraries directory that will be included in the Jetty global runtime classpath. We’re using a subdirectory named for the project’s +artifactId+ in order to make it easier to track the origin of a particular library. Runtime dependencies are included in the 'WEB-INF/lib' path of the web application, which is located within a subdirectory of the standard Jetty 'webapps/' directory that is named using a custom POM property called +webContextName+. What we've done in the previous example is separate application-specific dependencies from dependencies which will be present in a Servlet contains global classpath.

However, simply separating according to scope may not be enough, particularly in the case of a web application. It’s conceivable that one or more runtime dependencies will actually be bundles of standardized, non-compiled resources for use in the web application. For example, consider a set of web application which reuse a common set of Javascript, CSS, SWF, and image resources. To make these resources easy to standardize, it’s a common practice to bundle them up in an archive and deploy them to the Maven repository. At that point, they can be referenced as standard Maven dependencies - possibly with a dependency type of +zip+ - that are normally specified with a runtime scope. Remember, these are resources, not binary dependencies of the application code itself; therefore, it’s not appropriate to blindly include them in the 'WEB-INF/lib' directory. Instead, these resource archives should be separated from binary runtime dependencies, and unpacked into the web application document root somewhere. In order to achieve this kind of separation, we’ll need to use inclusion and exclusion patterns that apply to the coordinates of a specific dependency.

In other words, say you have three or four web application which reuse the same resources and you want to create an assembly that puts provided dependencies into 'lib/', runtime dependencies into 'webapps/<contextName>/WEB-INF/lib', and then unpacks a specific runtime dependency into your web application's document root. You can do this because the Assembly allows you to define multiple include and exclude patterns for a given +dependencySet+ element. Read the next section for more development of this idea.  

[[assemblies-sect-fine-tune]]
===== Fine Tuning: Dependency Includes and Excludes

A resource dependency might be as simple as a set of resources (CSS, Javascript, and Images) in a project that has an assembly which creates a ZIP archive. Depending on the particulars of our web application, we might be able to distinguish resource dependencies from binary dependencies solely according to type. Most web applications are going to depend on other dependencies of type +jar+, and it is possible that we can state with certainty that all dependencies of type +zip+ are resource dependencies. Or, we might have a situation where resources are stored in +jar+ format, but have a classifier of something like +resources+. In either case, we can specify an inclusion pattern to target these resource dependencies and apply different logic than that used for binary dependencies. We’ll specify these tuning patterns using the +includes+ and +excludes+ sections of the +dependencySet+.

Both includes and excludes are list sections, meaning they accept the sub-elements +include+ and +exclude+ respectively. Each +include+ or +exclude+ element contains a string value, which can contain wildcards. Each string value can match dependencies in a few different ways. Generally speaking, three identity pattern formats are supported:

 groupId:artifactId+ - version-less key::

   You would use this pattern to match a dependency by only the groupId and the artifactId  

 +groupId:artifactId:type[:classifier]+ - conflict id::

   The pattern allows you to specify a wider set of coordinates to create a more specific include/exclude pattern.  

 +groupId:artifactId:type[:classifier]:version+ - full artifact identity::

   If you need to get really specific, you can specify all the coordinates.   

All of these pattern formats support the wildcard character ‘*’, which can match any subsection of the identity and is not limited to matching single identity parts (sections between ‘:’ characters). Also, note that the classifier section above is optional, in that patterns matching dependencies that don’t have classifiers do not need to account for the classifier section in the pattern.

In the example given above, where the key distinction is the artifact type zip, and none of the dependencies have classifiers, the following pattern would match resource dependencies assuming that they were of type +zip+:

----

 \*:zip

----

The pattern above makes use of the second dependency identity: the dependency’s conflict id. Now that we have a pattern that distinguishes resource dependencies from binary dependencies, we can modify our dependency sets to handle resource archives differently:

[[ex-complex-dependencySet]]
.Using Dependency Excludes and Includes in +dependencySets+
----
<assembly>
    ...
    <dependencySets>
        <dependencySet>
            <scope>provided</scope>
            <outputDirectory>lib/${project.artifactId}</outputDirectory>
        </dependencySet>
        <dependencySet>
            <scope>runtime</scope>
            <outputDirectory>
                webapps/${webContextName}/WEB-INF/lib
            </outputDirectory>
            <excludes>
                <exclude>*:zip</exclude>
            </excludes>
        </dependencySet>
        <dependencySet>
            <scope>runtime</scope>
            <outputDirectory>
                webapps/${webContextName}/resources
            </outputDirectory>
            <includes>
                <include>*:zip</include>
            </includes>
            <unpack>true</unpack>
        </dependencySet>
    </dependencySets>
    ...
</assembly>
----

In <<ex-complex-dependencySet>>, the runtime-scoped dependency set from our last example has been updated to exclude resource dependencies. Only binary dependencies (non-zip dependencies) should be added to the 'WEB-INF/lib' directory of the web application. Resource dependencies now have their own dependency set, which is configured to include these dependencies in the resources directory of the web application. The +includes+ section in the last +dependencySet+ reverses the exclusion from the previous +dependencySet+, so that resource dependencies are included using the same identity pattern (i.e. +*:zip+). The last +dependencySet+ refers to the shared resource dependency and it is configured to unpack the shared resource dependency in the document root of the web application.

<<ex-complex-dependencySet>> was based upon the assumption that our shared resources project dependency had a type which differed from all of the other dependencies. What if the share resource dependency had the same type as all of the other dependencies? How could you differentiate the dependency? In this case if the shared resource dependency had been bundled as a JAR with the classifier +resources+, you can change to the identity pattern and match those dependencies instead:

----
\*:jar:resources
----

Instead of matching on artifacts with a type of +zip+ and no classifier, we’re matching on artifacts with a classifier of resources and a type of +jar+.

Just like the +fileSets+ section, +dependencySets+ support the +useStrictFiltering+ flag. When enabled, any specified patterns that don’t match one or more dependencies will cause the assembly - and consequently, the build - to fail. This can be particularly useful as a safety valve, to make sure your project dependencies and assembly descriptors are synchronized and interacting as you expect them to. By default, this flag is set to +false+ for the purposes of backward compatibility. 

[[assemblies-sect-transitive]]
===== Transitive Dependencies, Project Attachments, and Project

The +dependencySet+ section supports two more general mechanisms for tuning the subset of matching artifacts: transitive selection options, and options for working with project artifacts. Both of these features are a product of the need to support legacy configurations that applied a somewhat more liberal definition of the word “dependency”. As a prime example, consider the project’s own main artifact. Typically, this would not be considered a dependency; yet older versions of the Assembly plugin included the project artifact in calculations of dependency sets. To provide backward compatibility with this “feature”, the 2.2 releases (currently at 2.2-beta-2) of the Assembly plugin support a flag in the +dependencySet+ called +useProjectArtifact+, whose default value is +true+. By default, dependency sets will attempt to include the project artifact itself in calculations about which dependency artifacts match and which don’t. If you’d rather deal with the project artifact separately, set this flag to +false+.

TIP: The authors of this book recommend that you always set +useProjectArtifact+ to +false+.

As a natural extension to the inclusion of the project artifact, the project’s attached artifacts can also be managed within a +dependencySet+ using the +useProjectAttachments+ flag (whose default value is +false+). Enabling this flag allows patterns that specify classifiers and types to match on artifacts that are “attached” to the main project artifact; that is, they share the same basic +groupId+/+artifactId+/+version+ identity, but differ in +type+ and +classifier+ from the main artifact. This could be useful for including JavaDoc or source jars in an assembly.

Aside from dealing with the project’s own artifacts, it’s also possible to fine-tune the dependency set using two transitive-resolution flags. The first, called +useTransitiveDependencies+ (and set to +true+ by default) simply specifies whether the dependency set should consider transitive dependencies at all when determining the matching artifact set to be included. As an example of how this could be used, consider what happens when your POM has a dependency on another assembly. That assembly (most likely) will have a classifier that separates it from the main project artifact, making it an attachment. However, one quirk of the Maven dependency-resolution process is that the transitive-dependency information for the main artifact is still used when resolving the assembly artifact. If the assembly bundles its project dependencies inside itself, using transitive dependency resolution here would effectively duplicate those dependencies. To avoid this, we simply set +useTransitiveDependencies+ to +false+ for the dependency set that handles that assembly dependency. 

The other transitive-resolution flag is far more subtle. It’s called +useTransitiveFiltering+, and has a default value of +false+. To understand what this flag does, we first need to understand what information is available for any given artifact during the resolution process. When an artifact is a dependency of a dependency (that is, removed at least one level from your own POM), it has what Maven calls a "dependency trail", which is maintained as a list of strings that correspond to the full artifact identities (+groupId:artifactId:type:[classifier:]version+) of all dependencies between your POM and the artifact that owns that dependency trail. If you remember the three types of artifact identities available for pattern matching in a dependency set, you’ll notice that the entries in the dependency trail - the full artifact identity - correspond to the third type. When +useTransitiveFiltering+ is set to +true+, the entries in an artifact’s dependency trail can cause the artifact to be included or excluded in the same way its own identity can.

If you’re considering using transitive filtering, be careful! A given artifact can be included from multiple places in the transitive-dependency graph, but as of Maven 2.0.9, only the first inclusion’s trail will be tracked for this type of matching. This can lead to subtle problems when collecting the dependencies for your project.

WARNING: Most assemblies don’t really need this level of control over dependency sets; consider carefully whether yours truly does. Hint: It probably doesn't.
 
[[assemblies-sect-unpack]]
===== Advanced Unpacking Options

As we discussed previously, some project dependencies may need to be unpacked in order to create a working assembly archive. In the examples above, the decision to unpack or not was simple. It didn’t take into account what needed to be unpacked, or more importantly, what should not be unpacked. To gain more control over the dependency unpacking process, we can configure the +unpackOptions+ element of the +dependencySet+. Using this section, we have the ability to choose which file patterns to include or exclude from the assembly, and whether included files should be filtered to resolve expressions using current POM information. In fact, the options available for unpacking dependency sets are fairly similar to those available for including files from the project directory structure, using the file sets descriptor section.

To continue our web-application example, suppose some of the resource dependencies have been bundled with a file that details their distribution license. In the case of our web application, we’ll handle third-party license notices by way of a 'NOTICES' file included in our own bundle, so we don’t want to include the license file from the resource dependency. To exclude this file, we simply add it to the unpack options inside the dependency set that handles resource artifacts:

.Excluding Files from a Dependency Unpack
----
<asembly>
    ...
    <dependencySets>
        <dependencySet>
            <scope>runtime</scope>
            <outputDirectory>
                webapps/${webContextName}/resources
            </outputDirectory>
            <includes>
                <include>*:zip</include>
            </includes>
            <unpack>true</unpack>
            <unpackOptions>
                <excludes>
                    <exclude>**/LICENSE*</exclude>
                </excludes>
            </unpackOptions>
        </dependencySet>
    </dependencySets>
    ...
</assembly>
----

Notice that the +exclude+ we’re using looks very similar to those used in +fileSet+ declarations. Here, we’re blocking any file starting with the word 'LICENSE' in any directory within our resource artifacts. You can think of the unpack options section as a lightweight +fileSet+ applied to each dependency matched within that dependency set. In other words, it is a +fileSet+ by way of an unpacked dependency. Just as we specified an exclusion pattern for files within resource dependencies in order to block certain files, you can also choose which restricted set of files to include using the includes section. The same code that processes inclusions and exclusions on +fileSets+ has been reused for processing +unpackOptions+.

In addition to file inclusion and exclusion, the unpack options on a dependency set also provides a +filtering+ flag, whose default value is +false+. Again, this should be familiar from our discussion of file sets above. In both cases, expressions using either the Maven syntax of '+++${property}+++' or the Ant syntax of +@property@+ are supported. Filtering is a particularly nice feature to have for dependency sets, though, since it effectively allows you to create standardized, versioned resource templates that are then customized to each assembly as they are included. Once you start mastering the use of filtered, unpacked dependencies which store shared resources, you will be able to start abstracting repeated resources into common resource projects.  

[[assemblies-sect-summarizing]]
===== Summarizing Dependency Sets

Finally, it’s worth mentioning that dependency sets support the same +fileMode+ and +directoryMode+ configuration options that file sets do, though you should remember that the +directoryMode+ setting will only be used when dependencies are unpacked.  

[[assemblies-sect-modulesets]]
==== +moduleSets+ Sections

Multi-module builds are generally stitched together using the parent and modules sections of interrelated POMs. Typically, parent POMs specify their children in a +modules+ section, which under normal circumstances causes the child POMs to be included in the build process of the parent. Exactly how this relationship is constructed can have important implications for the ways in which the Assembly plugin can participate in this process, but we’ll discuss that more later. For now, it’s enough to keep in mind this parent-module relationship as we discuss the +moduleSets+ section.

Projects are stitched together into multi-module builds because they are part of a larger system. These projects are designed to be used together, and single module in a larger build has little practical value on its own. In this way, the structure of the project’s build is related to the way we expect the project (and its modules) to be used. If consider the project from the user's perspective, it makes sense that the ideal end goal of that build would be a single, distributable file that the user can consume directly with minimum installation hassle. Since Maven multi-module builds typically follow a top-down structure, where dependency information, plugin configurations, and other information trickles down from parent to child, it seems natural that the task of rolling all of these modules into a single distribution file should fall to the topmost project. This is where the +moduleSet+ comes into the picture.

Module sets allow the inclusion of resources that belong to each module in the project structure into the final assembly archive. Just like you can select a group of files to include in an assembly using a +fileSet+ and a +dependencySet+, you can include a set of files and resources using a +moduleSet+ to refer to modules in a multi-module build. They achieve this by enabling two basic types of module-specific inclusion: file-based, and artifact-based. Before we get into the specifics and differences between file-based and artifact-based inclusion of module resources into an assembly, let’s talk a little about selecting which modules to process.

[[assemblies-sect-module-selection]]
===== Module Selection

By now, you should be familiar with +includes+/+excludes+ patterns as they are used throughout the assembly descriptor to filter files and dependencies. When you are referring to modules in an assembly descriptor, you will also use the +includes+/+excludes+ patterns to define rules which apply to different sets of modules. The difference in +moduleSet+ +includes+ and +excludes+ is that these rules do not allow for wildcard patterns. (As of the 2.2-beta-2 release, this feature has not really seen much demand, so it hasn’t been implemented.) Instead, each include or exclude value is simply the +groupId+ and +artifactId+ for the module, separated by a colon, like this:

----
groupId:artifactId
----

In addition to +includes+ and +excludes+, the +moduleSet+ also supports an additional selection tool: the +includeSubModules+ flag (whose default value is +true+). The parent-child relationship in any multi-module build structure is not strictly limited to two tiers of projects. In fact, you can include any number of tiers, or layers, in your build. Any project that is a module of a module of the current project is considered a sub-module. In some cases, you may want to deal with each individual module in the build separately (including sub-modules). For example, this is often simplest when dealing with artifact-based contributions from these modules. To do this, you would simply leave the +useSubModules+ flag set to the default of +true+.

When you’re trying to include files from each module’s directory structure, you may wish to process that module’s directory structure only once. If your project directory structure mirrors that of the parent-module relationships that are included in the POMs, this approach would allow file patterns like **/src/main/java to apply not only to that direct module’s project directory, but also to the directories of its own modules as well. In this case you don’t want to process sub-modules directly (they will be processed as subdirectories within your own project’s modules instead), you should set the +useSubModules+ flag to +false+.

Once we’ve determined how module selection should proceed for the module set in question, we’re ready to choose what to include from each module. As mentioned above, this can include files or artifacts from the module project. 

[[assemblies-sect-sources-section]]
===== Sources Section

Suppose you want to include the source of all modules in your project's assembly, but you would like to exclude a particular module. Maybe you have a project named +secret-sauce+ which contains secret and sensitive code that you don't want to distribute with your project. The simplest way to accomplish this is to use a +moduleSet+ which includes each project's directory in '+++${module.basedir.name}+++' and which excludes the +secret-sauce+ module from the assembly.

[[ex-include-exclude-moduleSet]]
.Includes and Excluding Modules with a +moduleSet+
----
<assembly>
    ...
    <moduleSets>
        <moduleSet>
            <includeSubModules>false</includeSubModules>
            <excludes>
                <exclude>
                    com.mycompany.application:secret-sauce
                </exclude>
            </excludes>
            <sources>
                <outputDirectoryMapping>
                    ${module.basedir.name}
                </outputDirectoryMapping>
                <excludeSubModuleDirectories>
                    false
                </excludeSubModuleDirectories>
                <fileSets>
                    <fileSet>
                        <directory>/</directory>
                        <excludes>
                            <exclude>**/target</exclude>
                        </excludes>
                    </fileSet>
                </fileSets>
            </sources>
        </moduleSet>
    </moduleSets>
    ...
</assembly>
----

 In <<ex-include-exclude-moduleSet>>, since we’re dealing with each module’s sources it’s simpler to deal only with direct modules of the current project, handling sub-modules using file-path wildcard patterns in the file set. We set the +includeSubModules+ element to +false+ so we don't have to worry about submodules showing up in the root directory of the assembly archive. The +exclude+ element will take care of excluding the +secret-sauce+ module. We’re not going to include the project sources for the secret-sauce module; they’re, well, secret.

Normally, module sources are included in the assembly under a subdirectory named after the module’s +artifactId+. However, since Maven allows modules that are not in directories named after the module project’s +artifactId+, it’s often better to use the expression '+++${module.basedir.name}+++' to preserve the module directory’s actual name ('+++${module.basedir.name}+++' is the same as calling +MavenProject.getBasedir().getName()+). It is critical to remember that modules are not required to be subdirectories of the project that declares them. If your project has a particularly strange directory structure, you may need to resort to special +moduleSet+ declarations that include specific project and account for your own project's idiosyncrasies.

WARNING: Try to minimize your own project's idiosyncrasies, while Maven is flexible, if you find yourself doing too much configuration there is likely an easier way.

Continuing through <<ex-include-exclude-moduleSet>>, since we’re not processing sub-modules explicitly in this module set, we need to make sure sub-module directories are not excluded from the source directories we consider for each direct module. By setting the +excludeSubModuleDirectories+ flag to +false+, this allows us to apply the same file pattern to directory structures within a sub-module of the one we’re processing. Finally in <<ex-include-exclude-moduleSet>>, we’re not interested in any output of the build process for this module set. We exclude the target/ directory from all modules.

It’s also worth mentioning that the +sources+ section supports +fileSet+-like elements directly within itself, in addition to supporting nested +fileSets+. These configuration elements are used to provide backward compatibility to previous versions of the Assembly plugin (versions 2.1 and under) that didn’t support multiple distinct file sets for the same module without creating a separate module set declaration. They are deprecated, and should not be used.  

[[assemblies-sect-interpolate-modulesets]]
===== Interpolation of +outputDirectoryMapping+ in

In <<assemblies-sect-output-location>>, we used the element +outputDirectoryMapping+ to change the name of the directory under which each module’s sources would be included. The expressions contained in this element are resolved in exactly the same way as the +outputFileNameMapping+, used in dependency sets (see the explanation of this algorithm in <<assemblies-sect-output-algorithm>>).

In <<ex-include-exclude-moduleSet>>, we used the expression '+++${module.basedir.name}+++'. You might notice that the root of that expression, +module+, is not listed in the mapping-resolution algorithm from the dependency sets section; this object root is specific to configurations within +moduleSets+. It works in exactly the same way as the '+++${artifact.*}+++' references available in the +outputFileNameMapping+ element, except it is applied to the module’s +MavenProject+, +Artifact+, and +ArtifactHandler+ instances instead of those from a dependency artifact. 

[[assemblies-sect-binaries]]
===== Binaries section

Just as the +sources+ section is primarily concerned with including a module in its source form, the +binaries+ section is primarily concerned with including the module’s build output, or its artifacts. Though this section functions primarily as a way of specifying +dependencySets+ that apply to each module in the set, there are a few additional features unique to module artifacts that are worth exploring: +attachmentClassifier+ and +includeDependencies+. In addition, the +binaries+ section contains options similar to the +dependencySet+ section, that relate to the handling of the module artifact itself. These are: +unpack+, +outputFileNameMapping+, +outputDirectory+, +directoryMode+, and +fileMode+. Finally, module binaries can contain a +dependencySets+ section, to specify how each module’s dependencies should be included in the assembly archive. First, let’s take a look at how the options mentioned here can be used to manage the module’s own artifacts.

Suppose we want to include the javadoc jars for each of our modules inside our assembly. In this case, we don’t care about including the module dependencies; we just want the javadoc jar. However, since this particular jar is always going to be present as an attachment to the main project artifact, we need to specify which classifier to use to retrieve it. For simplicity, we won’t cover unpacking the module javadoc jars, since this configuration is exactly the same as what we used for dependency sets earlier in this chapter. The resulting module set might look similar to <<ex-include-javadoc-moduleset>>.

[[ex-include-javadoc-moduleset]]
.Including JavaDoc from Modules in an Assembly
----
<assembly>
    ...
    <moduleSets>
        <moduleSet>
            <binaries>
                <attachmentClassifier>javadoc</attachmentClassifier>
                <includeDependencies>false</includeDependencies>
                <outputDirectory>apidoc-jars</outputDirectory>
            </binaries>
        </moduleSet>
    </moduleSets>
    ...
</assembly>
----

In <<ex-include-javadoc-moduleset>>, we don’t explicitly set the +includeSubModules+ flag, since it’s +true+ by default. However, we definitely want to process all modules - even sub-modules - using this module set, since we’re not using any sort of file pattern that could match on sub-module directory structures within. The +attachmentClassifier+ grabs the attached artifact with the javadoc classifier for each module processed. The +includeDependencies+ element tells the Assembly plugin that we're not interested in any of the module's dependencies, just the javadoc attachment. Finally, the +outputDirectory+ element tells the Assembly plugin to put all of the javadoc jars into a directory named 'apidoc-jars/' off of the assembly root directory.

Although we’re not doing anything too complicated in this example, it’s important to understand that the same changes to the expression-resolution algorithm discussed for the +outputDirectoryMapping+ element of the sources section also applies here. That is, whatever was available as '+++${artifact.\*}+++' inside a +dependencySet+’s +outputFileNameMapping+ configuration is also available here as '+++${module.*}+++'. The same applies for +outputFileNameMapping+ when used directly within a +binaries+ section.

Finally, let’s examine an example where we simply want to process the module’s artifact and its runtime dependencies. In this case, we want to separate the artifact set for each module into separate directory structures, according to the module’s +artifactId+ and +version+. The resulting module set is surprisingly simply, and it looks like the listing in <<ex-the-big-include>>:

[[ex-the-big-include]]
.Including Module Artifacts and Dependencies in an Assembly
----
<assembly>
    ...
    <moduleSets>
        <moduleSet>
            <binaries>
                <outputDirectory>
                    ${module.artifactId}-${module.version}
                </outputDirectory>
                <dependencySets>
                    <dependencySet/>
                </dependencySets>
            </binaries>
        </moduleSet>
    </moduleSets>
    ...
</assembly>
----

In <<ex-the-big-include>>, we’re using the empty +dependencySet+ element here, since that should include all runtime dependencies by default, with no configuration. With the +outputDirectory+ specified at the binaries level, all dependencies should be included alongside the module’s own artifact in the same directory, so we don’t even need to specify that in our dependency set.

 For the most part, module binaries are fairly straightforward. In both parts - the main part, concerned with handling the module artifact itself, and the dependency sets, concerned with the module’s dependencies - the configuration options are very similar to those in a dependency set. Of course, the binaries section also provides options for controlling whether dependencies are included, and which main-project artifact you want to use.

Like the sources section, the binaries section contains a couple of configuration options that are provided solely for backward compatibility, and should be considered deprecated. These include the includes and excludes sub-sections. 

[[assemblies-sect-modulesets-parent-pom]]
===== +moduleSets+, Parent POMs

Finally, we close the discussion about module handling with a strong warning. There are subtle interactions between Maven’s internal design as it relates to parent-module relationships and the execution of a module-set’s binaries section. When a POM declares a parent, that parent must be resolved in some way or other before the POM in question can be built. If the parent is in the Maven repository, there is no problem. However, as of Maven 2.0.9 this can cause big problems if that parent is a higher-level POM in the same build, particularly if that parent POM expects to build an assembly using its modules’ binaries.

Maven 2.0.9 sorts projects in a multi-module build according to their dependencies, with a given project’s dependencies being built ahead of itself. The problem is the parent element is considered a dependency, which means the parent project’s build must complete before the child project is built. If part of that parent’s build process includes the creation of an assembly that uses module binaries, those binaries will not exist yet, and therefore cannot be included, causing the assembly to fail. This is a complex and subtle issue, which severely limits the usefulness of the module binaries section of the assembly descriptor. In fact, it has been filed in the bug tracker for the Assembly plugin at: http://jira.codehaus.org/browse/MASSEMBLY-97[http://jira.codehaus.org/browse/MASSEMBLY-97]. Hopefully, future versions of Maven will find a way to restore this functionality, since the parent-first requirement may not be completely necessary.  

[[assemblies-sect-repositories]]
==== Repositories Section

The repositories section represents a slightly more exotic
feature in the assembly descriptor, since few applications other than
Maven can take full advantage of a Maven-repository directory structure.
For this reason, and because many of its features closely resemble those
in the +dependencySets+ section, we won’t spend too
much time on the repositories section of the assembly descriptor. In
most cases, users who understand dependency sets should have no trouble
constructing repositories via the Assembly plugin. We're not going to
motivate the +repositories+ section; we're not going to
go through a the business of setting up a use case and walking you
through the process. We're just going to bring up a few caveats for
those of you who find the need to use the
+repositories+ section.

////
<!--TODO: We probably need to motivate why you would ever want to do this.  Right now, this section
doesn't make sense to new users.-->
////

Having said that, there are a two features particular to the
repositories section that deserve some mention. The first is the
+includeMetadata+ flag. When set to
+true+ it includes metadata such as the list of real
versions that correspond to +-SNAPSHOT+ virtual
versions, and by default it’s set to +false+. At
present, the only metadata included when this flag is
+true+ is the information downloaded from Maven’s
central repository.

The second feature is called
+groupVersionAlignments+. Again, this section is a list
of individual +groupVersionAlignment+ configurations,
whose purpose is to normalize all included artifacts for a particular
+groupId+ to use a single +version+.
Each alignment entry consists of two mandatory elements -
+id+ and +version+ - along with an
optional section called +excludes+ that supplies a list
of +artifactId+ string values which are to be excluded
from this realignment. Unfortunately, this realignment doesn’t seem to
modify the POMs involved in the repository, neither
those related to realigned artifacts nor those that depend on realigned
artifacts, so it’s difficult to imagine what the practical application
for this sort of realignment would be.

In general, it’s simplest to apply the same principles you would
use in dependency sets to repositories when adding them to your assembly
descriptor. While the repositories section does support the above extra
options, they are mainly provided for backward compatibility, and will
probably be deprecated in future releases.

[[assemblies-sect-managing-root]]
==== Managing the Assembly’s Root Directory

Now that we’ve made it through the main body of the assembly descriptor, we can close the discussion of content-related descriptor sections with something lighter: root-directory naming and site-directory handling.

Some may consider it a stylistic concern, but it’s often important to have control over the name of the root directory for your assembly, or whether the root directory is there at all. Fortunately, two configuration options in the root of the assembly descriptor make managing the archive root directory simple: +includeBaseDirectory+ and +baseDirectory+. In cases like executable jar files, you probably don’t want a root directory at all. To skip it, simply set the +includeBaseDirectory+ flag to +false+ (it’s +true+ by default). This will result in an archive that, when unpacked, may create more than one directory in the unpack target directory. While this is considered bad form for archives that are meant to be unpacked before use, it’s not so bad for archives that are consumable as-is.

In other cases, you may want to guarantee the name of the archive root directory regardless of the POM’s version or other information. By default, the +baseDirectory+ element has a value equal to '+++${project.artifactId}-${project.version}+++'. However, we can easily set this element to any value that consists of literal strings and expressions which can be interpolated from the current POM, such as '+++${project.groupId}-${project.artifactId}+++'. This could be very good news for your documentation team! (We all have those, right?)

Another configuration available is the +includeSiteDirectory+ flag, whose default value is +false+. If your project build has also constructed a website document root using the site lifecycle or the Site plugin goals, that output can be included by setting this flag to +true+. However, this feature is a bit limited, since it only includes the +outputDirectory+ from the reporting section of the current POM (by default, 'target/site') and doesn’t take into consideration any site directories that may be available in module projects. Use it if you want, but a good +fileSet+ specification or +moduleSet+ specification with sources configured could serve equally well, if not better. This is yet another example of legacy configuration currently supported by the Assembly plugin for the purpose of backward compatibility. Your mileage may vary. If you really want to include a site that is aggregated from many modules, you'll want to consider using a +fileSet+ or +moduleSet+ instead of setting +includeSiteDirectory+ to +true+. 

[[assemblies-sect-componentDescriptors]]
==== +componentDescriptors+ and

To round out our exploration of the assembly descriptor, we should touch briefly on two other sections: +containerDescriptorHandlers+ and +componentDescriptors+. The +containerDescriptorHandlers+ section refers to custom components that you use to extend the capabilities of the Assembly plugin. Specifically, these custom components allow you to define and handle special files which may need to be merged from the multiple constituents used to create your assembly. A good example of this might be a custom container-descriptor handler that merged 'web.xml' files from constituent war or war-fragment files included in your assembly, in order to create the single web-application descriptor required for you to use the resulting assembly archive as a war file.

The +componentDescriptors+ section allows you to reference external assembly-descriptor fragments and include them in the current descriptor. Component references can be any of the following:

. Relative file paths: 'src/main/assembly/component.xml' 
. Artifact references: +groupId:artifactId:version[:type[:classifier]]+ 
. Classpath resources: '/assemblies/component.xml' 
. URLs: http://www.sonatype.com/component.xml[http://www.sonatype.com/component.xml]  

Incidentally, when resolving a component descriptor, the Assembly plugin tries those different strategies in that exact order. The first one to succeed is used.

Component descriptors can contain many of the same content-oriented sections available in the assembly descriptor itself, with the exception of +moduleSets+, which is considered so specific to each project that it’s not a good candidate for reuse. Also included in a component descriptor is the +containerDescriptorHandlers+ section, which we briefly discussed above. Component descriptors cannot contain formats, assembly id’s, or any configuration related to the base directory of the assembly archive, all of which are also considered unique to a particular assembly descriptor. While it may make sense to allow sharing of the formats section, this has not been implemented as of the 2.2-beta-2 Assembly-plugin release.  

[[assemblies-sect-best-practices]]
=== Best Practices

The Assembly plugin provides enough flexibility to solve many problems in a number of different ways. If you have a unique requirement for your project, there's a good chance that you can use the methods documented in this chapter to achieve almost any assembly structure. This section of the chapter details some common best practices which, if adhered to, will make your experiences with the assembly plugin more productive and less painful.

[[assemblies-sect-standard-reusable]]
==== Standard, Reusable Assembly Descriptors

Up to now, we’ve been talking mainly about one-off solutions for building a particular type of assembly. But what do you do if you have dozens of projects that all need a particular type of assembly? In short, how can we reuse the effort we’ve invested to get our assemblies just the way we like them across more than one project without copying and pasting our assembly descriptor?

The simplest answer is to create a standardized, versioned artifact out of the assembly descriptor, and deploy it. Once that’s done, you can specify that the Assembly plugin section of your project’s POM include the assembly-descriptor artifact as a plugin-level dependency, which will prompt Maven to resolve and include that artifact in the plugin’s classpath. At that point, you can use the assembly descriptor via the +descriptorRefs+ configuration section in the Assembly plugin declaration. To illustrate, consider this example assembly descriptor:

----
<assembly>
    <id>war-fragment</id>
    <formats>
        <format>zip</format>
    </formats>
    <includeBaseDirectory>false</includeBaseDirectory>
    <dependencySets>
        <dependencySet>
            <outputDirectory>WEB-INF/lib</outputDirectory>
        </dependencySet>
    </dependencySets>
    <fileSets>
        <fileSet>
            <directory>src/main/webapp</directory>
            <outputDirectory>/</outputDirectory>
            <excludes>
                <exclude>**/web.xml</exclude>
            </excludes>
        </fileSet>
    </fileSets>
</assembly>
----

Included in your project, this descriptor would be a useful way to bundle the project contents so that it could be unpacked directly into an existing web application in order to add to it (for adding an extending feature, say). However, if your team builds more than one of these web-fragment projects, it will likely want to reuse this descriptor rather than duplicating it. To deploy this descriptor as its own artifact, we’re going to put it in its own project, under the 'src/main/resources/assemblies' directory.

The project structure for this assembly-descriptor artifact will look similar to the following:

----
|-- pom.xml
`-- src
`-- main
`-- resources
`-- assemblies
`-- web-fragment.xml

----

Notice the path of our +web-fragment+ descriptor file. By default, Maven includes the files from the 'src/main/resources' directory structure in the final jar, which means our assembly descriptor will be included with no extra configuration on our part. Also, notice the 'assemblies/' path prefix, the Assembly plugin expects this path prefix on all descriptors provided in the plugin classpath. It’s important that we put our descriptor in the appropriate relative location, so it will be picked up by the Assembly plugin as it executes.

Remember, this project is separate from your actual +web-fragment+ project now; the assembly descriptor has become its own artifact with its own version and, possibly, its own release cycle. Once you install this new project using Maven, you’ll be able to reference it in your +web-fragment+ projects. For clarity, the build process should look something like this:

----
$ mvn install
(...)
[INFO] [install:install]
[INFO] Installing (...)/web-fragment-descriptor/target/\
web-fragment-descriptor-1.0-SNAPSHOT.jar 
to /Users/~/.m2/repository/org/sonatype/mavenbook/assemblies/\
web-fragment-descriptor/1.0-SNAPSHOT/\
web-fragment-descriptor-1.0-SNAPSHOT.jar
[INFO] ---------------------------------------------------------------
[INFO] BUILD SUCCESSFUL
[INFO] ---------------------------------------------------------------
[INFO] Total time: 5 seconds
(...)
----

Since there are no sources for the +web-fragment-descriptor+ project, the resulting jar artifact will include nothing but our +web-fragment+ assembly descriptor. Now, let’s use this new descriptor artifact:

----
<project>
    (...)
    <artifactId>my-web-fragment</artifactId>
    (...)
    <build>
        <plugins>
            <plugin>
                <artifactId>maven-assembly-plugin</artifactId>
                <version>2.2-beta-2</version>
                <dependencies>
                    <dependency>
                        <groupId>org.sonatype.mavenbook.assemblies</groupId>
                        <artifactId>web-fragment-descriptor</artifactId>
                        <version>1.0-SNAPSHOT</version>
                    </dependency>
                </dependencies>
                <executions>
                    <execution>
                        <id>assemble</id>
                        <phase>package</phase>
                        <goals>
                            <goal>single</goal>
                        </goals>
                        <configuration>
                            <descriptorRefs>
                                <descriptorRef>web-fragment</descriptorRef>
                            </descriptorRefs>
                        </configuration>
                    </execution>
                </executions>
            </plugin>
            (...)
        </plugins>
    </build>
    (...)
</project>
----

Two things are special about this Assembly plugin configuration:

* We have to include a plugin-level dependency declaration on our new +web-fragment-descriptor+ artifact in order to have access to the assembly descriptor via the plugin’s classpath. 

* Since we’re using a classpath reference instead of a file in the local project directory structure, we must use the +descriptorRefs+ section instead of the +descriptor+ section. Also, notice that, while the assembly descriptor is actually in the 'assemblies/web-fragment.xml' location within the plugin’s classpath, we reference it without the 'assemblies/' prefix. This is because the Assembly plugin assumes that built-in assembly descriptors will always reside in the classpath under this path prefix.  

Now, you’re free to reuse the POM configuration above in as many projects as you like, with the assurance that all of their web-fragment assemblies will turn out the same. As you need to make adjustments to the assembly format - maybe to include other resources, or to fine-tune the dependency and file sets - you can simply increment the version of the assembly descriptor’s project, and release it again. POMs referencing the assembly-descriptor artifact can then adopt this new version of the descriptor as they are able.

One final point about assembly-descriptor reuse: you may want to consider sharing the plugin configuration itself as well as publishing the descriptor as an artifact. This is a fairly simple step; you simply add the configuration listed above to the +pluginManagement+ section of your parent POM, then reference the managed plugin configuration from your module POM like this:

----
(...)
<build>
    <plugins>
        <plugin>
            <artifactId>maven-assembly-plugin</artifactId>
        </plugin>
        (...)
----

If you’ve added the rest of the plugin’s configuration - listed in the previous example - to the +pluginManagement+ section of the project’s parent POM, then each project inheriting from that parent POM can add a minimal entry like the one above and take advantage of an advanced assembly format in their own builds. 

[[assemblies-set-dist-assemblies]]
==== Distribution (Aggregating) Assemblies

As mentioned above, the Assembly plugin provides multiple ways of creating many archive formats. Distribution archives are typically very good examples of this, since they often combine modules from a multi-module build, along with their dependencies and possibly, other files and artifacts besides these. The distribution aims to include all these different sources into a single archive that the user can download, unpack, and run with convenience. However, we also examined some of the potential drawbacks of using the +moduleSets+ section of the assembly descriptor - namely, that the parent-child relationships between POMs in a build can prevent the availability of module artifacts in some cases.

Specifically, if module POMs reference as their parent the POM that contains the Assembly-plugin configuration, that parent project will be built ahead of the module projects when the multi-module build executes. The parent’s assembly expects to find artifacts in place for its modules, but these module projects are waiting on the parent itself to finish building, a gridlock situation is reached and the parent build cannot succeed (since it’s unable to find artifacts for its module projects). In other words, the child project depends on the parent project which in turn depends on the child project.

As an example, consider the assembly descriptor below, designed to be used from the top-level project of a multi-module hierarchy:

----
<assembly>
    <id>distribution</id>
    <formats>
        <format>zip</format>
        <format>tar.gz</format>
        <format>tar.bz2</format>
    </formats>

    <moduleSets>
        <moduleSet>
            <includes>
                <include>*-web</include>
            </includes>
            <binaries>
                <outputDirectory>/</outputDirectory>
                <unpack>true</unpack>
                <includeDependencies>true</includeDependencies>
                <dependencySets>
                    <dependencySet>
                        <outputDirectory>/WEB-INF/lib</outputDirectory>
                    </dependencySet>
                </dependencySets>
            </binaries>
        </moduleSet>
        <moduleSet>
            <includes>
                <include>*-addons</include>
            </includes>
            <binaries>
                <outputDirectory>/WEB-INF/lib</outputDirectory>
                <includeDependencies>true</includeDependencies>
                <dependencySets>
                    <dependencySet/>
                </dependencySets>
            </binaries>
        </moduleSet>
    </moduleSets>
</assembly>
----

Given a parent project - called app-parent - with three modules called +app-core+, +app-web+, and +app-addons+, notice what happens when we try to execute this multi-module build:

----
$ mvn package
[INFO] Reactor build order: 
[INFO]   app-parent <----- PARENT BUILDS FIRST
[INFO]   app-core
[INFO]   app-web
[INFO]   app-addons
[INFO] ---------------------------------------------------------------
[INFO] Building app-parent
[INFO]task-segment: [package]
[INFO] ---------------------------------------------------------------
[INFO] [site:attach-descriptor]
[INFO] [assembly:single {execution: distro}]
[INFO] Reading assembly descriptor: src/main/assembly/distro.xml
[INFO] ---------------------------------------------------------------
[ERROR] BUILD ERROR
[INFO] ---------------------------------------------------------------
[INFO] Failed to create assembly: Artifact:
org.sonatype.mavenbook.assemblies:app-web:jar:1.0-SNAPSHOT (included by module) 
does not have an artifact with a file. Please ensure the package phase is 
run before the assembly is generated.
...
----

The parent project - +app-parent+ - builds first. This is because each of the other projects lists that POM as its parent, which causes it to be forced to the front of the build order. The +app-web+ module, which is the first module to be processed in the assembly descriptor, hasn’t been built yet. Therefore, it has no artifact associated with it, and the assembly cannot succeed.

One workaround for this is to remove the executions section of the Assembly-plugin declaration, that binds the plugin to the +package+ lifecycle phase in the parent POM, keeping the configuration section intact. Then, execute Maven with two command-line tasks: the first, +package+, to build the multi-module project graph, and a second, +assembly:assembly+, as a direct invocation of the assembly plugin to consume the artifacts built on the previous run, and create the distribution assembly. The command line for such a build might look like this:

----
$ mvn package assembly:assembly
----

However, this approach has several drawbacks. First, it makes the distribution-assembly process more of a manual task that can increase the complexity and potential for error in the overall build process significantly. Additionally, it could mean that attached artifacts - which are associated in memory as the project build executes - are not reachable on the second pass without resorting to file-system references.

Instead of using a +moduleSet+ to collect the artifacts from your multi-module build, it often makes more sense to employ a low-tech approach: using a dedicated distribution project module and inter-project dependencies. In this approach, you create a new module in your build whose sole purpose is to assemble the distribution. This module POM contains dependency references to all the other modules in the project hierarchy, and it configures the Assembly plugin to be bound the +package+ phase of its build lifecycle. The assembly descriptor itself uses the +dependencySets+ section instead of the +moduleSets+ section to collect module artifacts and determine where to include them in the resulting assembly archive. This approach escapes the pitfalls associated with the parent-child relationship discussed above, and has the additional advantage of using a simpler configuration section within the assembly descriptor itself to do the job.

To do this, we can create a new project structure that’s very similar to the one used for the module-set approach above, with the addition of a new distribution project, we might end up with five POMs in total: +app-parent+, +app-core+, +app-web+, +app-addons+, and +app-distribution+. The new +app-distribution+ POM looks similar to the following:

----
<project>
    <parent>
        <artifactId>app-parent</artifactId>
        <groupId>org.sonatype.mavenbook.assemblies</groupId>
        <version>1.0-SNAPSHOT</version>
    </parent>
    <modelVersion>4.0.0</modelVersion>
    <artifactId>app-distribution</artifactId>
    <name>app-distribution</name>

    <dependencies>
        <dependency>
            <artifactId>app-web</artifactId>
            <groupId>org.sonatype.mavenbook.assemblies</groupId>
            <version>1.0-SNAPSHOT</version>
            <type>war</type>
        </dependency>
        <dependency>
            <artifactId>app-addons</artifactId>
            <groupId>org.sonatype.mavenbook.assemblies</groupId>
            <version>1.0-SNAPSHOT</version>
        </dependency>
        <!-- Not necessary since it's brought in via app-web.
             <dependency> [2]
                 <artifactId>app-core</artifactId>
                 <groupId>org.sonatype.mavenbook.assemblies</groupId>
                 <version>1.0-SNAPSHOT</version>
             </dependency>
             -->
    </dependencies>
</project>
----

Notice that we have to include dependencies for the other modules in the project structure, since we don’t have a modules section to rely on in this POM. Also, notice that we’re not using an explicit dependency on +app-core+. Since it’s also a dependency of +app-web+, we don’t need to process it (or, avoid processing it) twice.

Next, when we move the 'distro.xml' assembly descriptor into the +app-distribution+ project, we must also change it to use a +dependencySets+ section, like this:

----
<assembly>
    ...
    <dependencySets>
        <dependencySet>
            <includes>
                <include>*-web</include>
            </includes>
            <useTransitiveDependencies>false</useTransitiveDependencies>
            <outputDirectory>/</outputDirectory>
            <unpack>true</unpack>
        </dependencySet>
        <dependencySet>
            <excludes>
                <exclude>*-web</exclude>
            </excludes>
            <useProjectArtifact>false</useProjectArtifact>
            <outputDirectory>/WEB-INF/lib</outputDirectory>
        </dependencySet>
    </dependencySets>
    ...
</assembly>
----

This time, if we run the build from the top-level project directory, we get better news:

----
$ mvn package
(...)
[INFO] ---------------------------------------------------------------
[INFO] Reactor Summary:
[INFO] ---------------------------------------------------------------
[INFO] module-set-distro-parent ...............SUCCESS [3.070s]
[INFO] app-core .............................. SUCCESS [2.970s]
[INFO] app-web ............................... SUCCESS [1.424s]
[INFO] app-addons ............................ SUCCESS [0.543s]
[INFO] app-distribution ...................... SUCCESS [2.603s]
[INFO] ---------------------------------------------------------------
[INFO] ---------------------------------------------------------------
[INFO] BUILD SUCCESSFUL
[INFO] ---------------------------------------------------------------
[INFO] Total time: 10 seconds
[INFO] Finished at: Thu May 01 18:00:09 EDT 2008
[INFO] Final Memory: 16M/29M
[INFO] ---------------------------------------------------------------
----

As you can see, the dependency-set approach is much more stable and - at least until Maven’s internal project-sorting logic catches up with the Assembly plugin’s capabilities, - involves less opportunity to get things wrong when running a build.  

[[assemblies-sect-summary]]
=== Summary

As we’ve seen in this chapter, the Maven Assembly plugin offers quite a bit of potential for creating custom archive formats. While the details of these assembly archives can be complex, they certainly don’t have to be in all cases - as we saw with built-in assembly descriptors. Even if your aim is to include your project’s dependencies and selected project files in some unique, archived directory structure, writing a custom assembly descriptor doesn’t have to be an arduous task.

Assemblies are useful for a wide array of applications, but are most commonly used as application distributions of various sorts. And, while there are many different ways to use the Assembly plugin, using standardized assembly-descriptor artifacts and avoiding +moduleSets+ when creating distributions containing binaries are two sure ways to avoid problems.  

[[resource-filtering]]
== Properties and Resource Filtering

[[resource-filtering-sect-intro]]
=== Introduction

Throughout this book, you will notice references to properties which can be used in a POM file. Sibling dependencies in a multi-project build can be referenced using the '+++${project.groupId}+++' and '+++${project.version}+++' properties and any part of the POM can be referenced by prefixing the variable name with "project.". Environment variables and Java System properties can be referenced, as well as values from your '~/.m2/settings.xml' file. What you haven't seen yet is an enumeration of the possible property values and some discussion about how they can be used to help you create portable builds. This chapter provides such an enumeration.

If you've been using property references in your POM, you should also know that Maven has a feature called Resource Filtering which allows you to replace property references in any resource files stored under 'src/main/resources'. By default this feature is disabled to prevent accidental replacement of property references. This feature can be used to target builds toward a specific platform and to externalize important build variables to properties files, POMs, or profiles. This chapter introduces the resource filtering feature and provides a brief discussion of how it can be used to create portable enterprise builds. 

[[resource-filtering-sect-properties]]
=== Maven Properties

You can use Maven properties in a 'pom.xml' file or in any resource that is being processed by the Maven Resource plugin's filtering features. A property is always surrounded by '+++${+++' and '+++}+++'. For example, to reference the +project.version+ property, one would write:

----

 1.0
 
----

There are some implicit properties available in any Maven project, these implicit properties are:

+project.*+::

   Maven Project Object Model (POM). You can use the +project.*+ prefix to reference values in a Maven POM.  

+settings.*+::

   Maven Settings. You use the +settings.*+ prefix to reference values from your Maven Settings in '~/.m2/settings.xml'.  

+env.*+::

   Environment variables like +PATH+ and +M2_HOME+ can be referenced using the +env.*+ prefix.  

System Properties::

   Any property which can be retrieved from the +System.getProperty()+ method can be referenced as a Maven property.   

In addition to the implicit properties listed above, a Maven POM, Maven Settings, or a Maven Profile can define a set of arbitrary, user-defined properties. The following sections provide some detail on the various properties available in a Maven project.

[[resource-filtering-sect-project-properties]]
==== Maven Project Properties

When a Maven Project Property is referenced, the property name is referencing a property of the Maven Project Object Model (POM). Specifically, you are referencing a property of the +org.apache.maven.model.Model+ class which is being exposed as the implicit variable +project+. When you reference a property using this implicit variable, you are using simple dot notation to reference a bean property of the +Model+ object. For example, when you reference '+++${project.version}+++', you are really invoking the +getVersion()+ method on the instance of +Model+ that is being exposed as +project+.

The POM is also represented in the 'pom.xml' document present in all Maven projects. Anything in a Maven POM can be referenced with a property. A complete reference for the POM structure is available at http://maven.apache.org/ref/3.0.3/maven-model/maven.html[http://maven.apache.org/ref/3.0.3/maven-model/maven.html]. The following list shows some common property references from the Maven project.

+project.groupId+ and +project.version+::

   Projects in a large, multi-module build often share the same +groupId+ and +version+ identifiers. When you are declaring interdependencies between two modules which share the same +groupId+ and +version+, it is a good idea to use a property reference for both:

----
<dependencies>
    <dependency>
        <groupId>${project.groupId}</groupId>
        <artifactId>sibling-project</artifactId>
        <version>${project.version}</version>
    </dependency>
</dependencies>
----

+project.artifactId+::

   A project's artifactId is often used as the name of a deliverable. For example, in a project with WAR packaging, you will want to generate a WAR file without the version identifiers. To do this, you would reference the +project.artifactId+ in your POM file like this:

----
<build>
    <finalName>${project.artifactId}</finalName>
</build>
----

+project.name+ and +project.description+::

   The name and project description can often be useful properties to reference from documentation. Instead of having to worry that all of your site documents maintain the same short descriptions, you can just reference these properties.  

+project.build.*+::

   If you are ever trying to reference output directories in Maven, you should never use a literal value like 'target/classes'. Instead you should use property references to refer to these directories.

* project.build.sourceDirectory
* project.build.scriptSourceDirectory
* project.build.testSourceDirectory
* project.build.outputDirectory
* project.build.testOutputDirectory
* project.build.directory

+sourceDirectory+, +scriptSourceDirectory+, and +testSourceDirectory+ provide access to the source directories for the project. +outputDirectory+ and +testOutputDirectory+ provide access to the directories where Maven is going to put bytecode or other build output. +directory+ refers to the directory which contains all of these output directories.

+project.baseUri+::

   If you need a valid URI for your project's base directory, you can use the +${project.baseUri}+ property. If your project is stored in the directory '/tmp/simple', +${project.baseUri}+ will resolve to file:/private/tmp/simple/.  

Other Project Property references::

   There are hundreds of properties to reference in a POM. A complete reference for the POM structure is available at http://maven.apache.org/ref/3.0.3/maven-model/maven.html[http://maven.apache.org/ref/3.0.3/maven-model/maven.html].   

For a full list of properties available on the Maven +Model+ object, take a look at the JavaDoc for the +maven-model+ project here http://maven.apache.org/ref/3.0.3/maven-model/apidocs/index.html[http://maven.apache.org/ref/3.0.3/maven-model/apidocs/index.html]. Once you load this JavaDoc, take a look at the +Model+ class. From this +Model+ class JavaDoc, you should be able to navigate to the POM property you wish to reference. If you needed to reference the output directory of the build, you can use the Maven Model JavaDoc to see that the output directory is referenced via +model.getBuild().getOutputDirectory()+; this method call would be translated to the Maven property reference '+++${project.build.outputDirectory}+++'.

For more information about the Maven Model module, the module which defines the structure of the POM, see the Maven Model project page at http://maven.apache.org/ref/3.0.3/maven-model[http://maven.apache.org/ref/3.0.3/maven-model]. 

[[resource-filtering-sect-settings-properties]]
==== Maven Settings Properties

You can also reference any properties in the Maven Local Settings file which is usually stored in '~/.m2/settings.xml'. This file contains user-specific configuration such as the location of the local repository and any servers, profiles, and mirrors configured by a specific user.

A full reference for the Local Settings file and corresponding properties is available here http://maven.apache.org/ref/3.0.3/maven-settings/settings.html[http://maven.apache.org/ref/3.0.3/maven-settings/settings.html]. 

[[resource-filtering-sect-enviroment-variable]]
==== Environment Variable Properties

Environment variables can be referenced with the env.* prefix. Some interesting environment variables are listed in the following list:

+env.PATH+::

   Contains the current +PATH+ in which Maven is running. The +PATH+ contains a list of directories used to locate executable scripts and programs.  

+env.HOME+::

   (On *nix systems) this variable points to a user's home directory. Instead of referencing this, you should use the '+++${user.home}+++'

+env.JAVA_HOME+::

   Contains the Java installation directory. This can point to either a Java Development Kit (JDK) installation or a Java Runtime Environment (JRE). Instead of using this, you should consider referencing the '+++${java.home}+++' property.  

+env.M2_HOME+::

   Contains the Maven 2 installation directory.   

While they are available, you should always use the Java System properties if you have the choice. If you need a user's home directory use '+++${user.home}+++' instead of '+++${env.HOME}+++'. If you do this, you'll end up with a more portable build that is more likely to adhere to the Write-Once-Run-Anywhere (WORA) promise of the Java platform. 

[[resource-filtering-sect-system-properties]]
==== Java System Properties

Maven exposes all properties from +java.lang.System+. Anything you can retrieve from +System.getProperty()+ you can reference in a Maven property. The following table lists available properties:

.Java System Properties
|=========================
| System Property | Description 
| +java.version+ | Java Runtime Environment version
| +java.vendor+ | Java Runtime Environment vendor
| +java.vendor.url+ | Java vendor URL
| +java.home+ | Java installation directory
| +java.vm.specification.version+ | Java Virtual Machine specification version
| +java.vm.specification.vendor+ | Java Virtual Machine specification vendor
| +java.vm.specification.name+ | Java Virtual Machine specification name
| +java.vm.version+ | Java Virtual Machine implementation version
| +java.vm.vendor+ | Java Virtual Machine implementation vendor
| +java.vm.name+ | Java Virtual Machine implementation name
| +java.specification.version+ | Java Runtime Environment specification version
| +java.specification.vendor+ | Java Runtime Environment specification vendor
| +java.specification.name+ | Java Runtime Environment specification name
| +java.class.version+ | Java class format version number
| +java.class.path+ | Java class path
| +java.ext.dirs+ | Path of extension directory or directories
| +os.name+ | Operating system name
| +os.arch+ | Operating system architecture
| +os.version+ | Operating system version
| +file.separator+ | File separator ("/" on UNIX, "\" on Windows)
| +path.separator+ | Path separator (":" on UNIX, ";" on Windows)
| +line.separator+ | Line separator ("\n" on UNIX and Windows)
| +user.name+ | User's account name
| +user.home+ | User's home directory
| +user.dir+ | User's current working 
|=========================

[[resource-filtering-sect-user-defined]]
==== User-defined Properties

In addition to the implicit properties provided by the POM, Maven Settings, environment variables, and the Java System properties, you have the ability to define your own arbitrary properties. Properties can be defined in a POM or in a Profile. The properties set in a POM or in a Maven Profile can be referenced just like any other property available throughout Maven. User-defined properties can be referenced in a POM, or they can be used to filter resources via the Maven Resource plugin. Here's an example of defining some arbitrary properties in a Maven POM.

.User-defined Properties in a POM
----
<project>
    ...
    <properties>
        <arbitrary.property.a>This is some text</arbitrary.property.a>
        <hibernate.version>3.3.0.ga</hibernate.version>
    </properties>
    ...
    <dependencies>
        <dependency>
            <groupId>org.hibernate</groupId>
            <artifactId>hibernate</artifactId>
            <version>${hibernate.version}</version>
        </dependency>  
    </dependencies>
    ...
</project>
----

The previous example defines two properties: +arbitrary.property.a+ and +hibernate.version+. The +hibernate.version+ is referenced in a dependency declaration. Using the period character as a separator in property names is a standard practice throughout Maven POMs and Profiles. The next example shows you how to define a property in a profile from a Maven POM.

.User-defined Properties in a Profile in a POM
----
<project>
    ...
    <profiles>
        <profile>
            <id>some-profile</id>
            <properties>
                <arbitrary.property>This is some text</arbitrary.property>
            </properties>
        </profile>
    </profiles>
    ...
</project>
----

 The previous example demonstrates the process of defining a user-defined property in a profile from a Maven POM. For more information about user-defined properties and profiles, see <<profiles>>.  

[[resource-filtering-sect-description]]
=== Resource Filtering

You can use Maven to perform variable replacement on project resources. When resource filtering is activated, Maven will scan resources for property references surrounded by '+++${+++' and '+++}+++'. When it finds these references it will replace them with the appropriate value in much the same way the properties defined in the previous section can be referenced from a POM. This feature is especially helpful when you need to parameterize a build with different configuration values depending on the target deployment platform.

Often a '.properties' file or an XML document in 'src/main/resources' will contain a reference to an external resource such as a database or a network location which needs to be configured differently depending on the target deployment environment. For example, a system which reads data from a database has an XML document which contains the JDBC URL along with credentials for the database. If you need to use a different database in development and a different database in production. You can either use a technology like JNDI to externalize the configuration from the application in an application server, or you can create a build which knows how to replace variables with different values depending on the target platform.

Using Maven resource filtering you can reference Maven properties and then use Maven profiles to define different configuration values for different target deployment environments. To illustrate this feature, assume that you have a project which uses the Spring Framework to configure a +BasicDataSource+ from the http://commons.apache.org/dbcp[Commons DBCP] project. Your project may contain a file in 'src/main/resources' named 'applicationContext.xml' which contains the XML listed in <<ex-filter-spring>>.

[[ex-filter-spring]]
.Referencing Maven Properties from a Resource
----
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans 
                           http://www.springframework.org/schema/beans/spring-beans-2.5.xsd">

    <bean id="someDao" class="com.example.SomeDao">
        <property name="dataSource" ref="dataSource"/>
    </bean>

    <bean id="dataSource" destroy-method="close" 
          class="org.apache.commons.dbcp.BasicDataSource">
        <property name="driverClassName" value="${jdbc.driverClassName}"/>
        <property name="url" value="${jdbc.url}"/>
        <property name="username" value="${jdbc.username}"/>
        <property name="password" value="${jdbc.password}"/>
    </bean>
</beans>
----

Your program would read this file at runtime, and your build is going to replace the references to properties like +jdbc.url+ and +jdbc.username+ with the values you defined in your pom.xml. Resource filtering is disabled by default to prevent any unintentional resource filtering. To turn on resource filtering, you need to use the +resources+ child element of the build element in a POM. <<ex-filter-pom>> shows a POM which defines the variables referenced in <<ex-filter-spring>> and which activates resource filtering for every resource under 'src/main/resources'.

[[ex-filter-pom]]
.Defining Variables and Activating Resource Filtering
----
<project>
    ...
    <properties>
        <jdbc.driverClassName>
            com.mysql.jdbc.Driver</jdbc.driverClassName>
        <jdbc.url>jdbc:mysql://localhost:3306/development_db</jdbc.url>
        <jdbc.username>dev_user</jdbc.username>
        <jdbc.password>s3cr3tw0rd</jdbc.password>
    </properties>
    ...
    <build>
        <resources>
            <resource>
                <directory>src/main/resources</directory>
                <filtering>true</filtering>
            </resource>
        </resources>
    </build>
    ...
    <profiles>
        <profile>
            <id>production</id>
            <properties>
                <jdbc.driverClassName>oracle.jdbc.driver.OracleDriver</jdbc.driverClassName>
                <jdbc.url>jdbc:oracle:thin:@proddb01:1521:PROD</jdbc.url>
                <jdbc.username>prod_user</jdbc.username>
                <jdbc.password>s00p3rs3cr3t</jdbc.password>
            </properties>
        </profile>  
    </profiles>
</project>
----

The four variables are defined in the +properties+ element, and resource filtering is activated for resources under 'src/main/resources'. Resource filtering is deactivated by default, and to activate it you must explicitly set +filtering+ to +true+ for the resources stored in your project. Filtering is deactivated by default to prevent accidental, unintentional filtering during your build. If you build a project with the resource from <<ex-filter-spring>> and the POM from <<ex-filter-pom>> and if you list the contents of the resource in target/classes, you should see that it contains the filtered resource:

----
$ mvn install
...
$ cat target/classes/applicationContext.xml
...
<bean id="dataSource" destroy-method="close" 
      class="org.apache.commons.dbcp.BasicDataSource">
    <property name="driverClassName" value="com.mysql.jdbc.Driver"/>
    <property name="url" value="jdbc:mysql://localhost:3306/development_db"/>
    <property name="username" value="dev_user"/>
    <property name="password" value="s3cr3tw0rd"/>
</bean>
...
----

The POM in <<ex-filter-pom>> also defines a +production+ profile under the +profiles/profile+ element which overrides the default properties with values that would be appropriate for a production environment. In this particular POM, the default values for the database connection are for a local MySQL database installed on a developer's machine. When the project is built with the production profile activated, Maven will configure the system to connect to a production Oracle database using a different driver class, URL, username, and password. If you build a project with the resource from <<ex-filter-spring>> and the POM from <<ex-filter-pom>> with the +production+ profile activated and if you list the contents of the resource in target/classes, you should see that it contains the filtered resource with production values:

----
$ mvn -Pproduction install
...
$ cat target/classes/applicationContext.xml
...
<bean id="dataSource" destroy-method="close" 
      class="org.apache.commons.dbcp.BasicDataSource">
    <property name="driverClassName" 
              value="oracle.jdbc.driver.OracleDriver"/>
    <property name="url" value="jdbc:oracle:thin:@proddb01:1521:PROD"/>
    <property name="username" value="prod_user"/>
    <property name="password" value="s00p3rs3cr3t"/>
</bean>
...
----

[[site-generation]]
== Site Generation


[[site-generation-sect-intro]]
=== Introduction

Successful software applications are rarely produced by a team of one. When we're talking about any software worth writing, we're usually dealing with teams of collaborating developers ranging anywhere in size from a handful of programmers working in a small team to hundreds or thousands of programmers working in a large distributed environment. Most open source projects (such as Maven) succeed or fail based on the presence or absence of well written documentation for a widely-distributed, ad-hoc collection of users and developers. In all environments it is important for projects to have an easy way to publish and maintain online documentation. Software development is primarily an exercise in collaboration and communication, and publishing a Maven site is one way to make sure that your project is communicating with your end-users.

A web site for an open source project is often the foundation for both the end-user and developer communities alike. End-users look to a project's web site for tutorials, user guides, API documentation, and mailing list archives, and developers look to a project's web site for design documents, code reports, issue tracking, and release plans. Large open-source projects may be integrated with wikis, issue trackers, and continuous integration systems which help to augment a project's online documentation with material that reflects the current status of ongoing development. If a new open source project has an inadequate web site which fails to convey basic information to prospective users, it often is a sign that the project in question will fail to be adopted. In other words, for an open source project, the site and the documentation are as important to the formation of a community as the code itself.

Maven can be used to create a project web site to capture information which is relevant to both the end-user and the developer audience. Out of the box, Maven can generate reports on everything from unit test failures to package coupling to reports on code quality. Maven provides you with the ability to write simple web pages and render those pages against a consistent project template. Maven can publish site content in multiple formats including XHTML and PDF. Maven can be used to generate API documentation and can also be used to embed Javadoc and source code in your project's binary release archive. Once you've used Maven to generate all of your project's end-user and developer documentation, you can then use Maven to publish your web site to a remote server. 

[[site-generation-sect-building]]
=== Building a Project Site with Maven

To illustrate the process of building a project website, create a sample Maven project with the archetype plugin:

----
$ mvn archetype:create -DgroupId=org.sonatype.mavenbook -DartifactId=sample-project

----

This creates the simplest possible Maven project with one Java class in 'src/main/java' and a simple POM. You can then build a Maven site by simply running +mvn site+. To build the site and preview the result in a browser, you can run +mvn site:run+, this will build the site and start an embedded instance of Jetty.

----
$ cd sample-project
$ mvn site:run
[INFO] Scanning for projects...
[INFO] Searching repository for plugin with prefix: 'site'.
[INFO] ------------------------------------------------------------------------
[INFO] Building sample-project
[INFO]task-segment: [site:run] (aggregator-style)
[INFO] ------------------------------------------------------------------------
[INFO] Setting property: classpath.resource.loader.class => 
'org.codehaus.plexus.velocity.ContextClassLoaderResourceLoader'.
[INFO] Setting property: velocimacro.messages.on => 'false'.
[INFO] Setting property: resource.loader => 'classpath'.
[INFO] Setting property: resource.manager.logwhenfound => 'false'.
[INFO] [site:run]
2008-04-26 11:52:26.981::INFO:  Logging to STDERR via org.mortbay.log.StdErrLog
[INFO] Starting Jetty on http://localhost:8080/
2008-04-26 11:52:26.046::INFO:  jetty-6.1.5
2008-04-26 11:52:26.156::INFO:  NO JSP Support for /, did not find 
org.apache.jasper.servlet.JspServlet
2008-04-26 11:52:26.244::INFO:  Started SelectChannelConnector@0.0.0.0:8080

----

Once Jetty starts and is listening to port 8080, you can see the project's site when you go to http://localhost:8080/[http://localhost:8080/] in a web browser. You can see the results in <<fig-simple-site>>.

[[fig-simple-site]]
.Simple Generated Maven Site
image::figs/web/site_index.png[]

If you click around on this simple site, you'll see that it isn't very helpful as a real project site. There's just nothing there (and it doesn't look very good). Since the +sample-project+ hasn't configured any developers, mailing lists, issue tracking providers, or source code repositories, all of these pages on the project site will have no information. Even the index page of the site states, "There is currently no description associated with this project". To customize the site, you'll have to start to add content to the project and to the project's POM.

If you are going to use the Maven Site plugin to build your project's site, you'll want to customize it. You will want to populate some of the important fields in the POM that tell Maven about the people participating in the project, and you'll want to customize the left-hand navigation menu and the links visible in the header of the page. To customize the contents of the site and affect the contents of the left-hand navigation menu, you will need to edit the site descriptor. 

[[site-generation-sect-custom-descript]]
=== Customizing the Site Descriptor

When you add content to the site, you are going to want to modify the left-hand navigation menu that is generated with your site. The following site descriptor customizes the logo in the upper left-hand corner of the site. In addition to customizing the header of the site, this descriptor adds a menu section to the left-hand navigation menu under the heading "Sample Project". This menu contains a single link to an overview page.

.An Initial Site Descriptor
----
<project name="Sample Project">
    <bannerLeft>
        <name>Sonatype</name>
        <src>images/logo.png</src>
        <href>http://www.sonatype.com</href>
    </bannerLeft>
    <body>
        <menu name="Sample Project">
            <item name="Overview" href="index.html"/>  
        </menu>
        <menu ref="reports"/>
    </body>
</project>
----

This site descriptor references one image. This 'logo.png' image should be placed in '+++${basedir}/src/site/resources/images+++'. In addition to the change to the site descriptor, you'll want to create a simple 'index.apt' page in '+++${basedir}/src/site/apt+++'. Put the following content in 'index.apt', it will be transformed to the 'index.html' and serve as the first page a user sees when they come to your project's Maven-generated web site. 

----
  Welcome to the Sample Project, we hope you enjoy your time
on this project site.  We've tried to assemble some 
great user documentation and developer information, and 
we're really excited that you've taken the time to visit
this site.

What is Sample Project

Well, it's easy enough to explain.   This sample project is 
a sample of a project with a Maven-generated site from
Maven: The Definitive	Guide.   A dedicated team of volunteers
help maintain this sample site, and so on and so forth.

----

To preview the site, run +mvn clean site+ followed by +mvn site:run+:

----
$ mvn clean site
$ mvn site:run
----

Once you do this, load the page in a browser by going to http://localhost:8080[http://localhost:8080]. You should see something similar to the screenshot in <<fig-custom-simple>>.

[[fig-custom-simple]]
.Customized Sample Project Web Site
image::figs/web/site_custom-descriptor.png[]

[[site-generation-sect-custom-header]]
==== Customizing the Header Graphics

To customize the graphics which appear in the upper left-hand and right-hand corners of the page, you can use the +bannerLeft+ and +bannerRight+ elements in a site descriptor.

.Adding a Banner Left and Banner Right to Site Descriptor
----
<project name="Sample Project">

    <bannerLeft>
        <name>Left Banner</name>
        <src>images/banner-left.png</src>
        <href>http://www.google.com</href>
    </bannerLeft>

    <bannerRight>
        <name>Right Banner</name>
        <src>images/banner-right.png</src>
        <href>http://www.yahoo.com</href>
    </bannerRight>
    ...
</project>
----

Both the +bannerLeft+ and +bannerRight+ elements take +name+, +src+, and +href+ child elements. In the site descriptor shown above, the Maven Site plugin will generate a site with 'banner-left.png' in the left-hand corner of the page and banner-right in the right-hand corner of the page. Maven is going to look in '+++${basedir}/src/site/resources/images+++' for these images. 

[[site-generation-sect-custom-nav]]
==== Customizing the Navigation Menu

To customize the contents of the navigation menu, use the +menu+ element with +item+ child elements. The +menu+ element adds a section to the left-hand navigation menu. Each item is rendered as a link in that menu.

.Creating Menu Items in a Site Descriptor
----
<project name="Sample Project">
    ...
    <body>

        <menu name="Sample Project">
            <item name="Introduction" href="index.html"/>
            <item name="News" href="news.html"/>
            <item name="Features" href="features.html"/>
            <item name="Installation" href="installation.html"/>
            <item name="Configuration" href="configuration.html"/>
            <item name="FAQ" href="faq.html"/>
        </menu>
        ...
    </body>
</project>
----

Menu items can also be nested. If you nest items, you will be creating a collapsible menu in the left-hand navigation menu. The following example adds a link "Developer Resources" which links to '/developer/index.html'. When a user is looking at the Developer Resources page, the menu items below the Developer Resources menu item will be expanded.

.Adding a Link to the Site Menu
----
<project name="Sample Project">
    ...
    <body>
        ...
        <menu name="Sample Project">
            ...
            <item name="Developer Resources" href="/developer/index.html" 
                  collapse="true">
                <item name="System Architecture" href="/developer/architecture.html"/>
                <item name="Embedder's Guide" href="/developer/embedding.html"/>
            </item>
        </menu>
        ...
    </body>
</project>
----

When an item has the +collapse+ attribute set to +true+, Maven will collapse the item until a user is viewing that specific page. In the previous example, when the user is not looking at the Developer Resources page, Maven will not display the System Architecture and Embedder's Guide links; instead, it will display an arrow pointing to the Developer Resources link. When the user is viewing the Developer Resources page it will show these links with an arrow pointing down.  

[[site-generation-sect-dir-struct]]
=== Site Directory Structure

Maven places all site documents under 'src/site'. Documents of similar format are placed in subdirectories of 'src/site'. All APT documents should be in 'src/site/apt', all FML documents should be in 'src/site/fml', and XDoc documents should be in 'src/site/xdoc'. The site descriptor should be in 'src/site/site.xml', and all resources should be stored under 'src/site/resources'. When the Maven Site plugin builds a web site, it will copy everything in the resources directory to the root of the site. If you store an image in 'src/site/resources/images/test.png', you would refer to the image from your site documentation using the relative path 'images/test.png'.

The following example shows the location of all files in a project which contains APT, FML, HTML, XHTML, and some XDoc. Note that the XHTML content is simply stored in the resources directory. The architecture.html file will not be processed by Doxia, it will simply be copied to the output directory. You can use this approach if you want to include unprocessed HTML content and you don't want to take advantage of the templating and formatting capabilities of Doxia and the Maven Site plugin.

----
sample-project
+- src/
+- site/
+- apt/
|  +- index.apt
|  +- about.apt
|  |
|  +- developer/
| +- embedding.apt
|
+- fml/
|  +- faq.fml
|
+- resources/
|  +- images/
|  |  +- banner-left.png
|  |  +- banner-right.png
|  |
|  +- architecture.html
|  +- jira-roadmap-export-2007-03-26.html
|
+- xdoc/
|  +- xml-example.xml
|
+- site.xml

----

Note that the developer documentation is stored in 'src/site/apt/developer/embedding.apt'. This extra directory below the 'apt' directory will be reflected in the location of the resulting HTML page on the site. When the Site plugin renders the contents of the 'src/site/apt' directory it will produce HTML output in directories relative to the site root. If a file is in the apt directory it will be in the root directory of the generated web site. If a file is in the 'apt/developer' directory it will be generated in the 'developer/' directory of the web site. 

[[site-generation-sect-proj-doc]]
=== Writing Project Documentation

Maven uses a documentation-processing engine called Doxia which reads multiple source formats into a common document model. Doxia can then manipulate documents and render the result into several output formats, such as PDF or XHTML. To write document for your project, you will need to write your content in a format which can be parsed by Doxia. Doxia currently has support for Almost Plain Text (APT), XDoc (a Maven 1.x documentation format), XHTML, and FML (useful for FAQ documents) formats.

This chapter has a cursory introduction to the APT format. For a deeper understand of the APT format, or for an in-depth introduction to XDoc or FML, please see the following resources:

*  APT Reference: http://maven.apache.org/doxia/format.html[http://maven.apache.org/doxia/format.html] 

*  XDoc Reference: http://jakarta.apache.org/site/jakarta-site2.html[http://jakarta.apache.org/site/jakarta-site2.html] 

*  FML Reference: http://maven.apache.org/doxia/references/fml-format.html[http://maven.apache.org/doxia/references/fml-format.html]   

[[site-generation-apt-example]]
==== APT Example

<<ex-apt>> shows a simple APT document with an introductory paragraph and a simple list. Note that the list is terminated by the psuedo-element "[]".

[[ex-apt]]
.APT Document
----
---
Introduction to Sample Project
---
Brian Fox
---
26-Mar-2008
---

Welcome to Sample Project

This is a sample project, welcome!   We're excited that you've decided to 
read the index page of this Sample Project.  We hope you enjoy the simple 
sample project we've assembled for you.

Here are some useful links to get you started:

* {{{news.html}News}}

* {{{features.html}Features}}

* {{{faq.html}FAQ}}


----

If the APT document from <<ex-apt>> were placed in 'src/site/apt/index.apt', the Maven Site plugin will parse the APT using Doxia and produce XHTML content in 'index.html'. 

[[site-generation-sect-fml-example]]
==== FML Example

Many projects maintain a Frequently Asked Questions (FAQ) page. <<ex-fml>> shows an example of an FML document.

[[ex-fml]]
.FAQ Markup Language Document
----
<?xml version="1.0" encoding="UTF-8"?>
<faqs title="Frequently Asked Questions">
    <part id="General">
        <faq id="sample-project-sucks">
            <question>Sample project doesn't work.  Why does sample 
                project suck?</question>
            <answer>
                <p>
                    We resent that question.  Sample wasn't designed to work, it was 
                    designed to show you how to use Maven.   If you really think 
                    this project sucks, then keep it to yourself.   We're not 
                    interested in your pestering questions.
                </p>
            </answer>
        </faq>
        <faq id="sample-project-source">
            <question>I want to put some code in Sample Project, 
                how do I do this?</question>
            <answer>
                <p>
                    If you want to add code to this project, just start putting 
                    Java source in src/main/java.   If you want to put some source 
                    code in this FAQ, use the source element:
                </p>
                <source>
                    for( int i = 0; i < 1234; i++ ) {
                                        // do something brilliant
                                        }
                                        </source>
            </answer>
        </faq>
    </part>
</faqs>
----

[[site-generation-sect-deploy-site]]
=== Deploying Your Project Website

Once your project's documentation has been written and you've creates a site to be proud of, you will want to deploy it to a server. To deploy your site you'll use the Maven Site plugin which can take care of deploying your project's site to a remote server using a number of methods including FTP, SCP, and DAV. To deploy the site using DAV, configure the site entry of the +distributionManagement+ section in the POM, like this:

.Configuring Site Deployment
----
<project>
    ...
    <distributionManagement>
        <site>
            <id>sample-project.website</id>
            <url>dav:https://dav.sample.com/sites/sample-project</url>
        </site>
    </distributionManagement>
    ...
</project>
----

The +url+ in distribution management has a leading indicator +dav+ which tells the Maven Site plugin to deploy the site to a URL that is able to understand WebDAV. Once you have added the +distributionManagement+ section to our +sample-project+ POM, we can try deploying the site:

----
$ mvn clean site-deploy
----

If you have a server configured properly that can understand WebDAV, Maven will deploy your project's web site to the remote server. If you are deploying this project to a site and server visible to the public, you are going to want to configure your web server to access for credentials. If your web server asks for a username and password (or other credentials, you can configure this values in your '~/.m2/settings.xml').

[[site-generation-sect-server-auth]]
==== Configuring Server Authentication

To configure a username/password combination for use during the site deployment, we'll include the following in '$HOME/.m2/settings.xml':

.Storing Server Authentication in User-specific Settings
----
<settings>
    ...
    <servers>
        <server>
            <id>sample-project.website</id>
            <username>jdcasey</username>
            <password>b@dp@ssw0rd</password>
        </server>
        ...
    </servers>
    ...
</settings>
----

The server authentication section can contain a number of authentication elements. In the event you're using SCP for deployment, you may wish to use public-key authentication. To do this, specify the +publicKey+ and+ passphrase+ elements, instead of the password element. You may still want to configure the username element, depending on your server's configuration. 

[[site-generation-sect-modes]]
==== Configuring File and Directory Modes

If you are working in a large group of developers, you'll want to make sure that your web site's files end up with the proper user and group permissions after they are published to the remote server. To configure specific file and directory modes for use during the site deployment, include the following in '$HOME/.m2/settings.xml':


.Configuring File and Directory Modes on Remote Servers
----
<settings>
    ...
    <servers>
        ...
        <server>
            <id>hello-world.website</id>
            ...
            <directoryPermissions>0775</directoryPermissions>
            <filePermissions>0664</filePermissions>
        </server>
    </servers>
    ...
</settings>
----

The above settings will make any directories readable and writable by either the owner or members of the owner's primary group; the anonymous users will only have access to read and list the directory. Similarly, the owner or members of the owner's primary group will have access to read and write any files, with the rest of the world restricted to read-only access.  

[[site-generation-sect-site-appearance]]
=== Customizing Site Appearance

The default Maven template leaves much to be desired. If you wish to customize your project's website beyond simply adding content, navigational elements, and custom logos. Maven offers several mechanisms for customizing your website that offer successively deeper access to content decoration and website structure. For small, per-project tweaks, providing a custom 'site.css' is often enough. However, if you want your customizations to be reusable across multiple projects, or if your customizations involve changing the XHTML that Maven generates, you should consider creating your own Maven website skin.

[[site-generation-sect-site-css]]
==== Customizing the Site CSS

The easiest way to affect the look and feel of your project's web site is through the project's 'site.css'. Just like any images or XHTML content you provide for the website, the 'site.css' file goes in the 'src/site/resources' directory. Maven expects this file to be in the 'src/site/resources/css' subdirectory. With CSS it is possible to change text styling properties, layout properties, and even add background images and custom bullet graphics. For example, if we decided that to make the menu heading stand out a little more, we might try the following style in 'src/site/resources/css/site.css':

----
#navcolumn h5 {
font-size: smaller;
border: 1px solid #aaaaaa;
background-color: #bbb;
margin-top: 7px;
margin-bottom: 2px;
padding-top: 2px;
padding-left: 2px;
color: #000;
}

----

When you regenerate the website, the menu headers should be framed by a gray background and separated from the rest of the menu by some extra margin space. Using this file, any structure in the Maven-generated website can be decorated with custom CSS. When you change 'site.css' in a specific Maven project, the changes will apply to that specific project. If you are interested in making changes that will apply to more than one Maven project, you can create a custom skin for the Maven Site plugin.

TIP: There is no good reference for the structure of the default Maven site template. If you are attempting to customize the style of your Maven project, you should use a Firefox extension like Firebug as a tool to explore the DOM for your project's pages.

[[site-generation-sect-custom-template]]
==== Create a Custom Site Template

If the default Maven Site structure just doesn't do it for you, you can always customize the Maven site template. Customizing the Maven Site template gives you complete control over the ultimate output of the Maven plugin, and it is possible to customize your project's site template to the point where it hardly resembles the structure of a default Maven site template.

The Site plugin uses a rendering engine called Doxia, which in turn uses a Velocity template to render the XHTML for each page. To change the page structure that is rendered by default, we can configure the site plugin in our POM to use a custom page template. The site template is fairly complex, and you'll need to have a good starting point for your customization. Start by copying the default Velocity template from Doxia's Subversion repository http://svn.apache.org/viewvc/maven/doxia/doxia-sitetools/trunk/doxia-site-renderer/src/main/resources/org/apache/maven/doxia/siterenderer/resources/default-site.vm?revision=595592[default-site.vm] to 'src/site/site.vm'. This template is written in a templating language called Velocity. Velocity is a simple templating language which supports simple macro definition and allows you to access an object's methods and properties using simple notation. A full introduction is beyond the scope of this book, for more information about Velocity and a full introduction please go to the Velocity project site at http://velocity.apache.org[http://velocity.apache.org].

The 'default-site.xml' template is fairly involved, but the change required to customize the left-hand menu is relatively straightforward. If you are trying to change the appearance of a +menuItem+, locate the +menuItem+ macro. It resides in a section that looks like this:

----
#macro ( menuItem $item )

...

#end

----

If you replace the macro definition with the macro definition listed below, you will injects Javascript references into each menu item which will allow the reader to expand or collapse the menu tree without suffering through a full page reload:

----
#macro ( menuItem $item $listCount )
#set ( $collapse = "none" )
#set ( $currentItemHref = $PathTool.calculateLink( $item.href, 
$relativePath ) )
#set ( $currentItemHref = $currentItemHref.replaceAll( "\\", "/" ) )

#if ( $item && $item.items && $item.items.size() > 0 )
#if ( $item.collapse == false )
#set ( $collapse = "collapsed" )
#else
## By default collapsed
#set ( $collapse = "collapsed" )
#end

#set ( $display = false )
#displayTree( $display $item )

#if ( $alignedFileName == $currentItemHref || $display )
#set ( $collapse = "expanded" )
#end
#end
<li class="$collapse">
#if ( $item.img )
#if ( ! ( $item.img.toLowerCase().startsWith("http") || 
$item.img.toLowerCase().startsWith("https") ) )
#set ( $src = $PathTool.calculateLink( $item.img, $relativePath ) )
#set ( $src = $item.img.replaceAll( "\\", "/" ) )
<img src="$src"/>
#else
<img src="$item.img" align="absbottom" style="border-width: 0"/>
#end
#end
#if ( $alignedFileName == $currentItemHref )
<strong>$item.name</strong>
#else
#if ( $item && $item.items && $item.items.size() > 0 )
<a onclick="expand('list$listCount')" 
style="cursor:pointer">$item.name</a>
#else
<a href="$currentItemHref">$item.name</a>
#end
#end
#if ( $item && $item.items && $item.items.size() > 0 )
#if ( $collapse == "expanded" )
<ul id="list$listCount" style="display:block">
#else
<ul id="list$listCount" style="display:none">
#end
#foreach( $subitem in $item.items )
#set ( $listCounter = $listCounter + 1 )
#menuItem( $subitem $listCounter )
#end
</ul>
#end
</li>
#end

----

This change adds a new parameter to the +menuItem+ macro. For the new functionality to work, you will need to change references to this macro, or the resulting template may produce unwanted or internally inconsistent XHTML. To finish changing these references, make a similar replacement in the +mainMenu+ macro. Find this macro by looking for something similar to the following template snippet:

----
#macro ( mainMenu $menus )
...
#end

----

Replace the mainMenu macro with the following implementation:

----
#macro ( mainMenu $menus )
#set ( $counter = 0 )
#set ( $listCounter = 0 )
#foreach( $menu in $menus )
#if ( $menu.name )
<h5 onclick="expand('menu$counter')">$menu.name</h5>
#end
<ul id="menu$counter" style="display:block">
#foreach( $item in $menu.items )
#menuItem( $item $listCounter )
#set ( $listCounter = $listCounter + 1 )
#end
</ul>
#set ( $counter = $counter + 1 )
#end
#end

----

This new +mainMenu+ macro is compatible with the new +menuItem+ macro above, and also provides support for a Javascript-enabled top-level menu. Clicking on a top-level menu item with children will expand the menu and allow users to see the entire tree without waiting for a page to load.

The change to the +menuItem+ macro introduced an +expand()+ Javascript function. This method needs to be added to the main XHTML template at the bottom of this template file. Find the section that looks similar to the following:

----
<head>
    ...
    <meta http-equiv="Content-Type" 
          content="text/html; charset=${outputEncoding}" />
    ...
</head>
----

and replace it with this:

----
<head>
    ...
    <meta http-equiv="Content-Type" 
          content="text/html; charset=${outputEncoding}" />
    <script type="text/javascript">
        function expand( item ) {
        var expandIt = document.getElementById( item );
        if( expandIt.style.display == "block" ) {
        expandIt.style.display = "none";
        expandIt.parentNode.className = "collapsed";
        } else {
        expandIt.style.display = "block";
        expandIt.parentNode.className = "expanded";
        }
        }
    </script>
    #if ( $decoration.body.head )
    #foreach( $item in $decoration.body.head.getChildren() )
    #if ( $item.name == "script" )
    $item.toUnescapedString()
    #else
    $item.toString()
    #end
    #end
    #end
</head>
----

After modifying the default site template, you'll need to configure your project's POM to reference this new site template. To customize the site template, you'll need to use the +templateDirectory+ and template configuration properties of the Maven Site plugin.

.Customizing the Page Template in a Project's POM
----
<project>
    ...
    <build>
        <plugins>
            <plugin>
                <artifactId>maven-site-plugin</artifactId>
                <configuration>
                    <templateDirectory>src/site</templateDirectory>
                    <template>site.vm</template>
                </configuration>
            </plugin>
        </plugins>
    </build>
    ...
</project>
----

Now, you should be able to regenerate your project website. When you do so you may notice that the resources and CSS for the maven site are missing. When a Maven project customizes the site template, the Site plugin expects the project to supply all of the default images and CSS. To seed your project's resources, you may want to copy the resources from the default Doxia site renderer project to your own project's resources directory by executing the following commands:

----
$ svn co \
      http://svn.apache.org/repos/asf/maven/doxia/doxia-sitetools/\
      trunk/doxia-site-renderer
$ rm \
      doxia-site-renderer/src/main/resources/org/apache/maven/\
      doxia/siterenderer/resources/css/maven-theme.cs+
$ cp -rf \
      doxia-site-renderer/src/main/resources/org/apache/maven/\
      doxia/siterenderer/resources/* \
      sample-project/src/site/resources
----

Check out the +doxia-site-renderer+ project, remove the default 'maven-theme.css' file and then copy all the resources to your project's 'src/site/resources' directory.

When you regenerate the site, you'll notice that a few menu items look like regular unstyled text. This is caused by a quirky interaction between the site's CSS and our new custom page template. It can be fixed by modifying our 'site.css' to restore the proper link color for these menus. Simply add this:

----
li.collapsed, li.expanded, a:link {
    color:#36a;
}
----

After regenerating the site, the menu's link color should be corrected. If you applied the new site template to the same sample-project from this chapter, you'll notice that the menu now consists of a tree. Clicking on "Developer Resources" no longer takes you to the "Developer Resources" page; in stead, it expands the sub-menu. Since you've turned the Developer Resources menu-item into a dynamically-folding sub-menu, you have lost the ability to reach the 'developer/index.apt' page. To address this change, you should add an Overview link to the sub-menu which references the same page:

.Adding a Menu Item to a Site Descriptor
----
<project name="Hello World">
    ...
    <menu name="Main Menu">
        ...
        <item name="Developer Resources" collapse="true">
            <item name="Overview" href="/developer/index.html"/>
            <item name="System Architecture" href="/developer/architecture.html"/>
            <item name="Embedder's Guide" href="/developer/embedding.html"/>
        </item>
    </menu>
    ...
</project>
----

[[site-generation-sect-reusable-skin]]
==== Reusable Website Skins

If your organization is creating many Maven project sites, you will likely want to reuse site template and CSS customizations throughout an organization. If you want thirty projects to share the same CSS and site template, you can use Maven's support for skinning. Maven Site skins allow you to package up resources and templates which can be reused by other projects in lieu of duplicating your site template for each project which needs to be customized.

While you can define your own skin, you may want to consider using one of Maven's alternate skins. You can choose from several skins. These each provide their own layout for navigation, content, logos, and templates:

*  Maven Classic Skin - +org.apache.maven.skins:maven-classic-skin:1.0+ 

*  Maven Default Skin - +org.apache.maven.skins:maven-default-skin:1.0+ 

*  Maven Stylus Skin - org.apache.maven.skins:maven-stylus-skin:1.0.1  

You can find an up-to-date and comprehensive listing in the Maven repository: http://repo1.maven.org/maven2/org/apache/maven/skins/[http://repo1.maven.org/maven2/org/apache/maven/skins/].

Creating a custom skin is a simple matter of wrapping your customized 'maven-theme.css' in a Maven project, so that it can be referenced by +groupId+, +artifactId+, and +version+. It can also include resources such as images, and a replacement website template (written in Velocity) that can generate a completely different XHTML page structure. In most cases, custom CSS can manage the changes you desire. To demonstrate, let's create a designer skin for the sample-project project, starting with a custom 'maven-theme.css'.

Before we can start writing our custom CSS, we need to create a separate Maven project to allow the +sample-project+ site descriptor to reference it. First, use Maven's archetype plugin to create a basic project. Issue the following command from the directory above the +sample-project+ project's root directory:

----
$ mvn archetype:create -DartifactId=sample-site-skin 
      -DgroupId=org.sonatype.mavenbook
----

This will create a project (and a directory) called +sample-site-skin+. Change directories to the new +sample-site-skin+ directory, remove all of the source code and tests, and create a directory to store your skin's resources:

----
$ cd sample-site-skin
$ rm -rf src/main/java src/test
$ mkdir src/main/resources
----

[[site-generation-sect-custom-theme-css]]
==== Creating a Custom Theme CSS

Next, write a custom CSS for the custom skin. A custom CSS stylesheet in a Maven site skin should be placed in 'src/main/resources/css/maven-theme.css'. Unlike the 'site.css' file, which goes in the site-specific source directory for a project, the 'maven-theme.css' will be bundled in a JAR artifact in your local Maven repository. In order for the maven-theme.css file to be included in the skin's JAR file, it must reside in the main project-resources directory, 'src/main/resources'.

As with the default the default site template, you will want to start customizing your new skin's CSS from a good starting point. Copy the CSS file used by the default Maven skin to your project's 'maven-theme.css'. To get a copy of this theme file, save the contents of http://svn.apache.org/viewvc/maven/skins/trunk/maven-default-skin/src/main/resources/css/maven-theme.css?view=co[maven-theme.css] from the +maven-default-skin+ project to 'src/main/resources/css/maven-theme.css' in our new skin project.

Now that we have the base theme file in place, customize it using the CSS from our old site.css file. Replace the +#navcolumn h5+ CSS block with the following:

----
#navcolumn h5 {
font-size: smaller;
border: 1px solid #aaaaaa;
background-color: #bbb;
margin-top: 7px;
margin-bottom: 2px;
padding-top: 2px;
padding-left: 2px;
color: #000;
}

----

Once you've customized the 'maven-theme.css', build and install the +sample-site-skin+ JAR artifact to your local Maven repository by running:

----
$ mvn clean install

----

Once the installation is complete, switch back to the 'sample-project' project directory, if you already customized the 'site.css' earlier in this chapter, move 'site.css' to 'site.css.bak' so it no longer affects the output of the Maven Site plugin:

----
$ mv src/site/resources/css/site.css src/site/resources/css/site.css.bak

----

To use the +sample-site-skin+ in the +sample-project+ site, you'll need to add a reference to the +sample-site-skin+ artifact in the +sample-project+'s site descriptor. A site references a skin in the site descriptor using the skin element:

.Configuring a Custom Site Skin in Site Descriptor
----
<project name="Sample Project">
    ...
    <skin>
        <groupId>org.sonatype.mavenbook</groupId>
        <artifactId>sample-site-skin</artifactId>
    </skin>
    ...
</project>
----

You can think of a Maven Site skin as a site dependency. Site skins are referenced as artifacts with a groupId and an artifactId. Using a site skin allows you to consolidate site customizations to a single project, and makes reusing custom CSS and site templates as easy as reusing build logic through a custom Maven plugin.  

[[site-generation-sect-tips-tricks]]
=== Tips and Tricks

This section lists some useful tips and tricks you can use when creating a Maven site.

[[site-generation-sect-inject-xhtml]]
==== Inject XHTML into HEAD

To inject XHTML into the HEAD element, add a head element to the body element in your project's Site descriptor. The following example adds a feed link to every page in the +sample-project+ web site.

.Injecting HTML into the HEAD element
----
<project name="Hello World">
    ...
    <body>
        <head>
            <link href="http://sample.com/sites/sample-project/feeds/blog"
                  type="application/atom+xml" 
                  id="auto-discovery" 
                  rel="alternate" 
                  title="Sample Project Blog" />
        </head>
        ...
    </body>
</project>
----

[[site-generation-sect-add-links]]
==== Add Links under Your Site Logo

If you are working on a project which is being developed by an organization, you may want to add links under your project's logo. Assume that your project is a part of the Apache Software Foundation, you might want to add a link to the Apache Software Foundation web site right below your logo, and you might want to add a link to a parent project as well. To add links below your site logo, just add a links element to the body element in the Site descriptor. Each item element in the links element will be rendered as a link in a bar directly below your project's logo. The following example would add a link to the Apache Software Foundation followed by a link to the Apache Maven project.

.Adding Links Under Your Site Logo
----
<project name="Hello World">
    ...
    <body>
        ...
        <links>
            <item name="Apache" href="http://www.apache.org"/>
            <item name="Maven" href="http://maven.apache.org"/>
        </links>
        ...
    </body>
</project>
----

[[site-generation-add-breadcumbs]]
==== Add Breadcrumbs to Your Site

If your hierarchy exists within a logical hierarchy, you may want to place a series of breadcrumbs to give the user a sense of context and give them a way to navigate up the tree to projects which might contain the current project as a subproject. To configure breadcrumbs, add a +breadcrumbs+ element to the +body+ element in the site descriptor. Each +item+ element will render a link, and the items in the +breadcrumbs+ element will be rendered in order. The breadcrumb items should be listed from highest level to lowest level. In the following site descriptor, the Codehaus item would be seen to contain the Mojo item.

.Configuring the Site's Breadcrumbs
----
<project name="Sample Project">
    ...
    <body>
        ...
        <breadcrumbs>
            <item name="Codehaus" href="http://www.codehaus.org"/>
            <item name="Mojo" href="http://mojo.codehaus.org"/>
        </breadcrumbs>
        ...
    </body>
</project>
----


[[site-generation-sect-add-project-version]]
==== Add the Project Version

When you are documenting a project that has multiple versions, it is often very helpful to list the project's version number on every page. To display your project's version on the website, simply add the +version+ element to your site descriptor:

.Positioning the Version Information
----
<project name="Sample Project">
    ...
    <version position="left"/>
    ...
</project>
----

This will position the version (in the case of the sample-project project, it will say "Version: 1.0-SNAPSHOT") in the upper left-hand corner of the site, right next to the default "Last Published" date. Valid positions for the project version are:

left::

   Left side of the bar just below the site logo  

right::

   Right side of the bar just below the site logo  

navigation-top::

   Top of the menu  

navigation-bottom::

   Bottom of the menu  

none::

   Suppress the version entirely

[[site-generation-sect-mod-pubdate]]
==== Modify the Publication Date Format and Location

In some cases, you may wish to reformat or reposition the "Last Published" date for your project website. Just like the project version tip above, you can specify the position of the publication date by using one of the following:

left::

   Left side of the bar just below the site logo  

right::

   Right side of the bar just below the site logo  

navigation-top::

   Top of the menu  

navigation-bottom::

   Bottom of the menu  

none::

   Suppress the publication entirely   

.Positioning the Publish Date
----
<project name="Sample Project">
    ...
    <publishDate position="navigation-bottom"/>
    ...
</project>
----

By default, the publication date will be formatted using the date format string +MM/dd/yyyy+. You can change this format by using the standard notation found in the JavaDocs for +java.text.SimpleDateFormat+ (see JavaDoc for http://java.sun.com/j2se/1.5.0/docs/api/java/text/SimpleDateFormat.html[SimpleDateFormat] for more information). To reformat the date using +yyyy-MM-dd+, use the following +publishDate+ element.

.Configuring the Publish Date Format
----
<project name="Sample Project">
    ...
    <publishDate position="navigation-bottom" format="yyyy-MM-dd"/>
    ...
</project>
----


[[site-generation-sect-doxia-macros]]
==== Using Doxia Macros

In addition to its advanced document rendering features, Doxia also provides a macro engine that allows each input format to trigger injection of dynamic content. An excellent example of this is the snippet macro, which allows a document to pull a code snippet out of a source file that's available via HTTP. Using this macro, a small fragment of APT can be rendered into XHTML. The following APT code calls out to the snippet macro. Please note that this code should be on a single continuous line, the black slash character is inserted to denote a line break so that this code will fit on the printed page.

----
%{snippet|id=modello-model|url=http://svn.apache.org/repos/asf/maven/\
archetype/trunk/maven-archetype/maven-archetype-model/src/main/\
mdo/archetype.mdo}

----

.Output of the Snippet Macro in XHTML
----
<div class="source"><pre>

        <model>
            <id>archetype</id>
            <name>Archetype</name>
            <description><![CDATA[Maven's model for the archetype descriptor.
]]></description>
            <defaults>
                <default>
                    <key>package</key>
                    <value>org.apache.maven.archetype.model</value>
                </default>
            </defaults>
            <classes>
                <class rootElement="true" xml.tagName="archetype">
                    <name>ArchetypeModel</name>
                    <description>Describes the assembly layout and packaging.</description>
                    <version>1.0.0</version>
                    <fields>
                        <field>
                            <name>id</name>
                            <version>1.0.0</version>
                            <required>true</required>
                            <type>String</type>
                        </field>
                        ...
                    </fields>
                </class>
            </classes>
        </model>

</pre></div>
----

WARNING: Doxia macros MUST NOT be indented in APT source documents. Doing so will result in the APT parser skipping the macro altogether.

For more information about defining snippets in your code for reference by the snippet macro, see the Guide to the Snippet Macro on the Maven website, at http://maven.apache.org/guides/mini/guide-snippet-macro.html[http://maven.apache.org/guides/mini/guide-snippet-macro.html].   

[[writing-plugins]]
== Writing Plugins

[[writing-plugins-sect-intro]]
=== Introduction

While this chapter covers an advanced topic, don't let the idea of writing a Maven plugin intimidate you. For all of the theory and complexity of this tool, the fundamental concepts are easy to understand and the mechanics of writing a plugin are straightforward. After you read this chapter, you will have a better grasp of what is involved in creating a Maven plugin. 

[[writing-plugins-sect-programming-maven]]
=== Programming Maven

Most of this book has dealt with using Maven, and for a book on Maven, you haven't seen too many code examples dealing with Maven customization. In fact, you haven't yet seen any. This is by design, 99 out of 100 Maven users will never need to write a custom plugin to customize Maven; there is an abundance of configurable plugins, and unless your project has particularly unique requirements, you will have to work to find a reason to write a new plugin. An even smaller percentage of people who end up writing custom plugins will ever need to crack open the source code for Maven and customize a core Maven component. If you really need to customize the behavior of Maven, then you would write a plugin. Modifying the core Maven code is as far out of scope for most developers as modifying the TCP/IP stack on an operating system, it is that abstract for most Maven users.

On the other hand, if you are going to start writing a custom plugin, you are going to have to learn a bit about the internals of Maven: How does it manage software components? What is a Plugin? How can I customize the lifecycle? This section answers some of those questions, and it introduces a few concepts at the core of Maven's design. Learning how to write a custom Maven plugin is the gateway to customizing Maven itself. If you were wondering how to start understanding the code behind Maven, you've found the proper starting line.

[[writing-plugins-ioc]]
==== What is Inversion of Control?

At the heart of Maven is an Inversion of Control (IoC) container named Plexus. What does it do? It is a system for managing and relating components. While there is a canonical essay about IoC written by Martin Fowler, the concept and term have been so heavily overloaded in the past few years it is tough to find a good definition of the concept that isn't a self-reference (or just a lazy reference to the aforementioned essay). Instead of resorting to a Wikipedia quote, we'll summarize Inversion of Control and Dependency Injection with an analogy.

Assume that you have a series of components which need to be wired together. When you think about components, think stereo components not software components. Imagine several stereo components hooked up to a Playstation 3 and a Tivo that have to interface with both an Apple TV box and a 50-inch flat panel LCD TV. You bring everything home from the electronics store and you purchase a series of cables that you are going to use to connect everything to everything else. You unpack all of these components, put them in the right place, and then get to the job of hooking up fifty thousand coaxial cables and stereo jacks to fifty thousand digital inputs and network cables. Step back from your home entertainment center and turn on the TV, you've just performed dependency injection, and you've just been an inversion of control container.

So what did that have to do with anything? Your Playstation 3 and a Java Bean both provide an interface. The Playstation 3 has two inputs: power and network, and one output to the TV. Your JavaBean has three properties: +power+, +network+, and +tvOutput+. When you open the box of your Playstation 3, it didn't provide you with detailed pictures and instructions for how to connect it to every different kind of TV that might be in every different kind of house. When you look at your Java Bean, it just provides a set of properties, not an explicit recipe for creating and managing an entire system of components. In an IoC container like Plexus, you are responsible for declaring the relationships between a set of components which simply provide an interface of inputs and outputs. You don't instantiate objects, Plexus does; your application's code isn't responsible for managing the state of components, Plexus is. Even though it sounds very cheesy, when you start up Maven, it is starting Plexus and managing a system of related components just like your stereo system.

What are the advantages of using an IoC container? What is the advantage of buying discrete stereo components? If one component breaks, you can drop in a replacement for your Playstation 3 without having to spend $20,000 on the entire system. If you are unhappy with your TV, you can swap it out without affecting your CD player. Most important to you, your stereo components cost less and are more capable and reliable because manufacturers can build to a set of known inputs and outputs and focus on building individual components. Inversion of Control containers and Dependency Injection encourage Disaggregation and the emergence of standards. The software industry likes to imagine itself as the font of all new ideas, but dependency injection and inversion of control are really just new words for the concepts of Disaggregation and interchangeable machinery. If you really want to know about DI and IoC, learn about the Model T, the Cotton Gin, and the emergence of a railroad standard in the late 19th century. 

[[writing-plugins-intro-plexus]]
==== Introduction to Plexus

The most important feature of an IoC container implemented in Java is a mechanism called dependency injection. The basic idea of IoC is that the control of creating and managing objects is removed from the code itself and placed into the hands of an IoC framework. Using dependency injection in an application that has been programmed to interfaces, you can create components which are not bound to specific implementations of these interfaces. Instead, you program to interfaces and then configure Plexus to connect the appropriate implementation to the appropriate component. While your code deals with interfaces, you can capture the dependencies between classes and components in an XML file that defines components, implementation classes, and the relationships between your components. In other words, you can write isolated components, then you can wire them together using an XML file that defines how the components are wired together. In the case of Plexus, system components are defined with an XML document that is found in 'META-INF/plexus/components.xml'.

In a Java IoC container, there are several methods for injecting dependencies values into a component object: constructor, setter, or field injections. Although Plexus is capable of all three dependency injection techniques, Maven only uses two types: field and setter injection.

Constructor Injection::

   Constructor injection is populating an object's values through its constructor when an instance of the object is created. For example, if you had an object of type +Person+ which had a constructor +Person(String name, Job job)+, you could pass in values for both +name+ and the +job+ via this constructor.  

Setter Injection::

   Setter injection is using the setter method of a property on a Java bean to populate object dependencies. For example, if you were working with a +Person+ object with the properties +name+ and +job+, an IoC container which uses setter injection, would create an instance of +Person+ using a no-arg constructor. Once it had an instance of +Person+, it would proceed to call the +setName()+ and +setJob()+ methods.  

Field Injection::

   Both Constructor and Setter injection rely on a call to a public method. Using Field injection, an IoC container populates a component's dependencies by setting an object's fields directly. For example, if you were working with a +Person+ object that had two fields +name+ and +job+, your IoC container would populate these dependencies by setting these fields directly (i.e. +person.name = "Thomas"; person.job = job;+)

[[writing-plugins-why-plexus]]
==== Why Plexus?

Spring does happen to be the most popular IoC container at the moment, and there's a good argument to be made that it has affected the Java "ecosystem" for the better forcing companies like Sun Microsystems to yield more control to the open source community and helping to open up standards by providing a pluggable, component-oriented "bus". But, Spring isn't the only IoC container in open source. There are many IoC containers (like http://www.picocontainer.org/[PicoContainer]).

Years and years ago, when Maven was created, Spring wasn't a mature option. The initial team of committers on Maven were more familiar with Plexus because they invented it, so they decided to use it as an IoC container. While it might not be as popular as the Spring Framework, it is no less capable. And, the fact that it was created by the same person who created Maven makes it a perfect fit. After reading this chapter you've have an idea of how Plexus works. If you already use an IoC container you'll notice similarities and differences between Plexus and the container you currently use.

NOTE: Just because Maven is based on Plexus doesn't mean that the Maven community is "anti-Spring" (we've included a whole chapter with a Spring example in this book, portions of the Spring project are moving to Maven as a build platform). The question, "Why didn't you use Spring?" comes up often enough it did make sense to address it here. We know it, Spring is a rock star, we don't deny it, and it is on our continuing to-do list to introduce people to (and document) Plexus: choice in the software industry is always a good thing.  

[[writing-plugins-what-is-plugin]]
==== What is a Plugin?

A Maven Plugin is a Maven artifact which contains a plugin descriptor and one or more Mojos. A Mojo can be thought of as a goal in Maven, and every goal corresponds to a Mojo. The +compiler:compile+ goal corresponds to the +CompilerMojo+ class in the Maven Compiler Plugin, and the +jar:jar+ goal corresponds to the +JarMojo+ class in the Maven Jar Plugin. When you write your own plugin, you are simply grouping together a set of related Mojos (or goals) in a single plugin artifact.
footnote:["mojo." The American Heritage® Dictionary of the English Language, Fourth Edition. Houghton Mifflin Company, 2004. Answers.com 02 Mar. 2008]

NOTE: Mojo? What is a Mojo? The word mojo is defined as "a magic charm or spell", "an amulet, often in a small flannel bag containing one or more magic items", and "personal magnetism; charm". Maven uses the term Mojo because it is a play on the word Pojo (Plain-old Java Object). 

A Mojo is much more than just a goal in Maven, it is a component managed by Plexus that can include references to other Plexus components.  

[[writing-plugins-sect-plugin-descriptor]]
=== Plugin Descriptor

A Maven plugin contains a road-map for Maven that tells Maven about the various Mojos and plugin configuration. This plugin descriptor is present in the plugin JAR file in 'META-INF/maven/plugin.xml'. When Maven loads a plugin, it reads this XML file, instantiates and configures plugin objects to make the Mojos contained in a plugin available to Maven.

When you are writing custom Maven plugins, you will almost never need to think about writing a plugin descriptor. In <<lifecycle>>, the lifecycle goals bound to the +maven-plugin+ packaging type show that the +plugin:descriptor+ goal is bound to the +generate-resources+ phase. This goal generates a plugin descriptor off of the annotations present in a plugin's source code. Later in this chapter, you will see how Mojos are annotated, and you will also see how the values in these annotations end up in the 'META-INF/maven/plugin.xml' file.

<<ex-plugin-desc>> shows a plugin descriptor for the Maven Zip Plugin. This plugin is a contrived plugin that simply zips up the output directory and produces an archive. Normally, you wouldn't need to write a custom plugin to create an archive from Maven, you could simply use the Maven Assembly Plugin which is capable of producing a distribution archive in multiple formats. Read through the following plugin descriptor to get an idea of the content it contains.


[[ex-plugin-desc]]
.Plugin Descriptor
----
<plugin>
    <description></description>
    <groupId>com.training.plugins</groupId>
    <artifactId>maven-zip-plugin</artifactId>
    <version>1-SNAPSHOT</version>
    <goalPrefix>zip</goalPrefix>
    <isolatedRealm>false</isolatedRealm>
    <inheritedByDefault>true</inheritedByDefault>
    <mojos>
        <mojo>
            <goal>zip</goal>
            <description>Zips up the output directory.</description>
            <requiresDirectInvocation>false</requiresDirectInvocation>
            <requiresProject>true</requiresProject>
            <requiresReports>false</requiresReports>
            <aggregator>false</aggregator>
            <requiresOnline>false</requiresOnline>
            <inheritedByDefault>true</inheritedByDefault>
            <phase>package</phase>
            <implementation>com.training.plugins.ZipMojo</implementation>
            <language>java</language>
            <instantiationStrategy>per-lookup</instantiationStrategy>
            <executionStrategy>once-per-session</executionStrategy>
            <parameters>
                <parameter>
                    <name>baseDirectory</name>
                    <type>java.io.File</type>
                    <required>false</required>
                    <editable>true</editable>
                    <description>Base directory of the project.</description>
                </parameter>
                <parameter>
                    <name>buildDirectory</name>
                    <type>java.io.File</type>
                    <required>false</required>
                    <editable>true</editable>
                    <description>Directory containing the build files.</description>
                </parameter>
            </parameters>
            <configuration>
                <buildDirectory implementation="java.io.File">
                    ${project.build.directory}</buildDirectory>
                <baseDirectory implementation="java.io.File">
                    ${basedir}</baseDirectory>
            </configuration>
            <requirements>
                <requirement>
                    <role>org.codehaus.plexus.archiver.Archiver</role>
                    <role-hint>zip</role-hint>
                    <field-name>zipArchiver</field-name>
                </requirement>
            </requirements>
        </mojo>
    </mojos>
    <dependencies>
        <groupId>org.apache.commons</groupId>
        <artifactId>commons-io</artifactId>
        <version>1.3.2</version>
    </dependencies>
</plugin>
----

There are three parts to a plugin descriptor: the top-level configuration of the plugin which contains elements like +groupId+ and +artifactId+, the declaration of mojos, and the declaration of dependencies. Let's examine each of these sections in more detail.

[[writing-plugins-top-level-elements]]
==== Top-level Plugin Descriptor Elements

The top-level configuration values in the +plugin+ element are:

description::

   This element contains a short description of the plugin. In the case of the Zip plugin, this description is empty.  

groupId, artifactId, version::

   As with everything else in Maven, plugins need to have a unique set of coordinates. The groupId, artifactId, and version are used to locate the plugin artifact in a Maven repository.  

goalPrefix::

   This element controls the prefix used to reference goals in a particular plugin. If you were to look at the Compiler plugin's descriptor you would see that +goalPrefix+ has a value of +compiler+. If you look at the descriptor for the Jar plugin, it would have a +goalPrefix+ of +jar+. It is important that you choose a distinct goal prefix for your custom plugin.  

isolatedRealm (deprecated)::

   This is a legacy property which is no longer used by Maven. It is still present in the system to provide backwards compatibility with older plugins. Earlier versions of Maven used to provide a mechanism to load a plugin's dependencies in an isolated +ClassLoader+. Maven makes extensive use of a project called http://classworlds.codehaus.org/[ClassWorlds] from the http://www.codehaus.org[Codehaus] community to create hierarchies of +ClassLoader+ objects which are modeled by a +ClassRealm+ object. Feel free to ignore this property and always set it to +false+.  

inheritedByDefault::

   If inheritedByDefault is set to true, any mojo in this plugin which is configured in a parent project will be configured in a child project. If you configure a mojo to execute during a specific phase in a parent project and the Plugin has inheritedByDefault set to true, this execution will be inherited by the child project. If inheritedByDefault is not set to true, then an goal execution defined in a parent project will not be inherited by a child project.

[[writing-plugins-sect-mojo-config]]
==== Mojo Configuration

Next is the declaration of each Mojo. The plugin element contains an element named mojos which contains a mojo element for each mojo present in the Plugin. Each mojo element contains the following configuration elements:

goal::

   This is the name of the goal. If you were running the +compiler:compile+ goal, then +compiler+ is the plugin's +goalPrefix+ and +compile+ would be the name of the goal.  

description::

   This contains a short description of the goal to display to the user when they use the Help plugin to generate plugin documentation.  

requiresDirectInvocation::

   If you set this to +true+, the goal can only be executed if it is explicitly executed from the command-line by the user. If someone tries to bind this goal to a lifecycle phase in a POM, Maven will print an error message. The default for this element is +false+. <!--TODO: Might want some justification.-->  

requiresProject::

   Specifies that a given goal cannot be executed outside of a project. The goal requires a project with a POM. The default value for +requiresProject+ is +true+.  

requiresReports::

   If you were creating a plugin that relies on the presence of reports, you would need to set +requiresReports+ to +true+. For example, if you were writing a plugin to aggregate information from a number of reports, you would set +requiresReports+ to +true+. The default for this element is +false+.  

aggregator::

   A Mojo descriptor with +aggregator+ set to +true+ is supposed to only run once during the execution of Maven, it was created to give plugin developers the ability to summarize the output of a series of builds; for example, to create a plugin that summarizes a report across all projects included in a build. A goal with +aggregator+ set to +true+ should only be run against the top-level project in a Maven build. The default value of +aggregator+ is +false+.  

requiresOnline::

   Specifies that a given goal cannot be executed if Maven is running in offline mode (+-o+ command-line option). If a goal depends on a network resource, you would specify a value of +true+ for this element and Maven would print an error if the goal was executed in offline mode. The default for +requiresOnline+ is +false+.  

inheritedByDefault::

   If +inheritedByDefault+ is set to +true+, a mojo which is configured in a parent project will be configured in a child project. If you configure a mojo to execute during a specific phase in a parent project and the Mojo descriptor has +inheritedByDefault+ set to +true+, this execution will be inherited by the child project. If +inheritedByDefault+ is not set to +true+, then a goal execution defined in a parent project will not be inherited by a child project.  

phase::

   If you don't bind this goal to a specific phase, this element defines the default phase for this mojo. If you do not specify a phase element, Maven will require the user to explicitly specify a phase in a POM.  

implementation::

   This element tells Maven which class to instantiate for this Mojo. This is a Plexus component property (defined in Plexus +ComponentDescriptor+).  

language::

   The default language for a Maven Mojo is Java. This controls the Plexus +ComponentFactory+ used to create instances of this Mojo component. This chapter focuses on writing Maven plugins in Java, but you can also write Maven in a number of alternative languages such as Groovy, Beanshell, and Ruby. If you were writing a plugin in one of these languages you would use a language element value other than +java+.  

instantiationStrategy::

   This property is a Plexus component configuration property, it tells Plexus how to create and manage instances of the component. In Maven, all mojos are going to be configured with an +instantiationStrategy+ of +per-lookup+; a new instance of the component (mojo) is created every time it is retrieved from Plexus.  

executionStrategy::

   The execution strategy tells Maven when and how to execute a Mojo. The valid values are +once-per-session+ and +always+. Note: This particular property doesn't do a thing, it is a hold over from an early design of Maven. This property is slated for deprecation in a future release of Maven.  

parameters::

   This element describes all of the parameters for this Mojo. What's the name of the parameter? What is the type of parameter? Is it required? Each parameter has the following elements:

name::

   Is the name of the parameter (i.e. +baseDirectory+)  

type::

   This is the type (Java class) of the parameters (i.e. +java.io.File+)  

required::

   Is the parameter required? If +true+, the parameter must be non-null when the goal is executed.  

editable::

   If a parameter is not editable (if +editable+ is set to +false+), then the value of the parameter cannot be set in the POM. For example, if the plugin descriptor defines the value of +buildDirectory+ to be '+++${basedir}+++' in the descriptor, a POM cannot override this value to be another value in a POM.  

description::

   A short description to use when generating plugin documentation (using the Help Plugin) 

configuration::

   This element provides default values for all of the Mojo's parameters using Maven property notation. This example provides a default value for the +baseDir+ Mojo parameter and the +buildDirectory+ Mojo parameter. In the parameter element, the implementation specifies the type of the parameter (in this case +java.io.File+), the value in the parameter element contains either a hard-coded default or a Maven property reference.  

requirements::

   This is where the descriptor gets interesting. A Mojo is a component that is managed by Plexus, and, because of this, it has the opportunity to reference other components managed by Plexus. This element allows you to define dependencies on other components in Plexus.

While you should know how to read a Plugin Descriptor, you will almost never need to write one of these descriptor files by hand. Plugin Descriptor files are generated automatically off of a set of annotations in the source for a Mojo. 

[[writing-plugins-sect-plugin-depend]]
==== Plugin Dependencies

Lastly, the plugin descriptor declares a set of dependencies just like a Maven project. When Maven uses a plugin, it will download any required dependencies before it attempts to execute a goal from this plugin. In this example, the plugin depends on Jakarta Commons IO version 1.3.2.  

[[writing-plugins-sect-custom-plugin]]
=== Writing a Custom Plugin

When you write a custom plugin, you are going to be writing a series of Mojos (goals). Every Mojo is a single Java class which contains a series of annotations that tell Maven how to generate the Plugin descriptor described in the previous section. Before you can start writing Mojo classes, you will need to create Maven project with the appropriate packaging and POM.

[[writing-plugins-sect-creating-plugin-project]]
==== Creating a Plugin Project

To create a plugin project, you should use the Maven Archetype plugin. The following command-line will create a plugin with a +groupId+ of +org.sonatype.mavenbook.plugins+ and the +artifactId+ of +first-maven-plugin+:

----
$ mvn archetype:create \
      -DgroupId=org.sonatype.mavenbook.plugins \
      -DartifactId=first-maven-plugin \
      -DarchetypeGroupId=org.apache.maven.archetypes \
      -DarchetypeArtifactId=maven-archetype-mojo
----

The Archetype plugin is going to create a directory named my-first-plugin which contains the following POM.

.A Plugin Project's POM
----
<?xml version="1.0" encoding="UTF-8"?><project>
    <modelVersion>4.0.0</modelVersion>
    <groupId>org.sonatype.mavenbook.plugins</groupId>
    <artifactId>first-maven-plugin</artifactId>
    <version>1.0-SNAPSHOT</version>
    <packaging>maven-plugin</packaging>
    <name>first-maven-plugin Maven Mojo</name>
    <url>http://maven.apache.org</url>
    <dependencies>
        <dependency>
            <groupId>org.apache.maven</groupId>
            <artifactId>maven-plugin-api</artifactId>
            <version>2.0</version>
        </dependency>
        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <version>3.8.1</version>
            <scope>test</scope>
        </dependency>
    </dependencies>
</project>
----

The most import element in a plugin project's POM is the packaging element which has a value of +maven-plugin+. This packaging element customizes the Maven lifecycle to include the necessary goals to create a plugin descriptor. The plugin lifecycle was introduced in <<lifecycle-sect-plugin-lifecycle>>, it is similar to the Jar lifecycle with three exceptions: +plugin:descriptor+ is bound to the +generate-resources+ phase, +plugin:addPluginArtifactMetadata+ is added to the +package+ phase, and +plugin:updateRegistry+ is added to the +install+ phase.

The other important piece of a plugin project's POM is the dependency on the Maven Plugin API. This project depends on version 2.0 of the +maven-plugin-api+ and it also adds in JUnit as a test-scoped dependency. 

[[writing-plugins-simple-java-mojo]]
==== A Simple Java Mojo

In this chapter, we're going to introduce a Maven Mojo written in Java. Each Mojo in your project is going to implement the +org.apache.maven.plugin.Mojo+ interface, the +Mojo+ implementation shown in the following example implements the Mojo interface by extending the +org.apache.maven.plugin.AbstractMojo+ class. Before we dive into the code for this Mojo, let's take some time to explore the methods on the Mojo interface. Mojo provides the following methods:

+void setLog( org.apache.maven.monitor.logging.Log log )+::

   Every +Mojo+ implementation has to provide a way for the plugin to communicate the progress of a particular goal. Did the goal succeed? Or, was there a problem during goal execution? When Maven loads and executes a Mojo, it is going to call the +setLog()+ method and supply the Mojo instance with a suitable logging destination to be used in your custom plugin.  

+protected Log getLog()+::

   Maven is going to call +setLog()+ before your +Mojo+ is executed, and your +Mojo+ can retrieve the logging object by calling +getLog()+. Instead of printing out status to Standard Output or the console, your +Mojo+ is going to invoke methods on the +Log+ object.  

 +void execute() throws org.apache.maven.plugin.MojoExecutionException+::

   This method is called by Maven when it is time to execute your goal.   

The +Mojo+ interface is concerned with two things: logging the results of goal execution and executing a goal. When you are writing a custom plugin, you'll be extending +AbstractMojo+. +AbstractMojo+ takes care of handling the +setLog()+ and +getLog()+ implementations and contains an abstract +execute()+ method. When you extend +AbstractMojo+, all you need to do is implement the +execute()+ method. <<ex-simple-echomojo>> shows a trivial +Mojo+ implement which simply prints out a message to the console.

[[ex-simple-echomojo]]
.A Simple EchoMojo
----
package org.sonatype.mavenbook.plugins;

import org.apache.maven.plugin.AbstractMojo;
import org.apache.maven.plugin.MojoExecutionException;
import org.apache.maven.plugin.MojoFailureException;

/**
 * Echos an object string to the output screen.
 * @goal echo
 * @requiresProject false
 */
public class EchoMojo extends AbstractMojo
{
    /**
     * Any Object to print out.
     * @parameter expression="${echo.message}" default-value="Hello World..."
     */
    private Object message;

    public void execute()
        throws MojoExecutionException, MojoFailureException
    {
        getLog().info( message.toString() );
    }
}
----

If you create this Mojo in '+++${basedir}+++' under 'src/main/java' in 'org/sonatype/mavenbook/mojo/EchoMojo.java' in the project created in the previous section and run +mvn install+, you should be able to invoke this goal directly from the command-line with:

----
$ mvn org.sonatype.mavenbook.plugins:first-maven-plugin:1.0-SNAPSHOT:echo
----

That large command-line is +mvn+ followed by the +groupId:artifactId:version:goal+. When you run this command-line you should see output that contains the output of the echo goal with the default message: "Hello Maven World...". If you want to customize the message, you can pass the value of the message parameter with the following command-line:

----
$ mvn org.sonatype.mavenbook.plugins:first-maven-plugin:1.0-SNAPSHOT:echo \
      -Decho.message="The Eagle has Landed"
----

The previous command-line is going to execute the +EchoMojo+ and print out the message "The Eagle has Landed". 

[[writing-plugins-sect-plugin-prefix]]
==== Configuring a Plugin Prefix

Specifying the +groupId+, +artifactId+, +version+, and +goal+ on the command-line is cumbersome. To address this, Maven assigns a plugin a prefix. Instead of typing:

----
$ mvn org.apache.maven.plugins:maven-jar-plugin:2.2:jar
----

You can use the plugin prefix +jar+ and turn that command-line into +mvn jar:jar+. How does Maven resolve something like +jar:jar+ to +org.apache.mven.plugins:maven-jar:2.3+? Maven looks at a file in the Maven repository to obtain a list of plugins for a specific +groupId+. By default, Maven is configured to look for plugins in two groups: +org.apache.maven.plugins+ and +org.codehaus.mojo+. When you specify a new plugin prefix like +mvn hibernate3:hbm2ddl+, Maven is going to scan the repository metadata for the appropriate plugin prefix. First, Maven is going to scan the +org.apache.maven.plugins+ group for the plugin prefix +hibernate3+. If it doesn't find the plugin prefix +hibernate3+ in the +org.apache.maven.plugins+ group it will scan the metadata for the +org.codehaus.mojo+ group.

When Maven scans the metadata for a particular +groupId+, it is retrieving an XML file from the Maven repository which captures metadata about the artifacts contained in a group. This XML file is specific for each repository referenced, if you are not using a custom Maven repository, you will be able to see the Maven metadata for the +org.apache.maven.plugins+ group in your local Maven repository ('~/.m2/repository') under 'org/apache/maven/plugins/maven-metadata-central.xml'. <<ex-maven-metadata>> shows a snippet of the 'maven-metadata-central.xml' file from the +org.apache.maven.plugin+ group.

[[ex-maven-metadata]]
.Maven Metadata for the Maven Plugin Group
----
<?xml version="1.0" encoding="UTF-8"?>
<metadata>
    <plugins>
        <plugin>
            <name>Maven Clean Plugin</name>
            <prefix>clean</prefix>
            <artifactId>maven-clean-plugin</artifactId>
        </plugin>
        <plugin>
            <name>Maven Compiler Plugin</name>
            <prefix>compiler</prefix>
            <artifactId>maven-compiler-plugin</artifactId>
        </plugin>
        <plugin>
            <name>Maven Surefire Plugin</name>
            <prefix>surefire</prefix>
            <artifactId>maven-surefire-plugin</artifactId>
        </plugin>
        ...
    </plugins>
</metadata>
----

As you can see in <<ex-maven-metadata>>, this 'maven-metadata-central.xml' file in your local repository is what makes it possible for you to execute +mvn surefire:test+. Maven scans +org.apache.maven.plugins+ and +org.codehaus.mojo+: plugins from +org.apache.maven.plugins+ are considered core Maven plugins and plugins from +org.codehaus.mojo+ are considered extra plugins. The Apache Maven project manages the +org.apache.maven.plugins+ group, and a separate independent open source community manages the Codehaus Mojo project. If you would like to start publishing plugins to your own +groupId+, and you would like Maven to automatically scan your own +groupId+ for plugin prefixes, you can customize the groups that Maven scans for plugins in your Maven Settings.

If you wanted to be able to run the +first-maven-plugin+'s echo goal by running +first:echo+, add the +org.sonatype.mavenbook.plugins+ groupId to your '~/.m2/settings.xml' as shown in <<ex-plugin-groups>>. This will prepend the +org.sonatype.mavenbook.plugins+ to the list of groups which Maven scans for Maven plugins.

[[ex-plugin-groups]]
.Customizing the Plugin Groups in Maven Settings
----
<settings>
    ...
    <pluginGroups>
        <pluginGroup>org.sonatype.mavenbook.plugins</pluginGroup>
    </pluginGroups>
</settings>
----

You can now run +mvn first:echo+ from any directory and see that Maven will properly resolve the goal prefix to the appropriate plugin identifiers. This worked because our project adhered to a naming convention for Maven plugins. If your plugin project has an +artifactId+ which follows the pattern +maven-first-plugin+ or +first-maven-plugin+. Maven will automatically assign a plugin goal prefix of +first+ to your plugin. In other words, when the Maven Plugin Plugin is generating the Plugin descriptor for your plugin and you have not explicitly set the +goalPrefix+ in your project, the +plugin:descriptor+ goal will extract the prefix from your plugin's +artifactId+ when it matches the following patterns:

* '+++${prefix}-maven-plugin+++', OR 
* maven-'+++${prefix}+++'-plugin

If you would like to set an explicit plugin prefix, you'll need to configure the Maven Plugin Plugin. The Maven Plugin Plugin is a plugin that is responsible for building the Plugin descriptor and performing plugin specific tasks during the package and load phases. The Maven Plugin Plugin can be configured just like any other plugin in the build element. To set the plugin prefix for your plugin, add the following build element to the +first-maven-plugin+ project's 'pom.xml'.

[[ex-plugin-prefix]]
.Configuring a Plugin Prefix
----
<?xml version="1.0" encoding="UTF-8"?><project>
    <modelVersion>4.0.0</modelVersion>
    <groupId>org.sonatype.mavenbook.plugins</groupId>
    <artifactId>first-maven-plugin</artifactId>
    <version>1.0-SNAPSHOT</version>
    <packaging>maven-plugin</packaging>
    <name>first-maven-plugin Maven Mojo</name>
    <url>http://maven.apache.org</url>
    <build>
        <plugins>
            <plugin>
                <artifactId>maven-plugin-plugin</artifactId>
                <version>2.3</version>
                <configuration>
                    <goalPrefix>blah</goalPrefix>
                </configuration>
            </plugin>
        </plugins>
    </build>
    <dependencies>
        <dependency>
            <groupId>org.apache.maven</groupId>
            <artifactId>maven-plugin-api</artifactId>
            <version>2.0</version>
        </dependency>
        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <version>3.8.1</version>
            <scope>test</scope>
        </dependency>
    </dependencies>
</project>
----

<<ex-plugin-prefix>> sets the plugin prefix to +blah+. If you've added the +org.sonatype.mavenbook.plugins+ to the +pluginGroups+ in your '~/.m2/settings.xml', you should be able to execute the +EchoMojo+ by running +mvn blah:echo+ from any directory. 

[[writing-plugins-sect-logging]]
==== Logging from a Plugin

Maven takes care of connecting your Mojo to a logging provider by calling +setLog()+ prior to the execution of your Mojo. It supplies an implementation of +org.apache.maven.monitor.logging.Log+. This class exposes methods that you can use to communicate information back to the user. This +Log+ class provides multiple levels of logging similar to that API provided by http://logging.apache.org/[Log4J]. Those levels are captured by a series of methods available for each level: debug, info, error and warn. To save trees, we've only listed the methods for a single logging level: debug.

+void debug( CharSequence message)+::

   Prints a message to the debug logging level.  

 +void debug( CharSequence message, Throwable t)+::

   Prints a message to the debug logging level which includes the stack trace from the +Throwable+ (either +Exception+ or +Error+)  

+void debug( Throwable t )+::

   Prints out the stack trace of the +Throwable+ (either +Exception+ or +Error+)   

Each of the four levels exposes the same three methods. The four logging levels serve different purposes. The debug level exists for debugging purposes and for people who want to see a very detailed picture of the execution of a Mojo. You should use the debug logging level to provide as much detail on the execution of a Mojo, but you should never assume that a user is going to see the debug level. The info level is for general informational messages that should be printed as a normal course of operation. If you were building a plugin that compiled code using a compiler, you might want to print the output of the compiler to the screen.

The warn logging level is used for messages about unexpected events and errors that your Mojo can cope with. If you were trying to run a plugin that compiled Ruby source code, and there was no Ruby source code available, you might want to just print a warning message and move on. Warnings are not fatal, but errors are usually build-stopping conditions. For the completely unexpected error condition, there is the error logging level. You would use error if you couldn't continue executing a Mojo. If you were writing a Mojo to compile some Java code and the compiler wasn't available, you'd print a message to the error level and possibly pass along an Exception that Maven could print out for the user. You should assume that a user is going to see most of the messages in info and all of the messages in error. 

[[writing-plugins-sect-class-annotations]]
==== Mojo Class Annotations

In +first-maven-plugin+, you didn't write the plugin descriptor yourself, you relied on Maven to generate the plugin descriptor from your source code. The descriptor was generated using your plugin project's POM information and a set of annotations on your +EchoMojo+ class. +EchoMojo+ only specifies the +@goal+ annotation, here is a list of other annotations you can place on your +Mojo+ implementation.

@goal <goalName>::

   This is the only required annotation which gives a name to this goal unique to this plugin.  

@requiresDependencyResolution <requireScope>::

   Flags this mojo as requiring the dependencies in the specified scope (or an implied scope) to be resolved before it can execute. Supports compile, runtime, and test. If this annotation had a value of +test+, it would tell Maven that the Mojo cannot be executed until the dependencies in the test scope had been resolved.  

@requiresProject (true|false)::

   Marks that this goal must be run inside of a project, default is +true+. This is opposed to plugins like archetypes, which do not.  

@requiresReports (true|false)::

   If you were creating a plugin that relies on the presence of reports, you would need to set +requiresReports+ to +true+. The default value of this annotation is false.  

@aggregator (true|false)::

   A Mojo with aggregator set to true is supposed to only run once during the execution of Maven. It was created to give plugin developers the ability to summarize the output of a series of builds; for example, to create a plugin that summarizes a report across all projects included in a build. A goal with +aggregator+ set to +true+ should only be run against the top-level project in a Maven build. The default value of +aggregator+ is +false+.  

@requiresOnline (true|false)::

   When set to +true+, Maven must not be running in offline mode when this goal is executed. Maven will throw an error if one attempts to execute this goal offline. Default: +false+.  

@requiresDirectInvocation::

   When set to +true+, the goal can only be executed if it is explicitly executed from the command-line by the user. Maven will throw an error if someone tries to bind this goal to a lifecycle phase. The default for this annotation is +false+.  

@phase <phaseName>::

   This annotation specifies the default phase for this goal. If you add an execution for this goal to a 'pom.xml' and do not specify the phase, Maven will bind the goal to the phase specified in this annotation by default.  

@execute [goal=goalName|phase=phaseName [lifecycle=lifecycleId]]::

   This annotation can be used in a number of ways. If a phase is supplied, Maven will execute a parallel lifecycle ending in the specified phase. The results of this separate execution will be made available in the Maven property '+++${executedProperty}+++'.

The second way of using this annotation is to specify an explicit goal using the +prefix:goal+ notation. When you specify just a goal, Maven will execute this goal in a parallel environment that will not affect the current Maven build.

The third way of using this annotation would be to specify a phase in an alternate lifecycle using the identifier of a lifecycle.

----
@execute phase="package" lifecycle="zip"
@execute phase="compile"
@execute goal="zip:zip"
----

If you look at the source for +EchoMojo+, you'll notice that Maven is not using the standard annotations available in Java 5. Instead, it is using http://commons.apache.org/attributes/[Commons Attributes]. Commons Attributes provided a way for Java programmers to use annotations before annotations were a part of the Java language specification. Why doesn't Maven use Java 5 annotations? Maven doesn't use Java 5 annotations because it is designed to target pre-Java 5 JVMs. Because Maven has to support older versions of Java, it cannot use any of the newer features available in Java 5. 

[[writing-plugins-sect-failure]]
==== When a Mojo Fails

The +execute()+ method in Mojo throws two exceptions +MojoExecutionException+ and +MojoFailureException+. The difference between these two exception is both subtle and important, and it relates to what happens when a goal execution "fails". A +MojoExecutionException+ is a fatal exception, something unrecoverable happened. You would throw a +MojoExecutionException+ if something happens that warrants a complete stop in a build; you re trying to write to disk, but there is no space left, or you were trying to publish to a remote repository, but you can't connect to it. Throw a +MojoExecutionException+ if there is no chance of a build continuing; something terrible has happened and you want the build to stop and the user to see a "BUILD ERROR" message.

A +MojoFailureException+ is something less catastrophic, a goal can fail, but it might not be the end of the world for your Maven build. A unit test can fail, or a MD5 checksum can fail; both of these are potential problems, but you don't want to return an exception that is going to kill the entire build. In this situation you would throw a +MojoFailureException+. Maven provides for different "resiliency" settings when it comes to project failure. Which are described below.

When you run a Maven build, it could involve a series of projects each of which can succeed or fail. You have the option of running Maven in three failure modes:

mvn -ff::

   Fail-fast mode: Maven will fail (stop) at the first build failure.  

mvn -fae::

   Fail-at-end: Maven will fail at the end of the build. If a project in the Maven reactor fails, Maven will continue to build the rest of the builds and report a failure at the end of the build.  

mvn -fn::

   Fail never: Maven won't stop for a failure and it won't report a failure.   

You might want to ignore failure if you are running a continuous integration build and you want to attempt a build regardless of the success of failure of an individual project build. As a plugin developer, you'll have to make a call as to whether a particular failure condition is a +MojoExecutionException+ or a +MojoFailureExeception+.  

[[writing-plugins-sect-mojo-params]]
=== Mojo Parameters

Just as important as the +execute()+ method and the Mojo annotations, a Mojo is configured via parameters. This section deals with some configuration and topics surrounding Mojo parameters.

[[writing-plugins-sect-param-values]]
==== Supplying Values for Mojo Parameters

In EchoMojo we declared the message parameter with the following annotations:

----
/**
* Any Object to print out.
* @parameter
*   expression="${echo.message}"
*   default-value="Hello Maven World"
*/
private Object message;

----

The default expression for this parameter is '+++${echo.message}+++', this means that Maven will try to use the value of the +echo.message+ property to set the value for message. If the value of the +echo.message+ property is null, the default-value attribute of the +@parameter+ annotation will be used instead. Instead of using the +echo.message+ property, we can configure a value for the message parameter of the EchoMojo directly in a project's POM.

There are a few ways to populate the message parameter in the +EchoMojo+. First we can pass in a value from the command-line like this (assuming that you've added +org.sonatype.mavenbook.plugins+ to your +pluginGroups+):

----
$ mvn first:echo -Decho.message="Hello Everybody"
----

We could also specify the value of this message parameter, by setting a property in our POM or in our 'settings.xml'.

----
<project>
    ...
    <properties>
        <echo.message>Hello Everybody</echo.message>
    </properties>
</project>
----

This parameter could also be configured directly as a configuration value for the plugin. If we wanted to customize the message parameter directly, we could use the following build configuration. The following configuration bypasses the echo.message property and populates the Mojo parameter in plugin configuration.

----
<project>
    ...
    <build>
        <plugins>
            <plugin>
                <groupId>org.sonatype.mavenbook.plugins</groupId>
                <artifactId>first-maven-plugin</artifactId>
                <version>1.0-SNAPSHOT</version>
                <configuration>
                    <message>Hello Everybody!</message>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>
----

If we wanted to run the +EchoMojo+ twice at difference phases in a lifecycle, and we wanted to customize the message parameter for each execution separately, we could configure the parameter value at the execution level in a POM like this:

----
<build>
    <plugins>
        <plugin>
            <groupId>org.sonatype.mavenbook.plugins</groupId>
            <artifactId>first-maven-plugin</artifactId>
            <version>1.0-SNAPSHOT</version>
            <executions>
                <execution>
                    <id>first-execution</id>
                    <phase>generate-resources</phase>
                    <goals>
                        <goal>echo</goal>
                    </goals>
                    <configuration>
                        <message>The Eagle has Landed!</message>
                    </configuration>
                </execution>
                <execution>
                    <id>second-execution</id>
                    <phase>validate</phase>
                    <goals>
                        <goal>echo</goal>
                    </goals>
                    <configuration>
                        <message>${project.version}</message>
                    </configuration>
                </execution>
            </executions>
        </plugin>
    </plugins>
</build>
----

While this last configuration example seems very verbose, it illustrates the flexibility of Maven. In the previous configuration example, you've bound the +EchoMojo+ to both the +validate+ and +generate-resources+ phases in the default Maven lifecycle. The first execution is bound to +generate-resources+, it supplies a string value to the message parameter of "The Eagle has Landed!". The second execution is bound to the +validate+ phase, it supplies a property reference to +1.0+. When you run +mvn install+ for his project, you'll see that the +first:echo+ goal executes twice and prints out two different messages. 

[[writing-plugins-sect-multival-params]]
==== Multi-valued Mojo Parameters

Plugins can have parameters which accept more than one value. Take a look at the +ZipMojo+ shown in <<ex-plugin-multivalue>>. Both the +includes+ and +excludes+ parameters are multivalued +String+ arrays which specify the inclusion and exclusion patterns for a component that creates a ZIP file.

[[ex-plugin-multivalue]]
.A Plugin with Multi-valued Parameters
----
package org.sonatype.mavenbook.plugins

/**
* Zips up the output directory.
* @goal zip
* @phase package
*/
public class ZipMojo extends AbstractMojo
{
/**
* The Zip archiver.
* @parameter \
expression="${component.org.codehaus.plexus.archiver.Archiver#zip}"
*/
private ZipArchiver zipArchiver;

/**
* Directory containing the build files.
* @parameter expression="${project.build.directory}"
*/
private File buildDirectory;

/**
* Base directory of the project.
* @parameter expression="${basedir}"
*/
private File baseDirectory;

/**
* A set of file patterns to include in the zip.
* @parameter alias="includes"
*/
private String[] mIncludes;

/**
* A set of file patterns to exclude from the zip.
* @parameter alias="excludes"
*/
private String[] mExcludes;

public void setExcludes( String[] excludes ) { mExcludes = excludes; }

public void setIncludes( String[] includes ) { mIncludes = includes; }

public void execute()
throws MojoExecutionException
{
try {
zipArchiver.addDirectory( buildDirectory, includes, excludes );
zipArchiver.setDestFile( new File( baseDirectory, "output.zip" ) );
zipArchiver.createArchive();
} catch( Exception e ) {
throw new MojoExecutionException( "Could not zip", e );
}
}
}

----

To configure a multi-valued Mojo parameter, you use a series of elements for each value. If the name of the multi-valued parameter is +includes+, you would use an element +includes+ with child elements +include+. If the multi-valued parameter is +excludes+, you would use an element +excludes+ with child elements +exclude+. To configure the +ZipMojo+ to ignore all files ending in +.txt+ and all files ending in a tilde, you would use the following plugin configuration. 

----
<project>
    ...
    <build>
        <plugins>
            <plugin>
                <groupId>org.sonatype.mavenbook.plugins</groupId>
                <artifactId>zip-maven-plugin</artifactId>
                <configuration>
                    <excludes>
                        <exclude>**/*.txt</exclude>
                        <exclude>**/*~</exclude>
                    </excludes>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>
----

[[writing-plugins-sect-depend-plexus]]
==== Depending on Plexus Components

A Mojo is a component managed by an IoC container called Plexus. A Mojo can depend on other components managed by Plexus by declaring a Mojo parameter and using the +@parameter+ or the +@component+ annotation. <<ex-plugin-multivalue>> shows a +ZipMojo+ which depends on a Plexus component using the +@parameter+ annotation, this dependency could be declared using the +@component+ annotation.

.Depending on a Plexus Component
----
/**
* The Zip archiver.
* @component role="org.codehaus.plexus.archiver.Archiver" roleHint="zip"
*/
private ZipArchiver zipArchiver;
----

When Maven instantiates this Mojo, it will then attempt to retrieve the Plexus component with the specified role and role hint. In this example, the Mojo will be related to a ZipArchiver component which will allow the +ZipMojo+ to create a ZIP file.

[[writing-plugins-sect-param-annot]]
==== Mojo Parameter Annotations

Unless you insist on writing your Plugin descriptors by hand, you'll never have to write that XML. Instead, the Maven Plugin Plugin has a +plugin:descriptor+ goal bound to the generate-resources phase. This goal generates the plugin descriptor from annotations on your Mojo. To configure a Mojo parameter, you should use the following annotations on either the private member variables for each of your Mojo's parameters on public setter methods for each property. The most common convention for Maven plugins is to annotate private member variables directly.


@parameter [alias="someAlias"] [expression="'+++${someExpression}+++'"] [default-value="value"]::

   Marks a private field (or a setter method) as a parameter. The +alias+ provides the name of the parameter. If +alias+ is omitted, Maven will use the name of the variable as the parameter name. The +expression+ is an expression that Maven will evaluate to obtain a value. Usually the expression is a property reference like '+++${echo.message}+++'. +default-value+ is the value that this Mojo will use if no value can be derived from the expression or if a value was not explicitly supplied via plugin configuration in a POM.  

@required::

   If this annotation is present, a valid value for this parameter is required prior to Mojo execution. If Maven tries to execute this Mojo and the parameter has a null value, Maven will throw an error when it tries to execute this goal.  

@readonly::

   If this annotation is present, the user cannot directly configure this parameter in the POM. You would use this annotation with the expression attribute of the parameter annotation. For example, if you wanted to make sure that a particular parameter always had the value of the +finalName+ POM property, you would list an expression of '+++${build.finalName}+++' and then add the +@readOnly+ annotation. If this were the case, the user could only change the value of this parameter by changing the value of +finalName+ in the POM.  

@component::

   Tells Maven to populate a field with a Plexus Component. A valid value for the +@component+ annotation would be:

----
@component role="org.codehaus.plexus.archiver.Archiver" roleHint="zip"
----

This would have the effect of retrieving the +ZipArchiver+ from Plexus. The +ZipArchiver+ is the Archiver which corresponds to the role hint +zip+. Instead of component, you could also use the @parameter annotation with an expression attribute of:

----
@parameter expression="'+++${component.org.codehaus.plexus.archiver.Archiver#zip}+++'"
----

While the two annotations are effectively the same, the +@component+ annotation is the preferred way to configure dependencies on Plexus components.  

@deprecated::

   The parameter will be deprecated. Users can continue configuring this parameter, but a warning message will be displayed. 

[[writing-plugins-sect-plugins-lifecycle]]
=== Plugins and the Maven Lifecycle

In the <<lifecycle>> chapter, you learned that lifecycles can be customized by packaging types. A plugin can both introduce a new packaging type and customize the lifecycle. In this section, you are going to learn how you can customize the lifecycle from a custom Maven plugin. You are going to learn how to execute a parallel lifecycle.

[[writing-plugins-sect-execute-parallel-lifecycle]]
==== Executing a Parallel Lifecycle

Let's assume you write some goal that depends on the output from a previous build. Maybe the +ZipMojo+ goal can only run if there is output to include in an archive. You can specify something like a prerequisite goal by using the +@execute+ annotation on a Mojo class. This annotation will cause Maven to spawn a parallel build and execute a goal or a lifecycle in a parallel instance of Maven that isn't going to affect the current build.

@execute goal="<goal>"::

   This will execute the given goal before execution of this one. The goal name is specified using the +prefix:goal+ notation.  

@execute phase="<phase>"::

   This will fork an alternate build lifecycle up to the specified phase before continuing to execute the current one. If no lifecycle is specified, Maven will use the lifecycle of the current build.  

@execute lifecycle="<lifecycle>" phase="<phase>"::

   This will execute the given alternate lifecycle. A custom lifecycle can be defined in 'META-INF/maven/lifecycles.xml'.

[[writing-plugins-sect-custom-lifecycle]]
==== Creating a Custom Lifecycle

A custom lifecycle must be packaged in the plugin under the 'META-INF/maven/lifecycles.xml' file. You can include a lifecycle under 'src/main/resources' in 'META-INF/maven/lifecycles.xml'. The following 'lifecycle.xml' declares a lifecycle named +zipcycle+ that contains only the +zip+ goal in a +package+ phase.

.Define a Custom Lifecycle in lifecycles.xml
----
<lifecycles>
    <lifecycle>
        <id>zipcycle</id>
        <phases>
            <phase>
                <id>package</id>
                <executions>
                    <execution>
                        <goals>
                            <goal>zip</goal>
                        </goals>
                    </execution>
                </executions>
            </phase>
        </phases>
    </lifecycle>
</lifecycles>
----

If you wanted to execute the +zipcycle+ lifecycle within another build, you could then create a +ZipForkMojo+ which uses the +@execute+ annotation to tell Maven to step through the +zipcycle+ lifecycle when the +ZipForkMojo+ is executed.

.Forking a Custom Lifecycle from a Mojo
----
/**
* Forks a zip lifecycle.
* @goal zip-fork
* @execute lifecycle="zipcycle" phase="package"
*/
public class ZipForkMojo extends AbstractMojo
{
public void execute()
throws MojoExecutionException
{
getLog().info( "doing nothing here" );
}
}
----

Running the +ZipForkMojo+ will fork the lifecycle. If you've configured your plugin to execute with the goal prefix +zip+, running +zip-fork+ should produce something similar to the following output.

----
$ mvn zip:zip-fork
[INFO] Scanning for projects...
[INFO] Searching repository for plugin with prefix: 'zip'.
[INFO] ----------------------------------------------------------------------
[INFO] Building Maven Zip Forked Lifecycle Test
[INFO]task-segment: [zip:zip-fork]
[INFO] ----------------------------------------------------------------------
[INFO] Preparing zip:zip-fork
[INFO] [site:attach-descriptor]
[INFO] [zip:zip]
[INFO] Building zip: \
~/maven-zip-plugin/src/projects/zip-lifecycle-test/target/output.zip
[INFO] [zip:zip-fork]
[INFO] doing nothing here
[INFO] ---------------------------------------------------------------------
[INFO] BUILD SUCCESSFUL
[INFO] ---------------------------------------------------------------------
[INFO] Total time: 1 second
[INFO] Finished at: Sun Apr 29 16:10:06 CDT 2007
[INFO] Final Memory: 3M/7M
[INFO] ---------------------------------------------------------------------
----

Calling +zip-fork+ spawned another lifecycle, Maven executed the +zipcycle+ lifecycle then it printed out the message from +ZipFormMojo+'s execute method. 

[[writing-plugins-sect-override-default-lifecycle]]
==== Overriding the Default Lifecycle

Once you've created your own lifecycle and spawned it from a Mojo. The next question you might have is how do you override the default lifecycle? How do you create custom lifecycles and attach them to projects? In <<lifecycle>>, we saw that the packaging of a project defines the lifecycle of a project. There's something different about almost every packaging type; each packaging type attaches different goals to the default lifecycle. When you create a custom lifecycle, you can attach that lifecycle to a packaging type by supplying some Plexus configuration in your plugin's archive.

To define a new lifecycle for a new packaging type, you'll need to configure a +LifecycleMapping+ component in Plexus. In your plugin project, create a 'META-INF/plexus/components.xml' under src/main/resources. In components.xml add the content from <<ex-override-lifecycle>>. Set the name of the packaging type under +role-hint+, and the set of phases containing the coordinates of the goals to bind (omit the version). Multiple goals can be associated with a phase using a comma delimited list.

[[ex-override-lifecycle]]
.Overriding the Default Lifecycle
----
<component-set>
    <components>
        <component>
            <role>org.apache.maven.lifecycle.mapping.LifecycleMapping</role>
            <role-hint>zip</role-hint>
            <implementation>
                org.apache.maven.lifecycle.mapping.DefaultLifecycleMapping
            </implementation>
            <configuration>
                <phases>
                    <process-resources>
                        org.apache.maven.plugins:maven-resources-plugin:resources
                    </process-resources>
                    <compile>
                        org.apache.maven.plugins:maven-compiler-plugin:compile
                    </compile>
                    <package>org.sonatype.mavenbook.plugins:maven-zip-plugin:zip</package>
                </phases>
            </configuration>
        </component>
    </components>
</component-set>
----

If you create a plugin which defines a new packaging type and a customized lifecycle, Maven won't know anything about it until you add the plugin to your project's POM and set the extensions element to true. Once you do this, Maven will scan your plugin for more than just Mojos to execute, it will look for the 'components.xml' under 'META-INF/plexus', and it will make the packaging type available to your project.

.Configuring a Plugin as an Extension
----
<project>
    ...
    <build>
        ...
        <plugins>
            <plugin>
                <groupId>com.training.plugins</groupId>
                <artifactId>maven-zip-plugin</artifactId>
                <extensions>true</extensions>
            </plugin>
        </plugins>
    </build>
</project>
----

Once you add the plugin with the extensions element set to true, you can use the custom packaging type and your project will be able to execute the custom lifecycle associated with that packaging type.   

[[archetypes]]
== Using Maven Archetypes


[[archetype-sect-intro]]
=== Introduction to Maven Archetypes

An archetype is a template for a Maven project which is used by the Maven Archetype plugin to create new projects. Archetypes are useful for open source projects such as Apache Wicket or Apache Cocoon which want to present end-users with a set of baseline projects that can be used as a foundation for new applications. Archetypes can also be useful within an organization that wants to encourage standards across a series of similar and related projects. If you work in an organization with a large team of developers who all need to create projects which follow a similar structure, you can publish an archetype that can be used by all other members of the development team. You can create a new project from an archetype using the Maven Archetype plugin from the command line or by using the project creation wizard in the m2eclipse plugin introduced in http://www.sonatype.com/books/m2eclipse-book/reference/[Developing with Eclipse and Maven]. 

[[archetype-sect-using]]
=== Using Archetypes

You can use an archetype by invoking the generate goal of the Archetype plugin via the command-line or with m2eclipse.

[[archetype-sect-using-cmd-line]]
==== Using an Archetype from the Command Line

The following command line can be used to generate a project from the quickstart archetype.

----
mvn archetype:generate \
-DgroupId=org.sonatype.mavenbook \
-DartifactId=quickstart \
-Dversion=1.0-SNAPSHOT \
-DpackageName=org.sonatype.mavenbook \
-DarchetypeGroupId=org.apache.maven.archetypes \
-DarchetypeArtifactId=maven-archetype-quickstart \
-DarchetypeVersion=1.0 \
-DinteractiveMode=false
----

The generate goal accepts the following parameters:

+groupId+::

   The +groupId+ for the project you are creating.  

+artifactId+::

   The +artifactId+ for the project you are creating.  

+version+::

   The +version+ for the project you are creating (defaults to 1.0-SNAPSHOT).  

+packageName+::

   The default package for the project you are creating (defaults to +groupId+).  

+archetypeGroupId+::

   The +groupId+ of the archetype you wish to use for project generation.  

+archetypeArtifactId+::

   The +artifactId+ of the archetype you wish to use for project generation.  

+archetypeVersion+::

   The +version+ of the archetype you wish to use for project generation.  

+interactiveMode+::

   When the +generate+ goal is executed in interactive mode, it will prompt the user for all the previously listed parameters. When +interactiveMode+ is false, the +generate+ goal will use the values passed in from the command line.   

Once you run the +generate+ goal using the previously listed command line, you will have a directory named quickstart which contains a new Maven project. The command line you had to suffer through in this section is difficult to manage. In the next section we generate the same project running the generate goal in an interactive mode. 

[[archtype-sect-generate]]
==== Using the Interactive generate Goal

The simplest way to use the Maven Archetype plugin to generate a new Maven project from an archetype is to run the +archetype:generate+ goal in interactive mode. When +interactiveMode+ is set to +true+, the +generate+ goal will present you with a list of archetypes and prompt you to select an archetype and supply the necessary identifiers. Since the default value of the parameter +interactiveMode+ is +true+, all you have to do to generate a new Maven project is run +mvn archetype:generate+.

----
$ mvn archetype:generate
[INFO] ------------------------------------------------------------------------
[INFO] Building Maven Default Project
[INFO]task-segment: [archetype:generate] (aggregator-style)
[INFO] [archetype:generate]
[INFO] Generating project in Interactive mode
[INFO] No archetype defined. Using maven-archetype-quickstart
Choose archetype:
1: internal -> appfuse-basic-jsf 
2: internal -> appfuse-basic-spring 
3: internal -> appfuse-basic-struts
4: internal -> appfuse-basic-tapestry
5: internal -> appfuse-core
6: internal -> appfuse-modular-jsf
7: internal -> appfuse-modular-spring
8: internal -> appfuse-modular-struts
9: internal -> appfuse-modular-tapestry
10: internal -> maven-archetype-j2ee-simple
11: internal -> maven-archetype-marmalade-mojo
12: internal -> maven-archetype-mojo
13: internal -> maven-archetype-portlet
14: internal -> maven-archetype-profiles
15: internal -> maven-archetype-quickstart
16: internal -> maven-archetype-site-simple
17: internal -> maven-archetype-site
18: internal -> maven-archetype-webapp
19: internal -> jini-service-archetype
20: internal -> softeu-archetype-seam
21: internal -> softeu-archetype-seam-simple
22: internal -> softeu-archetype-jsf
23: internal -> jpa-maven-archetype
24: internal -> spring-osgi-bundle-archetype
25: internal -> confluence-plugin-archetype
26: internal -> jira-plugin-archetype
27: internal -> maven-archetype-har
28: internal -> maven-archetype-sar
29: internal -> wicket-archetype-quickstart
30: internal -> scala-archetype-simple
31: internal -> lift-archetype-blank
32: internal -> lift-archetype-basic
33: internal -> cocoon-22-archetype-block-plain
34: internal -> cocoon-22-archetype-block
35: internal -> cocoon-22-archetype-webapp
36: internal -> myfaces-archetype-helloworld
37: internal -> myfaces-archetype-helloworld-facelets
38: internal -> myfaces-archetype-trinidad
39: internal -> myfaces-archetype-jsfcomponents
40: internal -> gmaven-archetype-basic
41: internal -> gmaven-archetype-mojo
Choose a number: +15 +
----

The first thing that the +archetype:generate+ goal does in interactive mode is print out a list of archetypes that it is aware of. The Maven Archetype plugin ships with an archetype catalog which includes a reference to all of the standard, simple Maven archetypes (10-18). The plugin's archetype catalog also contains a number of references to compelling third-party archetypes such as archetypes which can be used to create AppFuse projects, Confluence and JIRA plugins, Wicket applications, Scala applications, and Groovy projects. For a brief overview of these third-party archetypes, see <<archetype-sect-third-party>>.

Once you select an archetype, the Maven Archetype plugin downloads the archetype, and then asks you to supply the following values for your new project:

* groupId
* artifactId
* version
* package

----
Define value for groupId: : +org.sonatype.mavenbook+   
Define value for artifactId: : +quickstart+
Define value for version:  1.0-SNAPSHOT: : +1.0-SNAPSHOT+ 
Define value for package:  org.sonatype.mavenbook: : +org.sonatype.mavenbook+ 
Confirm properties configuration:
groupId: org.sonatype.mavenbook
artifactId: quickstart
version: 1.0-SNAPSHOT
package: org.sonatype.mavenbook
Y: : +Y+
----

Once this interactive portion of the +archetype:generate+ goal execution is finished, the Maven Archetype plugin will generate the project in a directory named after the +artifactId+ you supplied.

----
[INFO] Parameter: groupId, Value: org.sonatype.mavenbook
[INFO] Parameter: packageName, Value: org.sonatype.mavenbook
[INFO] Parameter: basedir, Value: /Users/tobrien/tmp
[INFO] Parameter: package, Value: org.sonatype.mavenbook
[INFO] Parameter: version, Value: 1.0-SNAPSHOT
[INFO] Parameter: artifactId, Value: quickstart
[INFO] ********************* End of debug info from resources from \
generated POM **
[INFO] OldArchetype created in dir: /Users/tobrien/tmp/quickstart
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESSFUL
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 1 minute 57 seconds
[INFO] Finished at: Sun Oct 12 15:39:14 CDT 2008
[INFO] Final Memory: 8M/15M
[INFO] ------------------------------------------------------------------------
----


[[archetype-sect-using-m2eclipse]]
==== Using an Archetype from m2eclipse

m2eclipse makes creating a new Maven project from a Maven Archetype very easy by providing an intuitive wizard for searching for, selecting, and configuring a Maven Archetype. For more information about generating a Maven project from a Maven Archetype using m2eclipse, see http://www.sonatype.com/books/m2eclipse-book/reference/eclipse-sect-creating-project.html#eclipse-sect-m2e-create-archetype[Creating a Maven Project from a Maven Archetype] in http://www.sonatype.com/books/m2eclipse-book/["Developing with Eclipse and Maven"].  

[[archetype-sect-available]]
=== Available Archetypes

As more and more projects adopt Maven, more and more artifacts are being published by projects as a way to provide users with a quick way of creating projects from existing templates. This section discusses some of the simple core archetypes from the Apache Maven project as well as providing a survey of some interesting third-party archetypes.

[[archetype-sect-common-maven]]
==== Common Maven Archetypes

Some of the most straightforward Maven archetypes are contained in the org.apache.maven.archetypes groupId. Most of the basic archetypes under org.apache.maven.archetypes are very basic templates that include few options. You'll use them only to provide the most basic features that distinguish a Maven project from a non-Maven project. For example, the webapp archetype plugin described in this section just includes a stub of a 'web.xml' file in '+++${basedir}/src/main/webapp/WEB-INF+++', and it doesn't even go as far as providing a Servlet for you to customize. In <<archetype-sect-third-party>> you'll see a quick survey of some of the more notable third-party archetypes such as the AppFuse and Cocoon artifacts.

The following archetypes can be found in the groupId +org.apache.maven.archetypes+:

[[archetype-sect-quickstart]]
===== maven-archetype-quickstart

The quickstart archetype is a simple project with JAR packaging and a single dependency on JUnit. After generating a project with the quickstart archetype, you will have a single class named +App+ in the default package with a +main()+ method that prints "Hello World!" to standard output. You will also have a single JUnit test class named AppTest with a +testApp()+ method with a trivial unit test. 

[[archetype-sect-webapp]]
===== maven-archetype-webapp

This archetype creates a simple project with WAR packaging and a single dependency on JUnit. '+++${basedir}/src/main/webapp+++' contains a simple shell of a web application: an 'index.jsp' page and the simplest possible 'web.xml' file. Even though the archetype includes a dependency on JUnit, this archetype does not create any unit tests. If you were looking for a functional web application, this archetype is going to disappoint you. For more relevant web archetypes, see <<archetype-sect-third-party>>. 

[[archetype-sect-mojo]]
===== maven-archetype-mojo

This archetype creates a simple project with +maven-plugin+ packaging and a single mojo class named +MyMojo+ in the project's default package. The +MyMojo+ class contains a +touch+ goal which is bound to the +process-resources+ phase, it creates a file named 'touch.txt' in the 'target/' directory of the new project when it is executed. The new project will have a dependency on maven-plugin-api and JUnit.  

[[archetype-sect-third-party]]
==== Notable Third-Party Archetypes

This section is going to give you a brief overview of some of the archetypes available from third-parties not associated with the Apache Maven project. If you are looking for a more comprehensive list of available archetypes, take a look at the list of archetypes in m2eclipse. m2eclipse allows you to create a new Maven project from an ever growing list of approximately 80 archetypes which span an amazing number of projects and technologies. http://www.sonatype.com/books/m2eclipse-book/reference/eclipse-sect-creating-project.html#eclipse-sect-m2e-create-archetype[Creating a Maven Project from a Maven Archetype] in http://www.sonatype.com/books/m2eclipse-book/["Developing with Eclipse and Maven"] contains a list of archetypes which are immediately available to you when you use m2eclipse. The archetypes listed in this section are available on the default list of archetypes generated by the interactive execution of the +generate+ goal.

[[archetype-sect-appfuse]]
===== AppFuse

AppFuse is an application framework developed by Matt Raible. You can think of AppFuse as something of a Rosetta Stone for a few very popular Java technologies like the Spring Framework, Hibernate, and iBatis. Using AppFuse you can very quickly create an end-to-end multi-tiered application that can plugin into several front-end web frameworks like Java Server Faces, Struts, and Tapestry. Starting with AppFuse 2.0, Matt Raible has been transitioning the framework to Maven 2 to take advantage of the dependency management and archetype capabilities. AppFuse 2 provides the following archetypes all in the groupId +org.appfuse.archetypes+:

+appfuse-basic-jsf+ and +appfuse-modular-jsf+::

   End-to-end application using Java Server Faces in the presentation layer  

 +appfuse-basic-spring+ and +appfuse-modular-spring+::

   End-to-end application using Spring MVC in the presentation layer  

 +appfuse-basic-struts+ and +appfuse-modular-struts+::

   End-to-end application using Struts 2 in the presentation layer  

 +appfuse-basic-tapestry+ and +appfuse-modular-tapestry+::

   End-to-end application using Tapestry in the presentation layer  

+appfuse-core+::

   Persistence and object model without the presentation layer   

Archetypes following the +appfuse-basic-\*+ pattern are entire end-to-end applications in a single Maven project, and archetypes following the +appfuse-modular-*+ pattern are end-to-end applications in a multimodule Maven project which separates the core model objects and persistence logic from the web front-end. Here's an example from generating a project to running a web application for the modular Spring MVC application:

----
$ mvn archetype:generate \
-DarchetypeArtifactId=appfuse-modular-spring \
-DarchetypeGroupId=org.appfuse.archetypes \
-DgroupId=org.sonatype.mavenbook \
-DartifactId=mod-spring \
-Dversion=1.0-SNAPSHOT \
-DinteractiveMode=false[INFO] Scanning for projects...
...
[INFO] [archetype:generate]
[INFO] Generating project in Batch mode
[INFO] Archetype [org.appfuse.archetypes:appfuse-modular-spring:RELEASE]
found in catalog 
[INFO] Parameter: groupId, Value: org.sonatype.mavenbook
[INFO] Parameter: packageName, Value: org.sonatype.mavenbook
[INFO] Parameter: basedir, Value: /Users/tobrien/tmp
[INFO] Parameter: package, Value: org.sonatype.mavenbook
[INFO] Parameter: version, Value: 1.0-SNAPSHOT
[INFO] Parameter: artifactId, Value: mod-spring
...
[INFO] OldArchetype created in dir: /Users/tobrien/tmp/mod-spring
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESSFUL
$ cd mod-spring
$ mvn
... (an overwhelming amount of activity ~5 minutes) 
$ cd web
$ mvn jetty:run-war
... (Maven Jetty plugin starts a Servlet Container on port 8080)
----

From generating a project with the AppFuse archetype to running a web application with a authentication and user-management system takes all of 5 minutes. This is the real power of using a Maven Archetype as a foundation for a new application. We oversimplified the AppFuse installation process a bit and left out the important part where you download and install a MySQL database, but that's easy enough to figure out by reading the http://appfuse.org/display/APF/AppFuse+QuickStart[AppFuse Quickstart Documentation]. 

[[archetype-sect-atlassian]]
===== Confluence and JIRA plugins

Atlassian has created some archetypes for people interested in developing plugins for both Confluence and JIRA. Confluence and JIRA are, respectively, a Wiki and an issue tracker both of which have gained a large open source user base through granting free licenses for open source projects. Both the +jira-plugin-archetype+ and the +confluence-maven-archetype+ artifacts are under the com.atlassian.maven.archetypes groupId. When you generate a Confluence plugin, the archetype will generate a pom.xml which contains the necessary references to the Atlassian repositories and a dependency on the confluence artifact. The resulting Confluence plugin project will have a single example macro class and an atlassian-plugin.xml descriptor. Generating a project from the Jira archetype creates a project with a single, blank +MyPlugin+ class and an atlassian-plugin.xml descriptor in '+++${basedir}/src/main/resources+++'.

For more information about developing Confluence plugins with Maven 2, see http://confluence.atlassian.com/display/DISC/Developing+Confluence+Plugins+with+Maven+2[Developing Confluence Plugins with Maven 2] on the Confluence project's Wiki. For more information about developing Jira plugins with Maven 2, see http://confluence.atlassian.com/display/DEVNET/How+to+Build+an+Atlassian+Plugin[How to Build and Atlassian Plugin] on the Atlassian Developer Network. 

[[archetype-sect-wicket]]
===== Wicket

Apache Wicket is a component-oriented web framework which focused on managing the server-side state of a number of components written in Java and simple HTML. Where a framework like Spring MVC or Ruby on Rails focuses on merging objects within a request with a series of page templates, Wicket is very strongly focused on capturing interactions and page structure in a series of POJO Java classes. In an age where hype-driven tech media outlets are proclaiming the "Death of Java", Wicket is a contrarian approach to the design and assembly of web applications. To generate a Wicket project with the Maven Archetype plugin:

----
$ mvn archetype:generate
... (select the "wicket-archetype-quickstart" artifact from the interactive \
menu) ...
... (supply a groupId, artifactId, version, package) ...
... (assuming the artifactId is "ex-wicket") ...
$ cd ex-wicket
$ mvn install
... (a lot of Maven activity) ...
$ mvn jetty:run
... (Jetty will start listening on port 8080) ...
----

Just like the AppFuse archetype, this archetype creates a shell web application which can be immediately executed with the Maven Jetty plugin. If you hit http://localhost:8080/ex-wicket[http://localhost:8080/ex-wicket], you be able to see the newly created web application in a servlet container.

NOTE: Think about the power of Maven Archetypes versus the copy and paste approach that has characterized the last few years of web development. Six years ago, without the benefit of something like the Maven Archetype plugin, you would have had to slog through a book about AppFuse or a book about Wicket and followed circuitous pedagogy about the framework before you could actually fire it up in servlet container. It was either that or just copying an existing project and customizing it for your needs. With the Maven Archetype plugin, framework developers can now give you a working, customized shell for an application in a matter of minutes. This is a sea change that has yet to hit the enterprise development space, and you can expect that this handful of available third-party artifacts will balloon to hundreds within the next few years.

[[archetype-sect-publishing]]
=== Publishing Archetypes

Once you've generated a good set of archetypes, you will probably want to share them with the world. To do this, you'll need to create something called an Archetype catalog. An Archetype catalog is an XML file which the Maven Archetype plugin can consult to locate archetypes in a repository. <<archetypes-cocoon-catalog>> shows the contents of the Archetype catalog for the Apache Cocoon project which can be found at http://cocoon.apache.org/archetype-catalog.xml[http://cocoon.apache.org/archetype-catalog.xml].

[[archetypes-cocoon-catalog]]
.Archetype Catalog for the Apache Cocoon Project
----
<archetype-catalog>
    <archetypes>
        <archetype>
            <groupId>org.apache.cocoon</groupId>
            <artifactId>cocoon-22-archetype-block-plain</artifactId>
            <version>1.0.0</version>
            <description>Creates an empty Cocoon block; useful if you want to add 
                another block to a Cocoon application</description>

        </archetype>
        <archetype>
            <groupId>org.apache.cocoon</groupId>
            <artifactId>cocoon-22-archetype-block</artifactId>
            <version>1.0.0</version>
            <description>Creates a Cocoon block containing some small 
                samples</description>
        </archetype>

        <archetype>
            <groupId>org.apache.cocoon</groupId>
            <artifactId>cocoon-22-archetype-webapp</artifactId>
            <version>1.0.0</version>
            <description>Creates a web application configured to host Cocoon blocks. 
                Just add the block dependencies</description>
        </archetype>
    </archetypes>

</archetype-catalog>
----

To generate such a catalog, you'll need to crawl a Maven repository and generate this catalog XML file. The Archetype plugin has a goal named crawl which does just this, and it assumes that it has access to the file system that hosts a repository. If you run archetype:crawl from the command line with no arguments, the Archetype plugin will crawl your local repository searching for Archetypes and it will create an archetype-catalog.xml in ~/.m2/repository.

----
[tobrien@MACBOOK repository]$ mvn archetype:crawl
[INFO] Scanning for projects...
[INFO] Searching repository for plugin with prefix: 'archetype'.
[INFO] ------------------------------------------------------------------------
[INFO] Building Maven Default Project
[INFO]task-segment: [archetype:crawl] (aggregator-style)
[INFO] ------------------------------------------------------------------------
[INFO] [archetype:crawl]
repository /Users/tobrien/.m2/repository
catalogFile null
[INFO] Scanning /Users/tobrien/.m2/repository/ant/ant/1.5/ant-1.5.jar
[INFO] Scanning /Users/tobrien/.m2/repository/ant/ant/1.5.1/ant-1.5.1.jar
[INFO] Scanning /Users/tobrien/.m2/repository/ant/ant/1.6/ant-1.6.jar
[INFO] Scanning /Users/tobrien/.m2/repository/ant/ant/1.6.5/ant-1.6.5.jar
...
[INFO] Scanning /Users/tobrien/.m2/repository/xom/xom/1.0/xom-1.0.jar
[INFO] Scanning /Users/tobrien/.m2/repository/xom/xom/1.0b3/xom-1.0b3.jar
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESSFUL
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 31 seconds
[INFO] Finished at: Sun Oct 12 16:06:07 CDT 2008
[INFO] Final Memory: 6M/12M
[INFO] ------------------------------------------------------------------------

----

If you are interested in creating an Archetype catalog it is usually because you are an open source project or organization which has a set of archetypes to share. These archetypes are likely already available in a repository, and you need to crawl this repository and generate a catalog in a file system. In other words, you'll probably want to scan a directory on an existing Maven repository and generate an Archetype plugin at the root of the repository. To do this, you'll need to pass in the catalog and repository parameters to the +archetype:crawl+ goal.

The following command line assumes that you are trying to generate a catalog file in /var/www/html/archetype-catalog.xml for a repository hosted in /var/www/html/maven2.

----
$ mvn archetype:crawl -Dcatalog=/var/www/html/archetype-catalog.xml \
[INFO] Scanning for projects...
[INFO] Searching repository for plugin with prefix: 'archetype'.
[INFO] ------------------------------------------------------------------------
[INFO] Building Maven Default Project
[INFO]task-segment: [archetype:crawl] (aggregator-style)
[INFO] ------------------------------------------------------------------------
[INFO] [archetype:crawl]
repository /Users/tobrien/tmp/maven2
catalogFile /Users/tobrien/tmp/blah.xml
-Drepository=/var/www/html/maven2
...
----

[[flex-dev]]
== Developing with Flexmojos


[[flex-dev-sect-intro]]
=== Introduction

This chapter provides an overview of the Flexmojos project for people interested in using Maven to develop Flex applications and libraries. 

[[flex-dev-sect-config-build]]
=== Configuring Build Environment for Flexmojos

Before you attempt to compile Flex libraries and applications with Maven, you will need to complete two configuration tasks:

*  Configure your Maven settings to reference a repository which contains the Flex framework 

*  Add the Flash Player to your PATH to support Flex unit testing 

*  (Optional) Configure your Maven Settings to include the Sonatype plugin group  

[[flex-dev-sect-referencing-repo-with-flex]]
==== Referencing a Repository with the Flex Framework

To setup your Maven environment for Flexmojos, you have two options: you can reference the Sonatype Flexmojos repository directly in a 'pom.xml', or you can install Nexus and add the Sonatype Flexmojos repository as a proxy repository in your own repository manager. While the most straightforward option is to reference the repository directly, downloading and installing Nexus will give you the control and flexibility you need to cache and manage artifacts generated by your own build. If you are just interested in getting up and running with Flexmojos, read <<flex-dev-sect-direct-repo>> next. If you are interested in a long-term solution which can be deployed to support a development team, continue to <<flex-dev-sect-proxy-nexus>>.

NOTE: If your organization is already using Sonatype Nexus to proxy remote repositories, you may already have customized your '~/.m2/settings.xml' file to point to a single Nexus group. If this is your situation, you should add a Proxy repository for the Sonatype Flexmojos repository group at ${flexmojos.repository}[${flexmojos.repository}]. Add this new repository to the Nexus Repository Group that is referenced by your development team. Adding a proxy repository for this remote group and then adding this group to your Nexus installation's public repository group will give clients of your Nexus instance access to the artifacts from the Sonatype repository.sonatype.org Nexus instance.

[[flex-dev-sect-direct-repo]]
===== Referencing Sonatype's Flexmojos Repository in a POM

Flexmojos depends on a few artifacts which are not currently available from the Central Maven repository. These artifacts are available from a Repository hosted by Sonatype. To use Flexmojos, you will need to reference this repository from your project's 'pom.xml'. To do this, add the +repositories+ element shown in <<ex-flex-dev-repository>> to your project's 'pom.xml'.

[[ex-flex-dev-repository]]
.Adding a Reference to Sonatype's FlexMojos Repository in a POM
----
<project>
    <modelVersion>4.0.0</modelVersion>
    <groupId>test</groupId>
    <artifactId>test</artifactId>
    <version>1.0-SNAPSHOT</version>
    <packaging>pom</packaging>

    <modules>
        <module>swc</module>
        <module>swf</module>
        <module>war</module>
    </modules>

    *<repositories>
        <repository>
            <id>flexmojos</id>
            <url>${flexmojos.repository}</url>
        </repository>
    </repositories>*

</project>
----

 The XML shown in <<ex-flex-dev-repository>>, will add this repository to the list of repositories Maven will consult when it attempts to download artifacts and plugins. 

[[flex-dev-sect-proxy-nexus]]
===== Proxying Sonatype's Flexmojos Repository with Nexus

Instead of pointing directly at the Sonatype Flexmojos repository, Sonatype recommends that you install a repository manager and proxy the Sonatype public repository. When you proxy a remote repository with a repository manager such as Nexus, you gain a level of control and stability not possible when your build relies directly on external resources. In addition to this control and stability, a repository manager also provides you with an deployment target for binary artifacts generated by your own builds. For instructions on downloading, installing, and configuring Nexus, refer to the http://www.sonatype.com/books/nexus-book/reference/install.html[Installation chapter in Repository Management with Nexus]. 


==== Configure a Flexmojos Proxy Repository in Nexus

Once Nexus is installed and started, complete the following steps to add a proxy repository for the Sonatype public repository. To add a new proxy repository:

.  Click on the *Repositories* link under *Views/Repositories* in the *Nexus* menu on the left-hand side of the Nexus user interface. 

.  Click on *Repositories* to load the *Repositories* panel. 

.  In the *Repositories* panel, click on the *Add..* button and select Proxy Repository as shown in <<fig-flex-dev-add-proxy-repos>>.  

[[fig-flex-dev-add-proxy-repos]]
.Adding a Proxy Repository to Sonatype Nexus
image::figs/web/flex-dev-nexus-add-proxy.png[]

Once you've created a new Proxy repository, you will need to configure it to point to the Sonatype Flexmojos repository.

.  Select the new repository, and then 

.  Select the Configuration tab in the lower half of the window. 

.  Populate the following field with the values shown in <<fig-flex-dev-sonatype-public-proxy>>.

.. <itemizedlist>  Repository ID is "sonatype-flexmojos" 

..  Repository Name is "Sonatype Flexmojos Proxy" 

..  The Remote Storage Location is ${flexmojos.repository}[${flexmojos.repository}]

[[fig-flex-dev-sonatype-public-proxy]]
.Configuring the Sonatype Flexmojos Proxy Repository
image::figs/web/flex-dev-nexus-sonatype-proxy.png[]

Once you have populated the fields shown in <<fig-flex-dev-sonatype-public-proxy>> click the *Save* button to save the proxy repository and start proxying the Sonatype Flexmojos repository. 


===== Add the Flexmojos Proxy Repository to a Group

Nexus ships with a public repository group, which combines several repositories into a single URL for Maven clients. Add this new Flexmojos proxy repository to the Nexus public group. To do this:

.  Return to the list of repositories which should now be visible in the upper half of the Repositories panel as shown in <<fig-flex-dev-sonatype-public-proxy>>. 

.  Click on the Public Repositories group, and then 

.  Click on the Configuration tab in the lower half of the Repository panel. Clicking the Configuration tab will expose the Group configuration form shown in <<fig-flex-dev-adding-sonatype-to-group>>.  

[[fig-flex-dev-adding-sonatype-to-group]]
.Adding the Sonatype Flexmojos Proxy to the Public Repositories Group
image::figs/web/flex-dev-nexus-sonatype-to-group.png[]

.  To add the *Sonatype Public Proxy* to the *Public Repositories* group simply drag and drop the *Sonatype Public Proxy* repository from the *Available Repositories* list to the *Ordered Group Repositories* list. 

.  Click *Save*, and you have successfully added a proxy of the Sonatype Flexmojos repository to your Nexus installation.  

Whenever a client requests an artifact from this repository group, if Nexus has not already cached a matching artifact, it will query the Sonatype Flexmojos repository at ${flexmojos.repository}[${flexmojos.repository}]. Your Nexus installation will maintain a local cache of all artifacts retrieved from the Sonatype Flexmojos repository. This local cache gives you more control and contributes to a more stable build environment. If you are setting up a group of developers to rely upon artifacts from the Sonatype public repository, you'll have a completely self-contained build environment that won't be subject to the availability of the Sonatype repository once the necessary artifacts have been cached by your Nexus instance. 


===== Configure Your Development Environment for Nexus

The final step is connecting your Maven installation to the Nexus instance you just configured. You will need to update your Maven Settings to use your Nexus repository group as a mirror for all repositories. To do this, you need to put the following XML in your '~/.m2/settings.xml' file.

[[ex-flex-dev-settings-local-nexus]]
.Settings XML for Local Nexus Instance
----
<settings>
    <mirrors>
        <mirror>
            <!--This sends everything else to /public -->
            <id>nexus</id>
            <mirrorOf>*</mirrorOf>
            <url>http://localhost:8081/nexus/content/groups/public</url>
        </mirror>
    </mirrors>
    <profiles>
        <profile>
            <id>nexus</id>
            <!--all requests to nexus via the mirror -->
            <repositories>
                <repository>
                    <id>central</id>
                    <url>http://central</url>
                    <releases><enabled>true</enabled></releases>
                    <snapshots><enabled>true</enabled></snapshots>
                </repository>
            </repositories>
            <pluginRepositories>
                <pluginRepository>
                    <id>central</id>
                    <url>http://central</url>
                    <releases><enabled>true</enabled></releases>
                    <snapshots><enabled>true</enabled></snapshots>
                </pluginRepository>
            </pluginRepositories>
        </profile>
    </profiles>
    <activeProfiles>
        <activeProfile>nexus</activeProfile>
    </activeProfiles>
</settings>
----

This XML file configures Maven to consult a single public repository group for all configured repositories and plugin repositories. It is a simple way to guarantee that every request for an artifact is made through your Nexus installation.   

[[flex-dev-sect-configuring-unit-tests]]
==== Configuring Environment to Support Flex Unit Tests

Flexmojos expects to be able to launch the stand-alone Flash Player to execute unit tests. In order for this to work, you will need to add the stand-alone Flash Player to your PATH, or you will need to pass the location of the Flash Player executable to your build using the +-DflashPlayer.command+ options. When executing a unit test, Flex Mojos expects to launch the following platform-specific executables for the stand-alone Flash Player:

Microsoft Windows::

   FlexMojos will attempt to launch the 'FlashPlayer.exe' binary. To support execution of unit tests, add the directory containing 'FlashPlayer.exe' to your PATH or pass in the location of the 'FlashPlayer.exe' binary to Maven using the +-DflashPlayer.command=${filepath}+ command-line option.  

Macintosh OSX::

   FlexMojos will attempt to launch the "Flash Player" application. To support the execution of unit tests, add the directory containing "Flash Player" to your PATH or pass the path to the executable to Maven using the +-DflashPlayer.command=${filepath}+ command-line option.  

Unix (Linux, Solaris, etc.)::

   FlexMojos will attempt to launch the 'flashplayer' executable. To support the execution of unit tests, add the directory containing 'flashplayer' to your PATH or pass the path to the executable to Maven using the +-DflashPlayer.command=${filepath}+ command-line option.   

NOTE: On a Linux machine, you will need to have X virtual framebuffer (Xvfb) installed to run unit tests in a headless build. For more information about Xvfb, http://en.wikipedia.org/wiki/Xvfb[click here]. 

If you have been developing Flash Applications with Adobe Flash CS4 or Adobe Flex Builder or if you have been viewing flash content in a browser, you probably have the Flash Player installed somewhere on your workstation. While it is possible to configure Maven to use one of these players for Flex unit tests, you'll want to make sure that you are running the debug version of the Flash Player. To minimize the potential for incompatibility, you should download one of the Flash Player's listed below and install it on your local workstation. To download the standalone Flash Player for you environment:

*  Windows: http://download.macromedia.com/pub/flashplayer/updaters/10/flashplayer_10_sa_debug.exe[http://download.macromedia.com/pub/flashplayer/updaters/10/flashplayer_10_sa_debug.exe] 

*  Mac OSX: http://download.macromedia.com/pub/flashplayer/updaters/10/flashplayer_10_sa_debug.app.zip[http://download.macromedia.com/pub/flashplayer/updaters/10/flashplayer_10_sa_debug.app.zip] 

*  Linux: http://download.macromedia.com/pub/flashplayer/updaters/10/flash_player_10_linux_dev.tar.gz[http://download.macromedia.com/pub/flashplayer/updaters/10/flash_player_10_linux_dev.tar.gz]  

To install this player and add it to your PATH on an OSX machine, run the following commands:

----
$ wget http://download.macromedia.com/pub/flashplayer/updaters/10/\
       flashplayer_10_sa_debug.app.zip
$ unzip flashplayer_10_sa_debug.app.zip
$ sudo cp -r Flash\ Player.app /Applications/
$ export PATH=/Applications/Flash\ Player.app/Contents/MacOS:${PATH}
----

Instead of adding the path for the Flash Player to your PATH on the command-line, you should configure your environment to automatically configure these variables. If you are using bash, you would add the last export command to your '~/.bash_profile'. 

[[flex-dev-sect-plugin-group]]
==== Adding FlexMojos to Your Maven Settings' Plugin Groups

If you need to run FlexMojos goals from the command-line, it will be more convenient if you add the Sonatype Plugin groups to your Maven Settings. To do this, open up '~/.m2/settings.xml' and add the following plugin groups:

.Adding Sonatype Plugins to Maven Settings
----
<pluginGroups>
    <pluginGroup>com.sonatype.maven.plugins</pluginGroup>
    <pluginGroup>org.sonatype.plugins</pluginGroup>
</pluginGroups>
----

 Once you've added these plugin groups to your Maven Settings you can invoke a FlexMojos goal using the plugin prefix +flexmojos+. Without this configuration, calling the +flexbuilder+ goal would involve the following command-line:

----
$ mvn org.sonatype.flexmojos:flexmojos-maven-plugin:${flexmojos.version}:flexbuilder
----

With the org.sonatype.plugins group in your Maven settings, the same goal can be invoked with:

----
$ mvn flexmojos:flexbuilder
----

[[flex-dev-sect-creating-with-archetype]]
=== Creating a Flex Mojos Project from an Archetype

Flexmojos has a set of archetypes which can be used to quickly create a new Flex project. The following archetypes are all in the +org.sonatype.flexmojos+ group with a version of +${flexmojos.version}+:

flexmojos-archetypes-library::

  Creates a simple Flex Library project which produces a SWC

flexmojos-archetypes-application::

  Creates a simple Flex Application with produces a SWF

flexmojos-archetypes-modular-webapp::

  Creates a Multimodule project which consists of a project that produces a SWC which is consumed by a project which produces a SWF that is ultimately presented in a project that generates a WAR

[[flex-dev-sect-library-archetype]]
==== Creating a Flex Library

To create a Flex Library Project, execute the following command at the command-line:

----
$ mvn archetype:generate \
-DarchetypeRepository=http://repository.sonatype.org/content/groups/public\
-DarchetypeGroupId=org.sonatype.flexmojos \
-DarchetypeArtifactId=flexmojos-archetypes-library \
-DarchetypeVersion=${flexmojos.version}
[INFO] Scanning for projects...
[INFO] Searching repository for plugin with prefix: 'archetype'.
[INFO] com.sonatype.maven.plugins: checking for updates from central
...
[INFO] [archetype:generate]
[INFO] Generating project in Interactive mode
[INFO] Archetype defined by properties
...
Define value for groupId: : +org.sonatype.test+
Define value for artifactId: : +sample-library+
Define value for version:  1.0-SNAPSHOT: : +1.0-SNAPSHOT+
Define value for package:  org.sonatype.test: : +org.sonatype.test+ 
Confirm properties configuration:
groupId: org.sonatype.test
artifactId: sample-library
version: 1.0-SNAPSHOT
package: org.sonatype.test
Y: : +Y+[INFO] Parameter: groupId, Value: org.sonatype.test
[INFO] Parameter: packageName, Value: org.sonatype.test
[INFO] Parameter: basedir, Value: /Users/Tim
[INFO] Parameter: package, Value: org.sonatype.test
[INFO] Parameter: version, Value: 1.0-SNAPSHOT
[INFO] Parameter: artifactId, Value: sample-library
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESSFUL

----

If you look in the directory 'sample-library/' you will see that the project consists of the directory structure shown in <<fig-flex-dev-library-archetype-fs>>.

[[fig-flex-dev-library-archetype-fs]]
.Flexmojo Library Archetype File Structure
image::figs/web/flex-dev-arche-simple-lib-fs.png[]

The product of the simple Flex library archetype only contains three files: a POM, one source, and a unit test. Let's examine each of these files. First, the Project Object Model (POM).

[[fig-flex-dev-simple-lib-pom]]
.Project Object Model for Flex Library Archetype
----
<project xmlns="http://maven.apache.org/POM/4.0.0" 
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
                             http://maven.apache.org/maven-v4_0_0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>org.sonatype.test</groupId>
    <artifactId>sample-library</artifactId>
    <version>1.0-SNAPSHOT</version>
    <packaging>swc</packaging>

    <name>sample-library Flex</name>

    <build>
        <sourceDirectory>src/main/flex</sourceDirectory>
        <testSourceDirectory>src/test/flex</testSourceDirectory>
        <plugins>
            <plugin>
                <groupId>org.sonatype.flexmojos</groupId>
                <artifactId>flexmojos-maven-plugin</artifactId>
                <version>3.5.0</version>
                <extensions>true</extensions>
            </plugin>
        </plugins>
    </build>

    <dependencies>
        <dependency>
            <groupId>com.adobe.flex.framework</groupId>
            <artifactId>flex-framework</artifactId>
            <version>3.2.0.3958</version>
            <type>pom</type>
        </dependency>

        <dependency>
            <groupId>com.adobe.flexunit</groupId>
            <artifactId>flexunit</artifactId>
            <version>0.85</version>
            <type>swc</type>
            <scope>test</scope>
        </dependency>
    </dependencies>

    <profiles>
        <profile>
            <id>m2e</id>
            <activation>
                <property>
                    <name>m2e.version</name>
                </property>
            </activation>
            <build>
                <plugins>
                    <plugin>
                        <groupId>org.maven.ide.eclipse</groupId>
                        <artifactId>lifecycle-mapping</artifactId>
                        <version>0.9.9-SNAPSHOT</version>
                        <configuration>
                            <mappingId>customizable</mappingId>
                            <configurators>
                                <configurator 
                                     id='org.maven.ide.eclipse.configuration.flex.configurator' />
                            </configurators>
                            <mojoExecutions>
                                <mojoExecution>
                                    org.apache.maven.plugins:maven-resources-plugin::
                                </mojoExecution>
                            </mojoExecutions>
                        </configuration>
                    </plugin>
                </plugins>
                <pluginManagement>
                    <plugins>
                        <plugin>
                            <groupId>org.apache.maven.plugins</groupId>
                            <artifactId>maven-resources-plugin</artifactId>
                            <version>2.4</version>
                        </plugin>
                    </plugins>
                </pluginManagement>
            </build>
        </profile>
    </profiles>

</project>
----

<<fig-flex-dev-simple-lib-pom>> is very simple, the key to this POM is the +flexmojos-maven-plugin+ configuration which sets +extensions+ to +true+. This configuration customizes the lifecycle for the +swc+ packaging which is defined in the +flexmojos-maven-plugin+. The archetype then includes the +flex-framework+ dependency and the +flexmojos-unittest-support+ test-scoped dependency. The +flex-framework+ dependency is a POM which contains references to the SWC libraries and resources required to compile Flex applications.

In <<fig-flex-dev-simple-lib-pom>>, the packaging is very critical. A POMs packaging type controls the lifecycle it uses to produce build output. The value +swc+ in the packaging element is Maven's cue to look for the Flex-specific lifecycle customizations which are provided by the +flexmojos-maven-plugin+. The other important part of this POM is the build element which specifies the location of the Flex source code and the Flex unit tests. Next, let's take a quick look at <<ex-flex-dev-lib-as>> which contains the sample Actionscript which was created by this archetype.

[[ex-flex-dev-lib-as]]
.Flex Library Archetype's Sample App Class
----
package org.sonatype.test {
public class App {
public static function greeting(name:String):String {
return "Hello, " + name;
}
}
}
----

While this code is underwhelming, it does provide you with a quick model and a quick pointer: "Place More Code Here". While it might seem silly to test code this simple, a sample test named 'TestApp.as' is provides in the 'src/test/flex' directory. This test is shown in <<ex-flex-dev-test-app>>.

[[ex-flex-dev-test-app]]
.Unit Test for Library Archetype's App Class
----
package org.sonatype.test {

    import flexunit.framework.TestCase;

    public class TestApp extends TestCase {

        /**
         * Tests our greeting() method
         */
        public function testGreeting():void {
            var name:String = "Buck Rogers";
            var expectedGreeting:String = "Hello, Buck Rogers";

            var result:String = App.greeting(name);
            assertEquals("Greeting is incorrect", expectedGreeting, result);
        }
    }
}
----

To run this build, go to the sample-library project directory and run mvn install.

----
$ mvn install
[INFO] Scanning for projects...
[INFO] ------------------------------------------------------------------------
[INFO] Building sample-library Flex
[INFO]task-segment: [install]
[INFO] ------------------------------------------------------------------------
[INFO] [resources:resources]
[INFO] [flexmojos:compile-swc]
[INFO] flexmojos ${flexmojos.version} - GNU GPL License (NO WARRANTY) - \
See COPYRIGHT file
[WARNING] Nothing expecified to include.  Assuming source and resources folders.
[INFO] Flex compiler configurations:
-compiler.headless-server=false 
-compiler.keep-all-type-selectors=false 
-compiler.keep-generated-actionscript=false 
-compiler.library-path ~/.m2/repository/com/adobe/flex/framework/flex/\
3.2.0.3958...
-compiler.namespaces.namespace http://www.adobe.com/2006/mxml 
target/classes/configs/mxml-manifest.xml 
-compiler.optimize=true 
-compiler.source-path src/main/flex 
...
[INFO] [resources:testResources]
[WARNING] Using platform encoding (MacRoman actually) to copy filtered \
resources, i.e.  build is platform dependent!
[INFO] skip non existing resourceDirectory src/test/resources
[INFO] [flexmojos:test-compile]
[INFO] flexmojos ${flexmojos.version} - GNU GPL License (NO WARRANTY) - \
See COPYRIGHT file
[INFO] Flex compiler configurations:
-compiler.include-libraries ~/.m2/repository/org/sonatype/flexmojos/\
flexmojos-unittest-support...
-compiler.keep-generated-actionscript=false 
-compiler.library-path ~/.m2/repository/com/adobe/flex/framework/flex
3.2.0.3958/flex-3.2.0.... 
-compiler.optimize=true 
-compiler.source-path src/main/flex target/test-classes src/test/flex 
-compiler.strict=true 
-target-player 9.0.0 
-use-network=true 
-verify-digests=true -load-config= 
[INFO] Already trust on target/test-classes/TestRunner.swf
[INFO] [flexmojos:test-run]
[INFO] flexmojos ${flexmojos.version} - GNU GPL License (NO WARRANTY) - \
See COPYRIGHT file
[INFO] flexunit setup args: null
[INFO] ------------------------------------------------------------------------
[INFO] Tests run: 1, Failures: 0, Errors: 0, Time Elpased: 0 sec
[INFO] [install:install]

----

NOTE: To execute Flex unit tests you will need to configure your PATH environment variable to include the Flash Player. For more information about configuring FlexMojos for unit tests, see <<flex-dev-sect-configuring-unit-tests>>. 

When you ran +mvn install+ on this project, you should notice in the output that Maven and Flexmojos plugin is take care of managing all of the libraries and the dependencies for the Flex compiler. Much like Maven excels at helping Java developers manage the contents of a Java classpath, Maven can help Flex developers manage the complex of compile paths. You also might have been shocked when the Flexmojos project started a web browser or the Flash Player and used it to execute the TestApp.as class against the project's source code. 

[[flex-dev-sect-application-archetype]]
==== Creating a Flex Application





To create a Flex application from a Maven archetype,
execute the following command:

----
$ mvn archetype:generate \
      -DarchetypeRepository=http://repository.sonatype.org/content/groups/public\
      -DarchetypeGroupId=org.sonatype.flexmojos \
      -DarchetypeArtifactId=flexmojos-archetypes-application \
      -DarchetypeVersion=${flexmojos.version}
[INFO] Scanning for projects...
[INFO] Searching repository for plugin with prefix: 'archetype'.
[INFO] com.sonatype.maven.plugins: checking for updates from central
...
[INFO] [archetype:generate]
[INFO] Generating project in Interactive mode
[INFO] Archetype defined by properties
...
Define value for groupId: : +org.sonatype.test+
Define value for artifactId: : +sample-application+
Define value for version:  1.0-SNAPSHOT: : +1.0-SNAPSHOT+
Define value for package:  org.sonatype.test: : +org.sonatype.test+ 
Confirm properties configuration:
groupId: org.sonatype.test
artifactId: sample-library
version: 1.0-SNAPSHOT
package: org.sonatype.test
Y: : +Y+
[INFO] Parameter: groupId, Value: org.sonatype.test
[INFO] Parameter: packageName, Value: org.sonatype.test
[INFO] Parameter: basedir, Value: /Users/Tim/flex-sample
[INFO] Parameter: package, Value: org.sonatype.test
[INFO] Parameter: version, Value: 1.0-SNAPSHOT
[INFO] Parameter: artifactId, Value: sample-application
[INFO] BUILD SUCCESSFUL


----

If you look in the directory sample-application/ you will see the filesystem shown in <<fig-flex-dev-dir-app-fs>>.

[[fig-flex-dev-dir-app-fs]]
.Directory Structure for Flex Application Archetype
image::figs/web/flex-dev-arche-simple-app-fs.png[]

Building an application from the Application archetype produces the following POM.

[[ex-flex-dev-app-pom]]
.POM for Flex Application Archetype
----
<project xmlns="http://maven.apache.org/POM/4.0.0" 
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
                             http://maven.apache.org/maven-v4_0_0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>org.sonatype.test</groupId>
    <artifactId>sample-application</artifactId>
    <version>1.0-SNAPSHOT</version>
    <packaging>swf</packaging>

    <name>sample-application Flex</name>

    <build>
        <sourceDirectory>src/main/flex</sourceDirectory>
        <testSourceDirectory>src/test/flex</testSourceDirectory>
        <plugins>
            <plugin>
                <groupId>org.sonatype.flexmojos</groupId>
                <artifactId>flexmojos-maven-plugin</artifactId>
                <version>3.5.0</version>
                <extensions>true</extensions>
            </plugin>
        </plugins>
    </build>

    <dependencies>
        <dependency>
            <groupId>com.adobe.flex.framework</groupId>
            <artifactId>flex-framework</artifactId>
            <version>3.2.0.3958</version>
            <type>pom</type>
        </dependency>

        <dependency>
            <groupId>com.adobe.flexunit</groupId>
            <artifactId>flexunit</artifactId>
            <version>0.85</version>
            <type>swc</type>
            <scope>test</scope>
        </dependency>
    </dependencies>

    <profiles>
        <profile>
            <id>m2e</id>
            <activation>
                <property>
                    <name>m2e.version</name>
                </property>
            </activation>
            <build>
                <plugins>
                    <plugin>
                        <groupId>org.maven.ide.eclipse</groupId>
                        <artifactId>lifecycle-mapping</artifactId>
                        <version>0.9.9-SNAPSHOT</version>
                        <configuration>
                            <mappingId>customizable</mappingId>
                            <configurators>
                                <configurator 
                                     id='org.maven.ide.eclipse.configuration.flex.configurator' />
                            </configurators>
                            <mojoExecutions>
                                <mojoExecution>
                                    org.apache.maven.plugins:maven-resources-plugin::
                                </mojoExecution>
                            </mojoExecutions>
                        </configuration>
                    </plugin>
                </plugins>
                <pluginManagement>
                    <plugins>
                        <plugin>
                            <groupId>org.apache.maven.plugins</groupId>
                            <artifactId>maven-resources-plugin</artifactId>
                            <version>2.4</version>
                        </plugin>
                    </plugins>
                </pluginManagement>
            </build>
        </profile>
    </profiles>

</project>
----

 The difference between <<ex-flex-dev-app-pom>> and <<fig-flex-dev-simple-lib-pom>> is that the +packaging+ element is +swf+ instead of +swc+. By setting the packaging to +swf+, the project will produce a Flex application in 'target/sample-application-1.0-SNAPSHOT.swf'. The sample application created by this archetype displays the Text "Hello World". 'Main.mxml' can be found in 'src/main/flex'.

.Sample Application Main.mxml
----
<mx:Application xmlns:mx="http://www.adobe.com/2006/mxml" layout="absolute">
    <mx:Text text="Hello World!"/>
</mx:Application>
----

 This application also creates a simple FlexUnit test that does nothing more than print out a trace message. The sample unit test is in 'src/test/flex/org/sonatype/test'.

.Unit Test for Main.mxml
----
package org.sonatype.test 
{

    import flexunit.framework.TestCase;
    import Main;

    public class TestApp extends TestCase 
    {

        public function testNothing():void 
        {
            //TODO un implemented
            trace("Hello test"); 
        }
    }
}
----

[[flex-dev-sect-multimodule-archetype]]
==== Creating a Multi-module Project: Web Application with a Flex

To create a multi-module project consisting of a Flex Library project referenced by a Flex Application, referenced by a Web Application.

----
$ mvn archetype:generate \
      -DarchetypeRepository=http://repository.sonatype.org/content/groups/public\
      -DarchetypeGroupId=org.sonatype.flexmojos \
      -DarchetypeArtifactId=flexmojos-archetypes-modular-webapp \
      -DarchetypeVersion=${flexmojos.version}
[INFO] Scanning for projects...
[INFO] Searching repository for plugin with prefix: 'archetype'.
[INFO] com.sonatype.maven.plugins: checking for updates from central
...
[INFO] [archetype:generate]
[INFO] Generating project in Interactive mode
[INFO] Archetype defined by properties
...
Define value for groupId: : +org.sonatype.test+
Define value for artifactId: : +sample-multimodule+
Define value for version:  1.0-SNAPSHOT: : +1.0-SNAPSHOT+
Define value for package:  org.sonatype.test: : +org.sonatype.test+ 
Confirm properties configuration:
groupId: org.sonatype.test
artifactId: sample-library
version: 1.0-SNAPSHOT
package: org.sonatype.test
Y: : +Y+
[INFO] Parameter: groupId, Value: org.sonatype.test
[INFO] Parameter: packageName, Value: org.sonatype.test
[INFO] Parameter: basedir, Value: /Users/Tim
[INFO] Parameter: package, Value: org.sonatype.test
[INFO] Parameter: version, Value: 1.0-SNAPSHOT
[INFO] Parameter: artifactId, Value: sample-multimodule
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESSFUL

----

If you look in the 'sample-multimodule/' directory, you will see a directory structure which contains three projects swc, swf, and war.

[[fig-flex-dev-multimodule-archetype-fs]]
.Directory Structure for Flex Multimodule Archetype
image::figs/web/flex-dev-arche-multimodule-fs.png[]

The simple top-level POM in this multimodule project is shown in . It consists of module references to the swc, swf, and war modules.

.Top-level POM Created by Modular Web Application Archetype
----
<project xmlns="http://maven.apache.org/POM/4.0.0" 
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
                             http://maven.apache.org/maven-v4_0_0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <groupId>org.sonatype.test</groupId>
    <artifactId>sample-multimodule</artifactId>
    <version>1.0-SNAPSHOT</version>
    <packaging>pom</packaging>

    <modules>
        <module>swc</module>
        <module>swf</module>
        <module>war</module>
    </modules>
</project>
----

The swc project has a simple POM that resembles the POM shown in <<fig-flex-dev-simple-lib-pom>>. Note that the +artifactId+ in this POM differs from the name of the module directory and is +swc-swc+.

.swc Module POM
----
<project xmlns="http://maven.apache.org/POM/4.0.0" 
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
                             http://maven.apache.org/maven-v4_0_0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <parent>
        <groupId>org.sonatype.test</groupId>
        <artifactId>sample-multimodule</artifactId>
        <version>1.0-SNAPSHOT</version>
    </parent>

    <groupId>org.sonatype.test</groupId>
    <artifactId>swc</artifactId>
    <version>1.0-SNAPSHOT</version>
    <packaging>swc</packaging>

    <name>swc Library</name>

    <build>
        <sourceDirectory>src/main/flex</sourceDirectory>
        <testSourceDirectory>src/test/flex</testSourceDirectory>
        <plugins>
            <plugin>
                <groupId>org.sonatype.flexmojos</groupId>
                <artifactId>flexmojos-maven-plugin</artifactId>
                <version>3.5.0</version>
                <extensions>true</extensions>
                <configuration>
                    <locales>
                        <locale>en_US</locale>
                    </locales>
                </configuration>
            </plugin>
        </plugins>
    </build>

    <dependencies>
        <dependency>
            <groupId>com.adobe.flex.framework</groupId>
            <artifactId>flex-framework</artifactId>
            <version>3.2.0.3958</version>
            <type>pom</type>
        </dependency>

        <dependency>
            <groupId>com.adobe.flexunit</groupId>
            <artifactId>flexunit</artifactId>
            <version>0.85</version>
            <type>swc</type>
            <scope>test</scope>
        </dependency>
    </dependencies>

    <profiles>
        <profile>
            <id>m2e</id>
            <activation>
                <property>
                    <name>m2e.version</name>
                </property>
            </activation>
            <build>
                <plugins>
                    <plugin>
                        <groupId>org.maven.ide.eclipse</groupId>
                        <artifactId>lifecycle-mapping</artifactId>
                        <version>0.9.9-SNAPSHOT</version>
                        <configuration>
                            <mappingId>customizable</mappingId>
                            <configurators>
                                <configurator 
                                     id="org.maven.ide.eclipse.configuration.flex.configurator" />
                            </configurators>
                            <mojoExecutions>
                                <mojoExecution>
                                    org.apache.maven.plugins:maven-resources-plugin::
                                </mojoExecution>
                            </mojoExecutions>
                        </configuration>
                    </plugin>
                </plugins>
                <pluginManagement>
                    <plugins>
                        <plugin>
                            <groupId>org.apache.maven.plugins</groupId>
                            <artifactId>maven-resources-plugin</artifactId>
                            <version>2.4</version>
                        </plugin>
                    </plugins>
                </pluginManagement>
            </build>
        </profile>
    </profiles>

</project>
----

The swf module's POM resembles the POM in <<ex-flex-dev-app-pom>> adding a dependency on the +swc-swc+ artifact. Note that the following POM defines an +artifactId+ that differs from the directory that stores the module; the artifactId in the following POM is +swf-swf+.

[[ex-flex-swf-module-pom]]
.swf module POM
----
<project xmlns="http://maven.apache.org/POM/4.0.0" 
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
                             http://maven.apache.org/maven-v4_0_0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <parent>
        <groupId>org.sonatype.test</groupId>
        <artifactId>sample-multimodule</artifactId>
        <version>1.0-SNAPSHOT</version>
    </parent>

    <groupId>org.sonatype.test</groupId>
    <artifactId>swf</artifactId>
    <version>1.0-SNAPSHOT</version>
    <packaging>swf</packaging>

    <name>swf Application</name>

    <build>
        <sourceDirectory>src/main/flex</sourceDirectory>
        <testSourceDirectory>src/test/flex</testSourceDirectory>
        <plugins>
            <plugin>
                <groupId>org.sonatype.flexmojos</groupId>
                <artifactId>flexmojos-maven-plugin</artifactId>
                <version>3.5.0</version>
                <extensions>true</extensions>
                <configuration>
                    <locales>
                        <locale>en_US</locale>
                    </locales>
                </configuration>
            </plugin>
        </plugins>
    </build>

    <dependencies>
        <dependency>
            <groupId>com.adobe.flex.framework</groupId>
            <artifactId>flex-framework</artifactId>
            <version>3.2.0.3958</version>
            <type>pom</type>
        </dependency>

        <dependency>
            <groupId>com.adobe.flexunit</groupId>
            <artifactId>flexunit</artifactId>
            <version>0.85</version>
            <type>swc</type>
            <scope>test</scope>
        </dependency>

        <dependency>
            <groupId>org.sonatype.test</groupId>
            <artifactId>swc</artifactId>
            <version>1.0-SNAPSHOT</version>
            <type>swc</type>
        </dependency>
    </dependencies>

    <profiles>
        <profile>
            <id>m2e</id>
            <activation>
                <property>
                    <name>m2e.version</name>
                </property>
            </activation>
            <build>
                <plugins>
                    <plugin>
                        <groupId>org.maven.ide.eclipse</groupId>
                        <artifactId>lifecycle-mapping</artifactId>
                        <version>0.9.9-SNAPSHOT</version>
                        <configuration>
                            <mappingId>customizable</mappingId>
                            <configurators>
                                <configurator 
                                     id="org.maven.ide.eclipse.configuration.flex.configurator" />
                            </configurators>
                            <mojoExecutions>
                                <mojoExecution>
                                    org.apache.maven.plugins:maven-resources-plugin::
                                </mojoExecution>
                            </mojoExecutions>
                        </configuration>
                    </plugin>
                </plugins>
                <pluginManagement>
                    <plugins>
                        <plugin>
                            <groupId>org.apache.maven.plugins</groupId>
                            <artifactId>maven-resources-plugin</artifactId>
                            <version>2.4</version>
                        </plugin>
                    </plugins>
                </pluginManagement>
            </build>
        </profile>
    </profiles>

</project>
----

When you declare a dependency on a SWC, you'll need to specify the type of the dependency so that Maven can locate the appropriate artifact in the remote or local repository. In this case, the +swf-swf+ project depends upon the SWC that is generated by the +swc-swc+ project. When you add the dependency to the +swf-swf+ project, the FlexMojos plugin will add the appropriate SWC file to the Flex Compiler's library path.

Next, take a look at the simple POM in the war module.

[[ex-flex-war-module-pom]]
.war module POM
----
<project xmlns="http://maven.apache.org/POM/4.0.0" 
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
                             http://maven.apache.org/maven-v4_0_0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <artifactId>sample-multimodule</artifactId>
        <groupId>org.sonatype.test</groupId>
        <version>1.0-SNAPSHOT</version>
    </parent>

    <groupId>org.sonatype.test</groupId>
    <artifactId>war</artifactId>
    <version>1.0-SNAPSHOT</version>

    <packaging>war</packaging>
    <build>
        <plugins>
            <plugin>
                <groupId>org.sonatype.flexmojos</groupId>
                <artifactId>flexmojos-maven-plugin</artifactId>
                <version>3.5.0</version>
                <executions>
                    <execution>
                        <goals>
                            <goal>copy-flex-resources</goal>
                        </goals>
                    </execution>
                </executions>
            </plugin>
            <plugin>
                <groupId>org.mortbay.jetty</groupId>
                <artifactId>maven-jetty-plugin</artifactId>
                <version>6.1.17</version>
            </plugin>
        </plugins>
    </build>

    <dependencies>
        <dependency>
            <groupId>org.sonatype.test</groupId>
            <artifactId>swf</artifactId>
            <version>1.0-SNAPSHOT</version>
            <type>swf</type>
        </dependency>
    </dependencies>

</project>
----

The POM shown in <<ex-flex-war-module-pom>> configures the FlexMojos plugin to execute the +copy-flex-resources+ goal for this project. The +copy-flex-resources+ goal will copy SWF application into the web application's document root. In this project, running a build and creating a WAR will copy the 'swf-swf-1.0-SNAPSHOT.swf' file to the web application's root directory in 'target/war-war-1.0-SNAPSHOT'.

To build the multimodule web application project, run +mvn install+ from the top-level directory. This should build the +swc-swc+, +swf-swf+, and +war-war+ artifacts and product a WAR file in war'/target/war-war-1.0-SNAPSHOT.war' which contains the 'swf-swf-1.0-SNAPSHOT.swf' in the document root of the web application.

NOTE: To execute Flex unit tests you will need to configure your PATH environment variable to include the Flash Player. For more information about configuring FlexMojos for unit tests, see <<flex-dev-sect-configuring-unit-tests>>.   

[[flex-dev-sect-custom-lifecycle]]
=== The FlexMojos Lifecycle

The FlexMojos Maven plugin customizes the lifecycle based on the packaging. If your project has a +packaging+ of type +swc+ or +swf,+ the FlexMojos plugin with execute a customized lifecycle if your plugin configuration sets the extensions to true. <<ex-flex-dev-extensions-true>> shows the plugin configuration for the flexmojos-maven-plugin with the +extensions+ set to +true+.

[[ex-flex-dev-extensions-true]]
.Setting Plugin Extensions to True for Custom Flex Lifecycle
----
<build>
    <sourceDirectory>src/main/flex</sourceDirectory>
    <testSourceDirectory>src/test/flex</testSourceDirectory>
    <plugins>
        <plugin>
            <groupId>org.sonatype.flexmojos</groupId>
            <artifactId>flexmojos-maven-plugin</artifactId>
            <version>${flexmojos.version}</version>
            *<extensions>true</extensions>*
            <configuration>
                <locales>
                    <locale>en_US</locale>
                </locales>
            </configuration>
        </plugin>
    </plugins>
</build>
----


[[flex-dev-sect-lifecycle-swc]]
==== The SWC Lifecycle

When the packaging is swc, FlexMojos will execute the lifecycle shown in <<fig-flex-dev-swc-lifecycle>>. The highlighted goals are goals from the FlexMojos plugin, the goals which are not highlights are standard goals from the Core Maven plugins.

[[fig-flex-dev-swc-lifecycle]]
.The FlexMojos SWC Lifecycle
image::figs/web/flex-dev_swc-lifecycle.png[]

The FlexMojos contributed goals are:

flexmojos:compile-swc::

   This goal compiles all of the Actionscript and MXML files in the +sourceDirectory+ into a SWC. A SWC is an Adobe library or class file which contains components and resources used in Flex applications.  

flexmojos:test-compile::

   This goal compiles all of the Actionscript and MXML files in the +testSourceDirectory+.  

flexmojos:test-run::

   This goal executes unit tests using the Flash Player. This goal can only run if the Flash Player has been configured as described in <<flex-dev-sect-configuring-unit-tests>>.

[[flex-dev-sect-lifecycle-swf]]
==== The SWF Lifecycle

When the packaging is swf, FlexMojos will execute the lifecycle shown in <<fig-flex-dev-swf-lifecycle>>. The highlighted goals are goals from the FlexMojos plugin, the goals which are not highlights are standard goals from the Core Maven plugins.

[[fig-flex-dev-swf-lifecycle]]
.The FlexMojos SWF Lifecycle
image::figs/web/flex-dev_swf-lifecycle.png[]

The FlexMojos contributed goals are:

flexmojos:compile-swf::

   This goal compiles all of the Actionscript and MXML files in the +sourceDirectory+ into a SWF. A SWF is a file which contains an application that can be render by the Adobe Flash Player or Adobe AIR software.  

flexmojos:test-compile::

   This goal compiles all of the Actionscript and MXML files in the +testSourceDirectory+.  

flexmojos:test-run::

   This goal executes unit tests using the Flash Player. This goal can only run if the Flash Player has been configured as described in <<flex-dev-sect-configuring-unit-tests>>. 

[[flex-dev-sect-goals]]
=== FlexMojos Plugin Goals

The FlexMojos Maven Plugin contains the following goals:

flexmojos:asdoc::

  Generates documentation for Actionscript source files

flexmojos:asdoc-report::

  Generates documentation for Actionscript sources as a report that can be included in a Maven site

flexmojos:compile-swc::

  Compiles Flex source (Actionscript and MXML) into a SWC library for use in a Flex or AIR application

flexmojos:compile-swf::

  Compiles Flex source (Actionscript and MXML) into a SWF for use in the Adobe Flash Player or Adobe AIR Runtime

flexmojos:copy-flex-resources::

  Copies Flex resources into a web application project

flexmojos:flexbuilder::

  Generates project files for use in Adobe Flex Builder

flexmojos:generate::

  Generates Actionscript 3 based on Java classes using Granite GAS3

flexmojos:optimize::

  Goal which run post-link SWF optimization on swc files. This goal is used to produce RSL files.

flexmojos:sources::

  Create a JAR which contains all the sources for a Flex project

flexmojos:test-compile::

  Compile all test classes in a Flex project

flexmojos:test-run::

  Run the tests using the Adobe Flash Player

flexmojos:test-swc::

  Build a SWC containing the test classes for a specific project

flexmojos:wrapper::

  Generate an HTML wrapper for a SWF application

[[flex-dev-sect-gen-asdoc]]
==== Generating Actionscript Documentation

You can run the asdoc or asdoc-report goals to generate documentation for Actionscript. Once the goals has completed, the documentation will be saved to '+++${basedir}/target/asdoc+++' as HTML. <<fig-flex-dev-actionscript>> shows the result of running the +asdoc+ goal against the Flexmojos application archetype project.


[[fig-flex-dev-actionscript]]
.Actionscript Documentation Generated by the FlexMojos Plugin
image::figs/web/flex-dev_asdoc-browser.png[]

[[flex-dev-sect-compiling]]
==== Compiling Flex Source

FlexMojos contains a number of goals which compile Actionscript and MXML into SWCs and SWFs. The compile-swc and compile-swf goals are used to generate output from a project's source, and test-compile is used to compile unit tests. In the simple projects created by the FlexMojos archetypes, the compile-swc and compile-swf goals are called because the project customizes the lifecycle and binds either compile-swc or compile-swf to the compile phase and test-compile to the test-compile phase. If you need to configure the options for the FlexMojos compiler, you would configure the FlexMojos plugin configuration. For example, if you wanted the application with the POM shown in <<ex-flex-dev-app-pom>> to ignore certain code-level warnings on compile and use some customized font settings, you might use the plugin configuration shown in <<ex-flex-dev-customizing-compiler>>.

[[ex-flex-dev-customizing-compiler]]
.Customizing the Compiler Plugin
----
<build>
    <sourceDirectory>src/main/flex</sourceDirectory>
    <testSourceDirectory>src/test/flex</testSourceDirectory>
    <plugins>
        <plugin>
            <groupId>org.sonatype.flexmojos</groupId>
            <artifactId>flexmojos-maven-plugin</artifactId>
            <version>${flexmojos.version}</version>
            <extensions>true</extensions>
            <configuration>
                <configurationReport>true</configurationReport>
                <warnings>
                    <arrayTostringChanges>true</arrayTostringChanges>
                    <duplicateArgumentNames>false</duplicateArgumentNames>
                </warnings>
                <fonts>
                    <advancedAntiAliasing>true</advancedAntiAliasing>
                    <flashType>true</flashType>
                    <languages>
                        <englishRange>U+0020-U+007E</englishRange>
                    </languages>
                    <localFontsSnapshot>
                        ${basedir}/src/main/resources/fonts.ser
                    </localFontsSnapshot>
                    <managers>
                        <manager>flash.fonts.BatikFontManager</manager>
                    </managers>
                    <maxCachedFonts>20</maxCachedFonts>
                    <maxGlyphsPerFace>1000</maxGlyphsPerFace>
                </fonts>
            </configuration>
        </plugin>
    </plugins>
</build>
----

[[flex-dev-sect-flexbuilder]]
==== Generating Flex Builder Project Files

To generate Flex Builder project files for a FlexMojos project, configure the plugin groups as described in <<flex-dev-sect-plugin-group>>, and run the +flexbuilder+ goal:

----
$ mvn flexmojos:flexbuilder
----

Running this goal will create a '.project', '.settings/org.eclipse.core.resources.prefs', '.actionScriptProperties', and '.flexLibProperties'.  

[[flex-dev-sect-reports]]
=== FlexMojos Plugin Reports

The FlexMojos Maven Plugin contains the following report:

flexmojos:asdoc-report::

  Generates documentation for Actionscript sources as a report that can be included in a Maven site

[[flex-dev-sect-report-asdoc]]
==== Generating Actionscript Documentation Report

To generate the +asdoc-report+ as part of your Maven site build, add the following XML to your POM:

.Configuring the Actionscript Documentation Report
----
<reporting>
    <plugins>
        <plugin>
            <groupId>org.sonatype.flexmojos</groupId>
            <artifactId>flexmojos-maven-plugin</artifactId>
            <version>${flexmojos.version}</version>
            <reportSets>
                <reportSet>
                    <id>flex-reports</id>
                    <reports>
                        <report>asdoc-report</report>
                    </reports>
                </reportSet>
            </reportSets>
        </plugin>
    </plugins>
</reporting>
----

When you run +mvn site+, Maven will generate this report and place the results under the "Project Reports" menu as shown in <<fig-flex-dev-actionscript-report>>.

[[fig-flex-dev-actionscript-report]]
.Actionscript Documentation Report on Maven Site
image::figs/web/flex-dev_asdocs-report.png[]

If you need to pass in any configuration options to the asdoc-report, you will need add a configuration element to the +reportSets+ element as shown in <<ex-flex-dev-config-asdoc-report>>.

[[ex-flex-dev-config-asdoc-report]]
.Configuring the asdoc-report
----
<reporting>
    <plugins>
        <plugin>
            <groupId>org.sonatype.flexmojos</groupId>
            <artifactId>flexmojos-maven-plugin</artifactId>
            <version>${flexmojos.version}</version>
            <reportSets>
                <reportSet>
                    <id>flex-reports</id>
                    <reports>
                        <report>asdoc-report</report>
                    </reports>
                    <configuration>
                        <windowTitle>My TEST API Doc</windowTitle>
                        <footer>Copyright 2010 Sonatype</footer>
                    </configuration>
                </reportSet>
            </reportSets>
        </plugin>
    </plugins>
</reporting>
----

[[flex-dev-sect-dev]]
=== Developing and Customizing Flexmojos

The following sections guide you through some of first steps toward customizing or contributing to the Flexmojos project. Flexmojos is more than just a tool for people who are interested in compiling Actionscript into SWF and SWC artifacts, it is a community of developers. This section isn't for everyone, but, if you have an itch to scratch and you wish to participate, come on in.

[[flex-dev-sect-get-source]]
==== Get the Flexmojos Source Code

Flexmojos is an open source project hosted on the Sonatype Forge, and the source code for Flexmojos is stored in the Sonatype Forge Subversion repository. You can browse the contents of the Flexmojos Subversion repository by opening http://svn.sonatype.org/flexmojos/trunk[http://svn.sonatype.org/flexmojos/trunk] in a web browser.

[[flex-dev-svn-repo]]
.Flexmojos Subversion Repository
image::figs/web/flex-dev-subversion.png[]

If you are interested in participating in the Flexmojos project, you will likely want to checkout the current Flexmojos source code to your local machine. To checkout the Flexmojos source using Subversion, execute the following command at the command line:

----
$ svn co http://svn.sonatype.org/flexmojos/trunk flexmojos
A flexmojos
...
$ ls
COPYRIGHT   flexmojos-sandbox pom.xml
flexmojos-archetypesflexmojos-super-poms  src
flexmojos-maven-plugin  flexmojos-testing
flexmojos-parentflexmojos-touchstone

----

[[android-dev]]
== Android Application Development with Maven


[[android-dev-sect-intro]]
=== Introduction

Android is a mobile phone and embedded device operating system developed by the Open Handset Alliance. It is based on a Linux kernel with a virtual machine environment for managed application code using Java bytecode for the runtime code generation. The development environment is based on the Java language and JVM/JDK based tooling. The generated Java bytecode is transformed into Dalvik executable code optimized for constrained devices. Java is the default programming language and the API's are all Java based.

In most cases, development of Android applications is done within the Eclipse based Android Development Toolkit ADT. The optionally generated Apache Ant based build can be used to build applications outside the IDE. The Maven Android Plugin was created to allow development teams to build, deploy and release Android applications with Apache Maven, taking advantage of all the powerful features available like dependency management, reporting, code analysis and much more. 

[[android-dev-sect-config-build]]
=== Configuring Build Environment for Android Development

Before you attempt to build your Android libraries and applications with Maven, you will need to complete the following configuration tasks:

*  Install the Android SDK 

*  Install the Android API jar files into a local or remote Maven repository 

*  Configure Maven for simplified usage of the Maven Android Plugin  

[[android-dev-sect-sdk-install]]
==== Installing the Android SDK

The Maven Android Plugin requires the presence of the Android SDK in your development environment. The +ANDROID_HOME+ environment variable should be configured to point to the installation directory of the Android SDK. The SDK should be installed following the directions on the Android Developer web site at http://developer.android.com/sdk/index.html. For example if the SDK is installed in /opt/android-sdk-linux this can be achieved with 

----
export ANDROID_HOME=/opt/android-sdk-linux
----

on a Unix/bash based system or 

----
set ANDROID_HOME=C:\opt\android-sdk-linux
----

on a Windows system.

In addition to the SDK, the various platform versions you need for development should also be installed. Instructions for this process are located at http://developer.android.com/sdk/adding-components.html. You can install a subset of available platforms or simply install all available versions. Optionally, the path +ANDROID_HOME/tools+ can be added to the PATH variable to allow easy command line execution of the various tools provided with the SDK. 

[[android-dev-sect-repository-install]]
==== Android artifact install into Maven repository

Once the SDK is installed you will need to provide the API JAR files to Maven in a repository. The Maven Android SDK Deployer tool allows you to do that for a single machine in a local repository as well as for any number of machines in a remote repository server. <!-- TODO link to nexus... in general how much do we have to explain here about this stuff, i would prefer to add links to the nexus book chapters somehow.. --> The Maven Android SDK deployer tool is available for download at:

* http://github.com/mosabua/maven-android-sdk-deployer

Simply click on the +Download Source+ button and extract the downloaded zip or tar archive in a folder of your choice. A folder with a naming pattern of mosabua-maven-android-sdk-deployer-XXX with XXX being a revision number like df824df will be created. Change directories to this new maven-android-sdk directory: 

----
cd mosabua-maven-android-sdk-deployer-df824df
----

[[android-dev-sect-repository-install-local]]
===== Installation to local repository

In order to install the android API jar files from the different platform revisions into your local repository you run the command in the deployer folder.

----
mvn clean install
----

By default this will install all android.jar and maps.jar files into your local Maven repository. You should find all newly installed files in the +android+ and +com.google.android.maps+ group identifiers under '~/.m2/repository'. 

[[android-dev-sect-repository-install-remote]]
===== Installation to remote repository

The above deployment works fine for one machine, but if you need to supply a whole team of developers and a cluster of build machines with the artifacts, you will want to deploy the artifacts once to a remote repository server that is available to all users. If you are not currently using a repository manager, you should download Nexus and configure a user with permission to deploy artifacts to a repository. To get started with Nexus, read the http://www.sonatype.com/books/nexus-book/reference/install.html[Nexus Installation chapter] in the free, online Nexus book.

As a first step you will need to edit the +repo.url+ property in the pom.xml in the top folder of the Maven Android SDK Deployer tool to point to the repository you want to publish to. Then you need to add a server with the correct access credentials for the server to your Maven Settings file ('~/.m2/settings.xml'). 

.Snippet for settings.xml for the repository server access credentials
----
<settings>
    <servers>
        <server>
            <id>android.repo</id>
            <username>your username</username>
            <password>your password</password>
        </server>
    </servers>
</settings>
----

Once that configuration is completed you can deploy the artifacts with the command +mvn deploy+. As a result you should find the artifact in the repository of your remote server. 

[[android-dev-sect-repository-install-parts]]
===== Installation of a subset of all platforms

By default the Maven Android SDK Deployer tool will attempt to install or deploy all versions of the platforms artifacts into a repository. If you decide to only install a subset of the components the tool can be used with profile options to only install or deploy some artifacts. This can be done by specifying the platform API versions as a profile name: 

----
mvn install -P 2.1
----

Available profile names are +1.1+, +1.5+, +1.6+, +2.0+ and +2.1+.  

[[android-dev-sect-plugin-config]]
==== Configuring Maven for usage of the Maven Android Plugin

In order to use the Maven Android Plugin goals on the command line with the short plugin name +android+, you have to add the following +pluginGroups+ snippet to your +settings.xml+ file.


.Snippet for settings.xml to enable short plugin name usage
----
<pluginGroups>
    <pluginGroup>
        com.jayway.maven.plugins.android.generation2
    </pluginGroup>
</pluginGroups>
----

[[android-dev-sect-using]]
=== Android Application Development with the Maven Android Plugin

[[android-dev-sect-helloandroidexample]]
==== HelloFlashlight Example

The HelloFlashlight example application serves as a starting point to introduce you to the usage of the Maven Android Plugin. You can follow the same steps to introduce an Maven Android Plugin based build to your Android application. After the initial environment setup documented above, the Android Development Tools from http://developer.android.com/sdk/eclipse-adt.html were installed and used to create a new Android project.

To enable a Maven based build of the project the following pom.xml file was added in the root folder of the project:

.The HelloFlashlight pom.xml file
----
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
                             http://maven.apache.org/maven-v4_0_0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <groupId>com.simpligility.android</groupId>
    <artifactId>helloflashlight</artifactId>
    <version>0.1-SNAPSHOT</version>
    <packaging>apk</packaging>
    <name>HelloFlashlight</name>

    <dependencies>
        <dependency>
            <groupId>android</groupId>
            <artifactId>android</artifactId>
            <version>2.1_r1</version>
            <scope>provided</scope>
        </dependency>
    </dependencies>

    <build>
        <sourceDirectory>src</sourceDirectory>
        <plugins>
            <plugin>
                <groupId>
                    com.jayway.maven.plugins.android.generation2
                </groupId>
                <artifactId>maven-android-plugin</artifactId>
                <version>2.2.3-SNAPSHOT</version>
                <configuration>
                    <sdk>
                        <platform>2.1</platform>
                    </sdk>
                    <deleteConflictingFiles>
                        true
                    </deleteConflictingFiles>
                </configuration>
                <extensions>true</extensions>
            </plugin>
            <plugin>
                <artifactId>maven-compiler-plugin</artifactId>
                <configuration>
                    <source>1.5</source>
                    <target>1.5</target>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>
----

The highlights of this pom.xml are: 

*  the +packaging+ type of +apk+ 

*  the dependency to the Android platform jar 

*  and the build configuration with the Maven Android Plugin and the Compiler Plugin  

The Android Package +packaging+ type +apk+ is what activates the Android-specific lifecycle modifications of the Maven Android Plugin. It takes care of all the specific calls to the Android SDK tools, that process resources, convert Java bytecode and so on.

The declared dependency to the android platform jar has to use the version of the target platform as published into the Maven repository by the Maven Android SDK Deployer. It, in turn, takes the library version from the + Platform.Version+ and the +Pkg.Revision+ values in the +source.properties+ file in the respective platforms folder of the Android SDK. The current valid values are +1.1_r1+, +1.5_r3+, +1.6_r2+, +2.0_r1+, +2.0.1_r1+ and +2.1_r1+. Simply browse the android folder of your maven repository/repository server to see what the exact versions are.

The configuration of the Maven Compiler Plugin in the build is necessary since Android uses Java 5 language specification code with annotations, foreach loop and so on and the Java compiler needs to know that. The main configuration of the Maven Android Plugin is done in the build section, but out of the box only limited configuration is necessary.

To build the application and run it on an already started emulator you could use 

----
mvn clean install android:deploy
----

////
<!--TODO potentially add commandline output for build here-->
////

The code for the example application is available as part of the maven-android-plugin-samples available at http://code.google.com/p/maven-android-plugin/wiki/Samples. 

[[android-dev-sect-test]]
==== Testing Android Application Code

Testing Android Application code can be done in a unit test fashion with rich junit support as part of the Android SDK as well as integration type testing called instrumentation testing.

[[android-dev-sect-test-unit]]
===== Unit tests

The Maven Android plugin includes the execution of the Surefire plugin and as such unit tests can be included in the project like in any other project. The default path for test classes in the Eclipse and therefore Android Development Toolkit is +test+ and therefore Maven has to be configured to access code from there with the configuration 


.Adding the test folder to the build configuration
----
<build>
    <testSourceDirectory>test</testSourceDirectory>
    ...  
----

Alternatively the Maven conventions can be implemented by moving the source code for the application and the test source code into +src/main/java+ and +src/test/java+ and reconfiguring the Eclipse project files. 

[[android-dev-sect-test-instrumentation]]
===== Instrumentation tests

Instrumentation tests are integration tests bundled into an application that run on the emulator or device and interact with another deployed application to test the behaviour. The common setup to run instrumentation tests would be two parallel projects, one for the application and one for the instrumentation tests. These modules are tied together as modules of a parent pom.

The Maven Android Plugin Samples codebase contains two examples for a project set up in this manner. The setup of the instrumentation test application with the Maven Android Plugin is the same as for a normal application with the added dependency to the application that needs to be tested. It is important to add the +type+ of +apk+ to the dependency to allow the Maven Android Plugin to find the Android package of the application.

----
<dependency>
    <groupId>com.simpligility.android</groupId>
    <artifactId>intents</artifactId>
    <version>0.1</version>
    <type>apk</type>
</dependency>
----

[[android-dev-sect-maps]]
==== Using Add Ons like the Google Maps Extension

For many applications the normal Android SDK artifact (android.jar) will be sufficient, however some applications require add-ons. One of the more commonly used add-ons is the Google Maps add-on which provides access to the Google Maps API. The Maps add-on is deployed to your Maven repository by the Maven Android SDK Deployer tool. In order to access the API in your application you need to add a dependency to the add-on to your pom.xml like this:

.The dependency to the Google Maps API
----
<dependency>
    <groupId>com.google.android.maps</groupId>
    <artifactId>maps</artifactId>
    <version>7_r1</version>
    <scope>provided</scope>
</dependency>  
----

The valid versions currently are +3_r3+, +4_r2+, +5_r1+, +6_r1+ and +7_r1+. Simply browse the android folder of your maven repository/repository server to see what the versions are. 

[[android-dev-sect-multimodule]]
==== Multi Module Maven Android Projects

The Maven Android Plugin can be used in a multi-module project setup. An example setup would be 3 different modules linked via a parent pom.

Java Library Code::

   This first module could contain any business logic implemented in Java, or any other JVM based language actually, in a jar package.  

Android Application Code::

   This second module would depend on the first module and consist of all the interface code for the Android platform. It would need to use apk packaging and the Maven Android Plugin.  

Instrumentation Test::

   This third module would depend on the second module and implement the integration test of the application.   

Together with the use of other module to separate items it is possible to set up a multi module build for an Android application as well as a server side web application sharing e.g. the code for the core objects and business logic. 

[[android-dev-sect-dependencies]]
==== Using external dependencies

When using the Maven Android plugin there are three types of dependencies that are treated differently.

Regular dependencies to other Java libraries::

The Java byte code files (.class) of library dependencies as denoted in the normal Maven way are transformed to dalvik executable format like any source code of the current project and included in the Android package. All other files are included as contained in the source library. An example would look like this

----
<dependency>
    <groupId>com.simpligility</groupId>
    <artifactId>model</artifactId>
    <version>0.1</version>
</dependency>
----

Dependencies to other Android projects::

   Other Maven Android projects with packaging type apk declared as dependencies are deployed to the emulator prior to running the instrumentation tests in the integration test phase.

----
<dependency>
    <groupId>com.simpligility.android</groupId>
    <artifactId>intents</artifactId>
    <version>0.1</version>
    <type>apk</type>
</dependency>
----

Dependencies to other Android projects sources::

   Other Maven Android projects with packaging type apk declared as source dependencies are pulled into the current Android application with assets and resources and used to build an application combining all artifacts.. 

----
<dependency>
    <groupId>com.simpligility.android</groupId>
    <artifactId>tools</artifactId>
    <version>0.1</version>
    <type>apksources</type>
</dependency>
----

More details can be found at http://code.google.com/p/maven-android-plugin/wiki/ApkSourcesDependency.

[[android-dev-sect-custom-details]]
=== Maven Android Plugin Details

[[android-dev-sect-custom-lifecycle]]
==== Maven Android Plugin Lifecycle

The Android Maven plugin customizes the lifecycle based on the packaging. If your project has a +packaging+ of type+apk+ the Android plugin will execute a customized lifecycle.

The customised life cycle has the following additional executions in the default lifecycle.

generate-sources Phase::

   Use the Android Asset Packaging Tool (+aapt+) of the platform version specified in the pom to package the Android specific resources like +AndroidManifest.xml+, assets and resources.  

process-classes Phase::

   Run the +dx+ tool of the platform version specified in the pom to convert all classes (libraries, resources and project code) into davlik executable format.  

package Phase::

   Run the Android Package tool (+apk+) of the Android SDK to create and sign the Android package file (apk) for installation on the emulator or device.  

pre-integration-test Phase::

   Deploy the currently built Android application package (apk) as well as any other dependencies with +packaging+ type +apk+ to the emulator/device.  

integration-test Phase::

   Run the instrumentation test classes against the deployed application.

[[android-dev-sect-goals]]
==== Maven Android Plugin Goals

 The Maven Android Plugin contains the following goals:

android:apk::

   The +apk+ goal creates the android package (apk) file. By default the plugin signs the file with the debug keystore. The configuration parameter  can be used to disable the signing process.

----
<sign><debug>false<debug><sign>
----

android:deploy::

   The +deploy+ goal deploys the built apk file, or another specified apk, to a connected device or emulator. This goal is automatically performed when running through the +integration-test+ lifecycle phase on a project with instrumentation tests (e.g. +mvn install+ or +mvn integration-test+).  

android:deploy-dependencies::

   The +deploy-dependencies+ goal deploys all directly declared dependencies of +<type>apk</type>+ in this project. This goal is usually used in a project with instrumentation tests, to deploy the apk to test onto the device before running the deploying and running the instrumentation tests apk. The goal is automatically performed when running through the integration-test life cycle phase on a project with instrumentation tests (e.g. +mvn install+ or +mvn integration-test+).  

android:dex::

   The +dex+ goal converts compiled Java classes to the Android Dalivk Executable (dex) format.  

android:emulator-start::

   The +emulator-start+ goal starts the Android device emulator. The start up parameters can be configured in the Maven Android Plugin configuration in the pom.xml file

----
<configuration>
    ...
    <emulator>
        <avd>21</avd>
        <wait>6000</wait>
        <options>-no-skin</options>
    </emulator>
    ...
</configuration>   
----

or via command line parameters outside an actual project. 

----
mvn android:emulator-start \
-Dandroid.emulator.avd=Default \
-Dandroid.emulator.options=-no-skin \
-Dandroid.emulator.wait=10000  
----

android:emulator-stop::

   The +emulator-stops+ stops the Android device emulator and can be used inside or outside a Maven project folder.  

android:generate-sources::

   The +generate-sources+ goal generates +R.java+ based on the resources specified by the resources configuration parameter. It generates Java files based on aidl files. If the configuration parameter +deleteConflictingFiles+ is true (which it is by default), this goal has also deletes any R.java files found in the source directory, deletes any .java files with the same name as an .aidl file found in the source directory and deletes any Thumbs.db files found in the resource directory.  

android:instrument::

   The +instrument+ goal runs the instrumentation android package on the device/emulator.  

android:internal-integration-test::

   The +internal-integration-test+ goal is called automatically when the lifecycle reaches the +integration-test+ phase. It determines whether to call the goal instrument in this phase based on the existence of instrumentation test classes in the current project. The goal is internal to the plugin lifecycle and should not be used as separate invocation on the command line.  

android:internal-pre-integration-test::

   The +internal-pre-integration-test+ goal is called automatically when the lifecycle reaches +pre-integration-test+ phase. It determines whether to call the goals +android:deploy-dependencies+ and +android:deploy+ in this phase and if necessary invokes them. The goal is internal to the plugin lifecycle and should not be used as separate invocation on the command line.  

android:pull::

   The pull goal can be used to copy files or directories from the device.  

android:push::

   The pull goal can be used to copy files or directories to the device.  

android:undeploy::

   The undeploy goal removes the apk of the current project, or another specified apk, from the connected device.  


[[appendix-settings]]
== Appendix: Settings Details

[[appendix-settings-sect-quick-overview]]
=== Quick Overview

The settings element in the 'settings.xml' file contains elements used to define values which configure Maven execution. Settings in this file are settings which apply to many projects and which should not be bundled to any specific project, or distributed to an audience. These include values such as the local repository location, alternate remote repository servers, and authentication information. There are two locations where a 'settings.xml' file may live:

*  Maven Installation Directory: '$M2_HOME/conf/settings.xml' 

*  User-specific Settings File: '~/.m2/settings.xml'  

Here is an overview of the top elements under settings:

.Overview of top-level elements in settings.xml
----
<settings xmlns="http://maven.apache.org/SETTINGS/1.0.0"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xsi:schemaLocation="http://maven.apache.org/SETTINGS/1.0.0
                              http://maven.apache.org/xsd/settings-1.0.0.xsd">

    <localRepository/>
    <interactiveMode/>
    <usePluginRegistry/>
    <offline/>
    <pluginGroups/>
    <servers/>
    <mirrors/>
    <proxies/>
    <profiles/>
    <activeProfiles/>
</settings>
----

[[appendix-settings-sect-details]]
=== Settings Details

[[appendix-settings-sect-simpleval]]
==== Simple Values

Half of the top-level settings elements are simple values, representing a range of values which configure the core behavior of Maven:

.Simple top-level elements in settings.xml
----
<settings xmlns="http://maven.apache.org/SETTINGS/1.0.0"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xsi:schemaLocation="http://maven.apache.org/SETTINGS/1.0.0
                              http://maven.apache.org/xsd/settings-1.0.0.xsd">
    <localRepository>${user.dir}/.m2/repository</localRepository>
    <interactiveMode>true</interactiveMode>
    <usePluginRegistry>false</usePluginRegistry>
    <offline>false</offline>
    <pluginGroups>
        <pluginGroup>org.codehaus.mojo</pluginGroup>
    </pluginGroups>
    ...
</settings>
----


The simple top-level elements are:

localRepository::

   This value is the path of this build system's local repository. The default value is '+++${user.dir}/.m2/repository+++'.  

interactiveMode::

   +true+ if Maven should attempt to interact with the user for input, +false+ if not. Defaults to +true+.  

usePluginRegistry::

   +true+ if Maven should use the '+++${user.dir}/.m2/plugin-registry.xml+++' file to manage plugin versions, defaults to +false+.  

offline::

   +true+ if this build system should operate in offline mode, defaults to +false+. This element is useful for build servers which cannot connect to a remote repository, either because of network setup or security reasons.  

pluginGroups::

   This element contains a list of +pluginGroup+ elements, each contains a +groupId+. The list is searched when a plugin is used and the +groupId+ is not provided in the command line. This list contains +org.apache.maven.plugins+ by default.

[[appendix-settings-sect-servers]]
==== Servers

The +distributionManagement+ element of the POM defines the repositories for deployment. However, certain settings such as security credentials should not be distributed along with the 'pom.xml'. This type of information should exist on the build server in the 'settings.xml'.

.Server configuration in settings.xml
----
<settings xmlns="http://maven.apache.org/SETTINGS/1.0.0"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xsi:schemaLocation="http://maven.apache.org/SETTINGS/1.0.0
                              http://maven.apache.org/xsd/settings-1.0.0.xsd">
    ...
    <servers>
        <server>
            <id>server001</id>
            <username>my_login</username>
            <password>my_password</password>
            <privateKey>${user.home}/.ssh/id_dsa</privateKey>
            <passphrase>some_passphrase</passphrase>
            <filePermissions>664</filePermissions>
            <directoryPermissions>775</directoryPermissions>
            <configuration></configuration>
        </server>
    </servers>
    ...
</settings>
----

The elements under server are:

id::

   This is the +id+ of the server (not of the user to login as) that matches the +distributionManagement+ repository element's +id+.   

username, password::

   These elements appear as a pair denoting the login and password required to authenticate to this server.   

privateKey, passphrase::

   Like the previous two elements, this pair specifies a path to a private key (default is '+++${user.home}/.ssh/id_dsa+++') and a passphrase, if required. The passphrase and password elements may be externalized in the future, but for now they must be set plain-text in the 'settings.xml' file.   

filePermissions, directoryPermissions::

   When a repository file or directory is created on deployment, these are the permissions to use. The legal values of each is a three digit number corresponding to *nix file permissions, i.e. 664, or 775.

[[appendix-settings-sect-mirrors]]
==== Mirrors

.Mirror configuration in settings.xml
----
<settings xmlns="http://maven.apache.org/SETTINGS/1.0.0"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xsi:schemaLocation="http://maven.apache.org/SETTINGS/1.0.0
                              http://maven.apache.org/xsd/settings-1.0.0.xsd">
    ...
    <mirrors>
        <mirror>
            <id>planetmirror.com</id>
            <name>PlanetMirror Australia</name>
            <url>http://downloads.planetmirror.com/pub/maven2</url>
            <mirrorOf>central</mirrorOf>
        </mirror>
    </mirrors>
    ...
</settings>
----

id, name::

The unique identifier of this mirror. The id is used to differentiate between mirror elements.  

url::

The base URL of this mirror. The build system will use prepend this URL to connect to a repository rather than the default server URL.  

mirrorOf::

The id of the server that this is a mirror of. For example, to point to a mirror of the Maven central server (http://repo1.maven.org/maven2[http://repo1.maven.org/maven2]), set this element to central. This must not match the mirror id.

[[appendix-settings-sect-proxies]]
==== Proxies

.Proxy configuration in settings.xml
----
<settings xmlns="http://maven.apache.org/SETTINGS/1.0.0"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xsi:schemaLocation="http://maven.apache.org/SETTINGS/1.0.0
                              http://maven.apache.org/xsd/settings-1.0.0.xsd">
    ...
    <proxies>
        <proxy>
            <id>myproxy</id>
            <active>true</active>
            <protocol>http</protocol>
            <host>proxy.somewhere.com</host>
            <port>8080</port>
            <username>proxyuser</username>
            <password>somepassword</password>
            <nonProxyHosts>*.google.com|ibiblio.org</nonProxyHosts>
        </proxy>
    </proxies>
    ...
</settings>
----

id::

   The unique identifier for this proxy. This is used to differentiate between proxy elements.  

active::

   +true+ if this proxy is active. This is useful for declaring a set of proxies, but only one may be active at a time.  

protocol, host, port::

   The +protocol://host:port+ of the proxy, separated into discrete elements.  

username, password::

   These elements appear as a pair denoting the login and password required to authenticate to this proxy server.  

nonProxyHosts::

   This is a list of hosts which should not be proxied. The delimiter of the list is the expected type of the proxy server; the example above is pipe delimited - comma delimited is also common.

[[appendix-settings-sect-profiles]]
==== Profiles

The +profile+ element in the 'settings.xml' is a truncated version of the 'pom.xml' profile element. It consists of the +activation+, +repositories+, +pluginRepositories+ and +properties+ elements. The profile elements only include these four elements because they concern themselves with the build system as a whole (which is the role of the 'settings.xml' file), not about individual project object model settings.

If a profile is active from settings, its values will override any equivalent profiles which matching identifiers in a POM or 'profiles.xml' file.  

[[appendix-settings-sect-activation]]
==== Activation

Activations are the key of a profile. Like the POM's profiles, the power of a profile comes from its ability to modify some values only under certain circumstances; those circumstances are specified via an activation element.

.Defining Activation Parameters in settings.xml
----
<settings xmlns="http://maven.apache.org/SETTINGS/1.0.0"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xsi:schemaLocation="http://maven.apache.org/SETTINGS/1.0.0
                              http://maven.apache.org/xsd/settings-1.0.0.xsd">
    ...
    <profiles>
        <profile>
            <id>test</id>
            <activation>
                <activeByDefault>false</activeByDefault>
                <jdk>1.5</jdk>
                <os>
                    <name>Windows XP</name>
                    <family>Windows</family>
                    <arch>x86</arch>
                    <version>5.1.2600</version>
                </os>
                <property>
                    <name>mavenVersion</name>
                    <value>2.0.3</value>
                </property>
                <file>
                    <exists>${basedir}/file2.properties</exists>
                    <missing>${basedir}/file1.properties</missing>
                </file>
            </activation>
            ...
        </profile>
    </profiles>
    ...
</settings>
----

Activation occurs when all specified criteria have been met, though not all are required at once.

jdk::

   activation has a built in, Java-centric check in the jdk element. This will activate if the test is run under a jdk version number that matches the prefix given. In the above example, 1.5.0_06 will match.  

os::

   The +os+ element can define some operating system specific properties shown above.  

property::

   The profile will activate if Maven detects a property (a value which can be dereferenced within the POM by '+++${name}+++') of the corresponding name=value pair.  

file::

   Finally, a given filename may activate the profile by the existence of a file, or if it is missing.   

The +activation+ element is not the only way that a profile may be activated. The 'settings.xml' file's +activeProfile+ element may contain the profile's id. They may also be activated explicitly through the command line via a comma separated list after the P flag (e.g. +-P+ test).

To see which profile will activate in a certain build, use the maven-help-plugin.

----
mvn help:active-profiles
----

[[appendix-settings-sect-properties]]
==== Properties

Maven properties are value placeholder, like properties in Ant. Their values are accessible anywhere within a POM by using the notation '+++${X}+++', where X is the property. They come in five different styles, all accessible from the settings.xml file:

+env.+X::

   Prefixing a variable with +env.+ will return the shell’s environment variable. For example, '+++${env.PATH}+++' contains the +++$path+++ environment variable. (+%PATH%+ in Windows.)  

+project.+x::

   A dot-notated (.) path in the POM will contain the corresponding elements value.  

+settings.+x::

   A dot-notated (.) path in the 'settings.xml' will contain the corresponding elements value.  

Java system properties::

   All properties accessible via +java.lang.System.getProperties()+ are available as POM properties, such as '+++${java.home}+++'.  

x::

   Set within a +properties+ element or an external file, the value may be used as <varname role="keep-together">'+++${someVar}+++'.   

.Setting the '+++${user.install}+++' property in settings.xml
----
<settings xmlns="http://maven.apache.org/SETTINGS/1.0.0"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xsi:schemaLocation="http://maven.apache.org/SETTINGS/1.0.0
                              http://maven.apache.org/xsd/settings-1.0.0.xsd">
    ...
    <profiles>
        <profile>
            ...
            <properties>
                <user.install>${user.dir}/our-project</user.install>
            </properties>
            ...
        </profile>
    </profiles>
    ...
</settings>
----

The property '+++${user.install}+++' is accessible from a POM if this profile is active. 

[[appendix-settings-sect-settings-repository]]
==== Repositories

Repositories are remote collections of projects from which Maven uses to populate the local repository of the build system. It is from this local repository that Maven calls it plugins and dependencies. Different remote repositories may contain different projects, and under the active profile they may be searched for a matching release or snapshot artifact.

.Repository Configuration in settings.xml
----
<settings xmlns="http://maven.apache.org/SETTINGS/1.0.0"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xsi:schemaLocation="http://maven.apache.org/SETTINGS/1.0.0
                              http://maven.apache.org/xsd/settings-1.0.0.xsd">
    ...
    <profiles>
        <profile>
            ...
            <repositories>
                <repository>
                    <id>codehausSnapshots</id>
                    <name>Codehaus Snapshots</name>
                    <releases>
                        <enabled>false</enabled>
                        <updatePolicy>always</updatePolicy>
                        <checksumPolicy>warn</checksumPolicy>
                    </releases>
                    <snapshots>
                        <enabled>true</enabled>
                        <updatePolicy>never</updatePolicy>
                        <checksumPolicy>fail</checksumPolicy>
                    </snapshots>
                    <url>http://snapshots.maven.codehaus.org/maven2</url>
                    <layout>default</layout>
                </repository>
            </repositories>
            <pluginRepositories>
                ...
            </pluginRepositories>
            ...
        </profile>
    </profiles>
    ...
</settings>
----

releases, snapshots::

   These are the policies for each type of artifact, Release or snapshot. With these two sets, a POM has the power to alter the policies for each type independent of the other within a single repository. For example, one may decide to enable only snapshot downloads, possibly for development purposes.  

enabled::

   +true+ or +false+ for whether this repository is enabled for the respective type (releases or snapshots).  

updatePolicy::

   This element specifies how often updates should attempt to occur. Maven will compare the local POMs timestamp to the remote. The choices are: +always+, +daily+ (default), +interval:X+ (where X is an integer in minutes) or +never+.  

checksumPolicy::

   When Maven deploys files to the repository, it also deploys corresponding checksum files. Your options are to +ignore+, +fail+, or +warn+ on missing or incorrect checksums.  

layout::

   In the above description of repositories, it was mentioned that they all follow a common layout. This is mostly correct. Maven 2 has a default layout for its repositories; however, Maven 1.x had a different layout. Use this element to specify which if it is default or legacy. If you are upgrading from Maven 1 to Maven 2, and you want to use the same repository which was used in your Maven 1 build, list the layout as +legacy+.  

[[appendix-settings-sect-plugin-repositories]]
==== Plugin Repositories

The structure of the +pluginRepositories+ element block is similar to the +repositories+ element. The +pluginRepository+ elements each specify a remote location of where Maven can find plugins artifacts.

.Plugin Repositories in settings.xml
----
<settings xmlns="http://maven.apache.org/SETTINGS/1.0.0"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xsi:schemaLocation="http://maven.apache.org/SETTINGS/1.0.0
                              http://maven.apache.org/xsd/settings-1.0.0.xsd">
    ...
    <profiles>
        <profile>
            ...
            <repositories>
                ...
            </repositories>
            <pluginRepositories>
                <pluginRepository>
                    <id>codehausSnapshots</id>
                    <name>Codehaus Snapshots</name>
                    <releases>
                        <enabled>false</enabled>
                        <updatePolicy>always</updatePolicy>
                        <checksumPolicy>warn</checksumPolicy>
                    </releases>
                    <snapshots>
                        <enabled>true</enabled>
                        <updatePolicy>never</updatePolicy>
                        <checksumPolicy>fail</checksumPolicy>
                    </snapshots>
                    <url>http://snapshots.maven.codehaus.org/maven2</url>
                    <layout>default</layout>
                </pluginRepository>
            </pluginRepositories>
            ...
        </profile>
    </profiles>
    ...
</settings>
----

[[appendix-settings-sect-active-profiles]]
==== Active Profiles

.Setting active profiles in settings.xml
----
<settings xmlns="http://maven.apache.org/SETTINGS/1.0.0"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xsi:schemaLocation="http://maven.apache.org/SETTINGS/1.0.0
                              http://maven.apache.org/xsd/settings-1.0.0.xsd">
    ...
    <activeProfiles>
        <activeProfile>env-test</activeProfile>
    </activeProfiles>
</settings>
----

The final piece of the 'settings.xml' puzzle is the +activeProfiles+ element. This contains a set of +activeProfile+ elements, which each have a value of a profile id. Any profile id defined as an +activeProfile+ will be active, regardless of any environment settings. If no matching profile is found nothing will happen. For example, if +env-test+ is an +activeProfile+, a +profile+ in a 'pom.xml' (or 'profile.xml' with a corresponding id it will be active. If no such profile is found then execution will continue as normal. 

[[appendix-settings-sect-encrypting-passwords]]
==== Encrypting Passwords in Maven Settings

Once you start to use Maven to deploy software to remote repositories and to interact with source control systems directly, you will start to collect a number of passwords in your Maven Settings and without a mechanism for encrypting these passwords, a developer's '~/.m2/settings.xml' will quickly become a security risk as it will contain plain-text passwords to source control and repository managers. Maven 2.1 introduced a facility to encrypt passwords in a user's Maven Settings ('~/.m2/settings.xml'). To do this, you must first create a master password and store this master password in a 'security-settings.xml' file in '~/.m2/settings-security.xml'. You can then use this master password to encrypt passwords stored in Maven Settings ('~/.m2/settings.xml').

To illustrate this feature, consider the process Maven uses to retrieve an unencrypted server password for a user's Maven Settings as shown in <<fig-settings-unencrypted>>. A user will reference a named server using an identifier in a project's POM, Maven looks for a matching server in Maven Settings. When it finds a matching server element in Maven Settings, Maven will then use the password associated with that server element and send this password along to the server. The password is stored as plain-text in '~/.m2/settings.xml' and it is readily available to anyone who has read access to this file.

[[fig-settings-unencrypted]]
.Storing Unencrypted Passwords in Maven Settings
image::figs/web/settings_password-no-encryption.png[]

Next, consider the process Maven uses to support encrypted passwords as shown in <<fig-settings-encrypted>>.

[[fig-settings-encrypted]]
.Storing Encrypted Passwords in Maven Settings
image::figs/web/settings_password-encryption.png[]

To configure encrypted passwords, create a master password by running +mvn -emp+ or +mvn --encrypt-master-password+ followed by your master password.

----
$ mvn -emp mypassword
{rsB56BJcqoEHZqEZ0R1VR4TIspmODx1Ln8/PVvsgaGw=}
----

Maven prints out an encrypted copy of the password to standard out. Copy this encrypted password and paste it into a '~/.m2/settings-security.xml' file as shown in

[[ex-settings-master-password]]
.settings-security.xml with Master Password
----
<settingsSecurity>
    <master>{rsB56BJcqoEHZqEZ0R1VR4TIspmODx1Ln8/PVvsgaGw=}</master>
</settingsSecurity>
----

After you have created a master password, you can then encrypt passwords for use in your Maven Settings. To encrypt a password with the master password, run +mvn -ep+ or +mvn --encrypt-password+. Assume that you have a repository manager and you need to send a username of "deployment" and a password of "qualityFIRST". To encrypt this particular password, you would run the following command:

----
$ mvn -ep qualityFIRST
{uMrbEOEf/VQHnc0W2X49Qab75j9LSTwiM3mg2LCrOzI=}
----

At this point, copy the encrypted password printed from the output of +mvn -ep+ and paste it into your Maven Settings.


.Storing an Encrypted Password in Maven Settings (~/.m2/settings.xml)
----
<settings>
    <servers>
        <server>
            <id>nexus</id>
            <username>deployment</username>
            <password>{uMrbEOEf/VQHnc0W2X49Qab75j9LSTwiM3mg2LCrOzI=}</password>
        </server>
    </servers>
    ...
</settings>
----

When you run a Maven build that needs to interact with the repository manager, Maven will retrieve the Master password from the '~/.m2/settings-security.xml' file and use this master password to decrypt the password stored in your '~/.m2/settings.xml' file. Maven will then send the decrypted password to the server.

What does this buy you? It allows you to avoid storing your passwords in '~/.m2/settings.xml' as plain-text passwords providing you with the peace of mind that your critical passwords are not being stored, unprotected in a Maven Settings file. Note that this feature does not provide for encryption of the password while it is being sent to the remote server. An enterprising attacker could still capture the password using a network analysis tool.

For an extra level of security, you can encourage your developers to store the encrypted master password on a removable storage device like a USB hard drive. Using this method, a developer would plug a removable drive into a workstation when she wanted to perform a deployment or interact with a remote server. To support this, your '~/.m2/settings-security.xml' file would contain a reference to the location of the 'settings-security.xml' file using the relocation element.

.Configuring Relocation of the Master Password
----
<settingsSecurity>
    <relocation>/Volumes/usb-key/settings-security.xml</relocation>
</settingsSecurity>
----

The developer would then store the 'settings-security.xml' file at '/Volumes/usb-key/settings-security.xml' which would only be available if the developer were sitting at the workstation.   

[[appendix-enterprise]]
== Appendix: Sun Specification Alternatives

The Apache Geronimo project maintains implementations of various enterprise Java specifications. <<table-spec-alternatives>> lists the artifactId and artifact version for all of the specifications implemented by the Geronimo project. To use one of these dependencies, use a groupId of +org.apache.geronimo.specs+, locate the version of the Specification you want to use and reference the dependency with the Artifact Id and Artifact Version listed in <<table-spec-alternatives>>.

NOTE: All artifacts in <<table-spec-alternatives>>, have a groupId of +org.apache.geronimo.specs+. 

[[table-spec-alternatives]]
.Alternate Spec Implementations Artifacts
|========================================
| Specification | Spec Version | Artifact Id | Artifact Version 
| Activation | 1.0.2 | geronimo-activation_1.0.2_spec | 1.2 
| Activation | 1.1 | geronimo-activation_1.1_spec | 1.0.1 
| Activation | 1.0 | geronimo-activation_1.0_spec | 1.1 
| CommonJ | 1.1 | geronimo-commonj_1.1_spec | 1.0 
| Corba | 2.3 | geronimo-corba_2.3_spec | 1.1 
| Corba | 3.0 | geronimo-corba_3.0_spec | 1.2 
| EJB | 2.1 | geronimo-ejb_2.1_spec | 1.1 
| EJB | 3.0 | geronimo-ejb_3.0_spec | 1.0 
| EL | 1.0 | geronimo-el_1.0_spec | 1.0 
| Interceptor | 3.0 | geronimo-interceptor_3.0_spec | 1.0 
| J2EE Connector | 1.5 | geronimo-j2ee-connector_1.5_spec | 1.1.1 
| J2EE Deployment | 1.1 | geronimo-j2ee-deployment_1.1_spec | 1.1 
| J2EE JACC | 1.0 | geronimo-j2ee-jacc_1.0_spec | 1.1.1 
| J2EE Management | 1.0 | geronimo-j2ee-management_1.0_spec | 1.1 
| J2EE Management | 1.1 | geronimo-j2ee-management_1.1_spec | 1.0 
| J2EE | 1.4 | geronimo-j2ee_1.4_spec | 1.1 
| JACC | 1.1 | geronimo-jacc_1.1_spec | 1.0 
| JEE Deployment | 1.1MR3 | geronimo-javaee-deployment_1.1MR3_spec | 1.0 
| JavaMail | 1.3.1 | geronimo-javamail_1.3.1_spec | 1.3 
| JavaMail | 1.4 | geronimo-javamail_1.4_spec | 1.2 
| JAXR | 1.0 | geronimo-jaxr_1.0_spec | 1.1 
| JAXRPC | 1.1 | geronimo-jaxrpc_1.1_spec | 1.1 
| JMS | 1.1 | geronimo-jms_1.1_spec | 1.1
| JPA | 3.0 | geronimo-jpa_3.0_spec | 1.1 
| JSP | 2.0 | geronimo-jsp_2.0_spec | 1.1 
| JSP | 2.1 | geronimo-jsp_2.1_spec | 1.0 
| JTA | 1.0.1B | geronimo-jta_1.0.1B_spec | 1.1.1 
| JTA | 1.1 | geronimo-jta_1.1_spec | 1.1 
| QName | 1.1 | geronimo-qname_1.1_spec | 1.1 
| SAAJ | 1.1 | geronimo-saaj_1.1_spec | 1.1 
| Servlet | 2.4 | geronimo-servlet_2.4_spec | 1.1.1 
| Servlet | 2.5 | geronimo-servlet_2.5_spec | 1.1.1 
| STaX API | 1.0 | geronimo-stax-api_1.0_spec | 1.0.1 
| WS Metadata | 2.0 | geronimo-ws-metadata_2.0_spec | 1.1.1 
|=======================================

NOTE: The version numbers in the Artifact Version column may be out of date by the time you read this book. To check on the version number, visit http://repo1.maven.org/maven2/org/apache/geronimo/specs/[http://repo1.maven.org/maven2/org/apache/geronimo/specs/] in a web browser, and click on the artifactId you want to add. Choose the highest version of the spec you want to depend upon.

To illustrate how one would use <<table-spec-alternatives>>, if we wanted to write some code in our project which interacted with the JTA 1.0.1B specification, we would need to add the following dependency to our project:

.Adding JTA 1.0.1B to a Maven Project
----
<dependency>
    <groupId>org.apache.geronimo.specs</groupId>
    <artifactId>geronimo-jta_1.0.1B_spec</artifactId>
    <version>1.1.1</version>
</dependency>
----

Notice how the version of the artifact isn't going to line up with the version of the specification—the previous dependency configuration adds version 1.0.1B of the JTA specification using the artifact version of 1.1.1. Be aware of this when depending on the alternate Geronimo implementations, and always double check that you are using the latest artifact version number for your specifications. 


[[appendix-license]]
== Creative Commons License

This work is licensed under a Creative Commons Attribution-Noncommercial-No Derivative Works 3.0 United States license. For more information about this license, see http://creativecommons.org/licenses/by-nc-nd/3.0/us/[http://creativecommons.org/licenses/by-nc-nd/3.0/us/]. You are free to share, copy, distribute, display, and perform the work under the following conditions:

*  You must attribute the work to Sonatype, Inc. with a link to http://www.sonatype.com[http://www.sonatype.com]. 

*  You may not use this work for commercial purposes. 

*  You may not alter, transform, or build upon this work.  

If you redistribute this work on a web page, you must include the following link with the URL in the about attribute listed on a single line (remove the backslashes and join all URL parameters):

----

<div xmlns:cc="http://creativecommons.org/ns#" 
     about="http://creativecommons.org/license/results-one?q_1=2&q_1=1\
            &field_commercial=n&field_derivatives=n&field_jurisdiction=us\
            &field_format=StillImage&field_worktitle=Repository%3A+\Management\
            &field_attribute_to_name=Sonatype%2C+Inc.\
            &field_attribute_to_url=http%3A%2F%2Fwww.sonatype.com\
            &field_sourceurl=http%3A%2F%2Fwww.sonatype.com%2Fbook\
            &lang=en_US&language=en_US&n_questions=3">
    <a rel="cc:attributionURL" property="cc:attributionName" 
       href="http://www.sonatype.com">Sonatype, Inc.</a> / 
    <a rel="license" 
       href="http://creativecommons.org/licenses/by-nc-nd/3.0/us/">
        CC BY-NC-ND 3.0</a>
</div>

----

When downloaded or distributed in a jurisdiction other than the United States of America, this work shall be covered by the appropriate ported version of Creative Commons Attribution-Noncommercial-No Derivative Works 3.0 license for the specific jurisdiction. If the Creative Commons Attribution-Noncommercial-No Derivative Works version 3.0 license is not available for a specific jurisdiction, this work shall be covered under the Creative Commons Attribution-Noncommercial-No Derivate Works version 2.5 license for the jurisdiction in which the work was downloaded or distributed. A comprehensive list of jurisdictions for which a Creative Commons license is available can be found on the Creative Commons International web site at http://creativecommons.org/international[http://creativecommons.org/international].

If no ported version of the Creative Commons license exists for a particular jurisdiction, this work shall be covered by the generic, unported Creative Commons Attribution-Noncommercial-No Derivative Works version 3.0 license available from http://creativecommons.org/licenses/by-nc-nd/3.0/[http://creativecommons.org/licenses/by-nc-nd/3.0/].
